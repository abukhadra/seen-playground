/*version: 0.1.5*/
export function SeenEditor(id, parent, opts) { 
                opts.mode = 'editor'
                const code = `<!doctype html>
<html>
	<head>
		<meta charset="utf-8"/>

		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Expires" content="0">

		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="">
		<meta name="keywords" content=" ">		



		<script> window.opts = '%SEEN_EDITOR__OPTS%' </script>


		 				
		<script type="module">
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
})(void 0, function() {
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\\/\\d/i.test(userAgent);
  var ie_upto10 = /MSIE \\d/.test(userAgent);
  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);
  var edge = /Edge\\/(\\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\\//.test(userAgent);
  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);
  var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);
  var chrome_version = chrome && +chrome[1];
  var presto = /Opera\\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\\bCrOS\\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  }
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;
  function classTest(cls) {
    return new RegExp("(^|\\\\s)" + cls + "(?:\$|\\\\s)\\\\s*");
  }
  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i2 = 0; i2 < content.length; ++i2) {
        e.appendChild(content[i2]);
      }
    }
    return e;
  }
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }
  var range;
  if (document.createRange) {
    range = function(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function(node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }
  function contains2(parent, child) {
    if (child.nodeType == 3) {
      child = child.parentNode;
    }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }
  function activeElt(doc2) {
    var activeElement;
    try {
      activeElement = doc2.activeElement;
    } catch (e) {
      activeElement = doc2.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
  }
  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i2 = 0; i2 < as.length; i2++) {
      if (as[i2] && !classTest(as[i2]).test(b)) {
        b += " " + as[i2];
      }
    }
    return b;
  }
  var selectInput = function(node) {
    node.select();
  };
  if (ios) {
    selectInput = function(node) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    };
  } else if (ie) {
    selectInput = function(node) {
      try {
        node.select();
      } catch (_e) {
      }
    };
  }
  function doc(cm) {
    return cm.display.wrapper.ownerDocument;
  }
  function win(cm) {
    return doc(cm).defaultView;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
      return f.apply(null, args);
    };
  }
  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop2 in obj) {
      if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
        target[prop2] = obj[prop2];
      }
    }
    return target;
  }
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\\s\\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
      var nextTab = string.indexOf("	", i2);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i2);
      }
      n += nextTab - i2;
      n += tabSize - n % tabSize;
      i2 = nextTab + 1;
    }
  }
  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function(self2) {
    self2.id = 0;
    if (self2.time <= +/* @__PURE__ */ new Date()) {
      self2.f();
    } else {
      setTimeout(self2.handler, self2.time - +/* @__PURE__ */ new Date());
    }
  };
  Delayed.prototype.set = function(ms, f) {
    this.f = f;
    var time = +/* @__PURE__ */ new Date() + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };
  function indexOf(array, elt2) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      if (array[i2] == elt2) {
        return i2;
      }
    }
    return -1;
  }
  var scrollerGap = 50;
  var Pass = { toString: function() {
    return "CodeMirror.Pass";
  } };
  var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0; ; ) {
      var nextTab = string.indexOf("	", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }
  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function map(array, f) {
    var out = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      out[i2] = f(array[i2], i2);
    }
    return out;
  }
  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }
  function nothing() {
  }
  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }
  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;
  function isWordCharBasic(ch) {
    return /\\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }
  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }
  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }
    return pos;
  }
  function findFirst(pred, from, to) {
    var dir = from > to ? -1 : 1;
    for (; ; ) {
      if (from == to) {
        return from;
      }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) {
        return pred(mid) ? from : to;
      }
      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  }
  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }
    var found = false;
    for (var i2 = 0; i2 < order.length; ++i2) {
      var part = order[i2];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }
  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i2 = 0; i2 < order.length; ++i2) {
      var cur = order[i2];
      if (cur.from < ch && cur.to > ch) {
        return i2;
      }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i2;
        } else {
          bidiOther = i2;
        }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i2;
        } else {
          bidiOther = i2;
        }
      }
    }
    return found != null ? found : bidiOther;
  }
  var bidiOrdering = /* @__PURE__ */ function() {
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 247) {
        return lowTypes.charAt(code);
      } else if (1424 <= code && code <= 1524) {
        return "R";
      } else if (1536 <= code && code <= 1785) {
        return arabicTypes.charAt(code - 1536);
      } else if (1774 <= code && code <= 2220) {
        return "r";
      } else if (8192 <= code && code <= 8203) {
        return "w";
      } else if (code == 8204) {
        return "b";
      } else {
        return "L";
      }
    }
    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }
    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";
      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }
      var len = str.length, types = [];
      for (var i2 = 0; i2 < len; ++i2) {
        types.push(charType(str.charCodeAt(i2)));
      }
      for (var i\$12 = 0, prev = outerType; i\$12 < len; ++i\$12) {
        var type2 = types[i\$12];
        if (type2 == "m") {
          types[i\$12] = prev;
        } else {
          prev = type2;
        }
      }
      for (var i\$22 = 0, cur = outerType; i\$22 < len; ++i\$22) {
        var type\$1 = types[i\$22];
        if (type\$1 == "1" && cur == "r") {
          types[i\$22] = "n";
        } else if (isStrong.test(type\$1)) {
          cur = type\$1;
          if (type\$1 == "r") {
            types[i\$22] = "R";
          }
        }
      }
      for (var i\$3 = 1, prev\$1 = types[0]; i\$3 < len - 1; ++i\$3) {
        var type\$2 = types[i\$3];
        if (type\$2 == "+" && prev\$1 == "1" && types[i\$3 + 1] == "1") {
          types[i\$3] = "1";
        } else if (type\$2 == "," && prev\$1 == types[i\$3 + 1] && (prev\$1 == "1" || prev\$1 == "n")) {
          types[i\$3] = prev\$1;
        }
        prev\$1 = type\$2;
      }
      for (var i\$4 = 0; i\$4 < len; ++i\$4) {
        var type\$3 = types[i\$4];
        if (type\$3 == ",") {
          types[i\$4] = "N";
        } else if (type\$3 == "%") {
          var end = void 0;
          for (end = i\$4 + 1; end < len && types[end] == "%"; ++end) {
          }
          var replace2 = i\$4 && types[i\$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i\$4; j < end; ++j) {
            types[j] = replace2;
          }
          i\$4 = end - 1;
        }
      }
      for (var i\$5 = 0, cur\$1 = outerType; i\$5 < len; ++i\$5) {
        var type\$4 = types[i\$5];
        if (cur\$1 == "L" && type\$4 == "1") {
          types[i\$5] = "L";
        } else if (isStrong.test(type\$4)) {
          cur\$1 = type\$4;
        }
      }
      for (var i\$6 = 0; i\$6 < len; ++i\$6) {
        if (isNeutral.test(types[i\$6])) {
          var end\$1 = void 0;
          for (end\$1 = i\$6 + 1; end\$1 < len && isNeutral.test(types[end\$1]); ++end\$1) {
          }
          var before = (i\$6 ? types[i\$6 - 1] : outerType) == "L";
          var after = (end\$1 < len ? types[end\$1] : outerType) == "L";
          var replace\$1 = before == after ? before ? "L" : "R" : outerType;
          for (var j\$1 = i\$6; j\$1 < end\$1; ++j\$1) {
            types[j\$1] = replace\$1;
          }
          i\$6 = end\$1 - 1;
        }
      }
      var order = [], m;
      for (var i\$7 = 0; i\$7 < len; ) {
        if (countsAsLeft.test(types[i\$7])) {
          var start = i\$7;
          for (++i\$7; i\$7 < len && countsAsLeft.test(types[i\$7]); ++i\$7) {
          }
          order.push(new BidiSpan(0, start, i\$7));
        } else {
          var pos = i\$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i\$7; i\$7 < len && types[i\$7] != "L"; ++i\$7) {
          }
          for (var j\$2 = pos; j\$2 < i\$7; ) {
            if (countsAsNum.test(types[j\$2])) {
              if (pos < j\$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j\$2));
                at += isRTL;
              }
              var nstart = j\$2;
              for (++j\$2; j\$2 < i\$7 && countsAsNum.test(types[j\$2]); ++j\$2) {
              }
              order.splice(at, 0, new BidiSpan(2, nstart, j\$2));
              at += isRTL;
              pos = j\$2;
            } else {
              ++j\$2;
            }
          }
          if (pos < i\$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i\$7));
          }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\\s+\$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }
      return direction == "rtl" ? order.reverse() : order;
    };
  }();
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }
    return order;
  }
  var noHandlers = [];
  var on = function(emitter, type2, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type2, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type2, f);
    } else {
      var map2 = emitter._handlers || (emitter._handlers = {});
      map2[type2] = (map2[type2] || noHandlers).concat(f);
    }
  };
  function getHandlers(emitter, type2) {
    return emitter._handlers && emitter._handlers[type2] || noHandlers;
  }
  function off(emitter, type2, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type2, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type2, f);
    } else {
      var map2 = emitter._handlers, arr = map2 && map2[type2];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map2[type2] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }
  function signal(emitter, type2) {
    var handlers = getHandlers(emitter, type2);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i2 = 0; i2 < handlers.length; ++i2) {
      handlers[i2].apply(null, args);
    }
  }
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = { type: e, preventDefault: function() {
        this.defaultPrevented = true;
      } };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i2 = 0; i2 < arr.length; ++i2) {
      if (indexOf(set, arr[i2]) == -1) {
        set.push(arr[i2]);
      }
    }
  }
  function hasHandler(emitter, type2) {
    return getHandlers(emitter, type2).length > 0;
  }
  function eventMixin(ctor) {
    ctor.prototype.on = function(type2, f) {
      on(this, type2, f);
    };
    ctor.prototype.off = function(type2, f) {
      off(this, type2, f);
    };
  }
  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }
  var dragAndDrop = function() {
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt("div");
    return "draggable" in div || "dragDrop" in div;
  }();
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "​");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    }
    return badBidiRects = r1.right - r0.right < 3;
  }
  var splitLinesAuto = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);
      var rt = line.indexOf("\\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string) {
    return string.split(/\\r\\n?|\\n/);
  };
  var hasSelection = window.getSelection ? function(te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function(te) {
    var range2;
    try {
      range2 = te.ownerDocument.selection.createRange();
    } catch (e) {
    }
    if (!range2 || range2.parentElement() != te) {
      return false;
    }
    return range2.compareEndPoints("StartToEnd", range2) != 0;
  };
  var hasCopyEvent = function() {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();
  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }
  var modes = {}, mimeModes = {};
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }
  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = { name: found };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml\$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+json\$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return { name: spec };
    } else {
      return spec || { name: "null" };
    }
  }
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop2 in exts) {
        if (!exts.hasOwnProperty(prop2)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop2)) {
          modeObj["_" + prop2] = modeObj[prop2];
        }
        modeObj[prop2] = exts[prop2];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop\$1 in spec.modeProps) {
        modeObj[prop\$1] = spec.modeProps[prop\$1];
      }
    }
    return modeObj;
  }
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }
  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || { mode, state };
  }
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };
  StringStream.prototype.eol = function() {
    return this.pos >= this.string.length;
  };
  StringStream.prototype.sol = function() {
    return this.pos == this.lineStart;
  };
  StringStream.prototype.peek = function() {
    return this.string.charAt(this.pos) || void 0;
  };
  StringStream.prototype.next = function() {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };
  StringStream.prototype.eat = function(match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }
    if (ok) {
      ++this.pos;
      return ch;
    }
  };
  StringStream.prototype.eatWhile = function(match) {
    var start = this.pos;
    while (this.eat(match)) {
    }
    return this.pos > start;
  };
  StringStream.prototype.eatSpace = function() {
    var start = this.pos;
    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this.pos;
    }
    return this.pos > start;
  };
  StringStream.prototype.skipToEnd = function() {
    this.pos = this.string.length;
  };
  StringStream.prototype.skipTo = function(ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  };
  StringStream.prototype.backUp = function(n) {
    this.pos -= n;
  };
  StringStream.prototype.column = function() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.indentation = function() {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function(str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }
        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) {
        return null;
      }
      if (match && consume !== false) {
        this.pos += match[0].length;
      }
      return match;
    }
  };
  StringStream.prototype.current = function() {
    return this.string.slice(this.start, this.pos);
  };
  StringStream.prototype.hideFirstChars = function(n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };
  StringStream.prototype.lookAhead = function(n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };
  StringStream.prototype.baseToken = function() {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };
  function getLine(doc2, n) {
    n -= doc2.first;
    if (n < 0 || n >= doc2.size) {
      throw new Error("There is no line " + (n + doc2.first) + " in the document.");
    }
    var chunk = doc2;
    while (!chunk.lines) {
      for (var i2 = 0; ; ++i2) {
        var child = chunk.children[i2], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc2, start, end) {
    var out = [], n = start.line;
    doc2.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc2, from, to) {
    var out = [];
    doc2.iter(from, to, function(line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i2 = 0; ; ++i2) {
        if (chunk.children[i2] == cur) {
          break;
        }
        no += chunk.children[i2].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i\$12 = 0; i\$12 < chunk.children.length; ++i\$12) {
        var child = chunk.children[i\$12], ch = child.height;
        if (h < ch) {
          chunk = child;
          continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i2 = 0;
    for (; i2 < chunk.lines.length; ++i2) {
      var line = chunk.lines[i2], lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i2;
  }
  function isLine(doc2, l) {
    return l >= doc2.first && l < doc2.first + doc2.size;
  }
  function lineNumberFor(options, i2) {
    return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
  }
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;
    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }
  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }
  function clipLine(doc2, n) {
    return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
  }
  function clipPos(doc2, pos) {
    if (pos.line < doc2.first) {
      return Pos(doc2.first, 0);
    }
    var last = doc2.first + doc2.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc2, last).text.length);
    }
    return clipToLen(pos, getLine(doc2, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc2, array) {
    var out = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      out[i2] = clipPos(doc2, array[i2]);
    }
    return out;
  }
  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };
  var Context = function(doc2, state, line, lookAhead) {
    this.state = state;
    this.doc = doc2;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };
  Context.prototype.lookAhead = function(n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }
    return line;
  };
  Context.prototype.baseToken = function(n) {
    if (!this.baseTokens) {
      return null;
    }
    while (this.baseTokens[this.baseTokenPos] <= n) {
      this.baseTokenPos += 2;
    }
    var type2 = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type2 && type2.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };
  Context.prototype.nextLine = function() {
    this.line++;
    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };
  Context.fromSaved = function(doc2, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc2, copyState(doc2.mode, saved), line);
    }
  };
  Context.prototype.save = function(copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  };
  function highlightLine(cm, line, context, forceToEnd) {
    var st = [cm.state.modeGen], lineClasses = {};
    runMode(
      cm,
      line.text,
      cm.doc.mode,
      context,
      function(end, style) {
        return st.push(end, style);
      },
      lineClasses,
      forceToEnd
    );
    var state = context.state;
    var loop = function(o2) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function(end, style) {
        var start = i2;
        while (at < end) {
          var i_end = st[i2];
          if (i_end > end) {
            st.splice(i2, 1, end, st[i2 + 1], i_end);
          }
          i2 += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i2 - start, end, "overlay " + style);
          i2 = start + 2;
        } else {
          for (; start < i2; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };
    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
    return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
  }
  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) {
        context.state = resetState;
      }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }
    return line.styles;
  }
  function getContextBefore(cm, n, precise) {
    var doc2 = cm.doc, display = cm.display;
    if (!doc2.mode.startState) {
      return new Context(doc2, true, n);
    }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc2.first && getLine(doc2, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc2, saved, start) : new Context(doc2, startState(doc2.mode), start);
    doc2.iter(start, n, function(line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) {
      doc2.modeFrontier = context.line;
    }
    return context;
  }
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, context.state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }
  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }
  function readToken(mode, stream, state, inner) {
    for (var i2 = 0; i2 < 10; i2++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }
  var Token2 = function(stream, type2, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type2 || null;
    this.state = state;
  };
  function takeToken(cm, pos, precise, asArray) {
    var doc2 = cm.doc, mode = doc2.mode, style;
    pos = clipPos(doc2, pos);
    var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) {
        tokens.push(new Token2(stream, style, copyState(doc2.mode, context.state)));
      }
    }
    return asArray ? tokens : new Token2(stream, style, context.state);
  }
  function extractLineClasses(type2, output2) {
    if (type2) {
      for (; ; ) {
        var lineClass = type2.match(/(?:^|\\s+)line-(background-)?(\\S+)/);
        if (!lineClass) {
          break;
        }
        type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
        var prop2 = lineClass[1] ? "bgClass" : "textClass";
        if (output2[prop2] == null) {
          output2[prop2] = lineClass[2];
        } else if (!new RegExp("(?:^|\\\\s)" + lineClass[2] + "(?:\$|\\\\s)").test(output2[prop2])) {
          output2[prop2] += " " + lineClass[2];
        }
      }
    }
    return type2;
  }
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5e3);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      var pos = Math.min(stream.pos, curStart + 5e3);
      f(pos, curStyle);
      curStart = pos;
    }
  }
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc2 = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc2.first) {
        return doc2.first;
      }
      var line = getLine(doc2, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function retreatFrontier(doc2, n) {
    doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
    if (doc2.highlightFrontier < n - 10) {
      return;
    }
    var start = doc2.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc2, line).stateAfter;
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }
    doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start);
  }
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }
  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }
  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i2 = 0; i2 < spans.length; ++i2) {
        var span = spans[i2];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i2 = 0; i2 < spans.length; ++i2) {
      if (spans[i2] != span) {
        (r || (r = [])).push(spans[i2]);
      }
    }
    return r;
  }
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) {
        inThisOp.add(line.markedSpans);
      }
    }
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i2 = 0; i2 < old.length; ++i2) {
        var span = old[i2], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i2 = 0; i2 < old.length; ++i2) {
        var span = old[i2], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(
            marker,
            startsBefore ? null : span.from - endCh,
            span.to == null ? null : span.to - endCh
          ));
        }
      }
    }
    return nw;
  }
  function stretchSpansOverChange(doc2, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
    var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i2 = 0; i2 < first.length; ++i2) {
        var span = first[i2];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      for (var i\$12 = 0; i\$12 < last.length; ++i\$12) {
        var span\$1 = last[i\$12];
        if (span\$1.to != null) {
          span\$1.to += offset;
        }
        if (span\$1.from == null) {
          var found\$1 = getMarkedSpanFor(first, span\$1.marker);
          if (!found\$1) {
            span\$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span\$1);
            }
          }
        } else {
          span\$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span\$1);
          }
        }
      }
    }
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first) {
        for (var i\$22 = 0; i\$22 < first.length; ++i\$22) {
          if (first[i\$22].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i\$22].marker, null, null));
          }
        }
      }
      for (var i\$3 = 0; i\$3 < gap; ++i\$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function clearEmptySpans(spans) {
    for (var i2 = 0; i2 < spans.length; ++i2) {
      var span = spans[i2];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i2--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }
  function removeReadOnlyRanges(doc2, from, to) {
    var markers = null;
    doc2.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) {
        for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
          var mark = line.markedSpans[i3].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{ from, to }];
    for (var i2 = 0; i2 < markers.length; ++i2) {
      var mk = markers[i2], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({ from: p.from, to: m.from });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({ from: m.to, to: p.to });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts;
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i2 = 0; i2 < spans.length; ++i2) {
      spans[i2].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i2 = 0; i2 < spans.length; ++i2) {
      spans[i2].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
        sp = sps[i2];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }
  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var i2 = 0; i2 < sps.length; ++i2) {
        var sp = sps[i2];
        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
    var line = getLine(doc2, lineNo2);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i2 = 0; i2 < sps.length; ++i2) {
        var sp = sps[i2];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }
  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return line;
  }
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }
  function visualLineNo(doc2, lineN) {
    var line = getLine(doc2, lineN), vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }
  function visualLineEndNo(doc2, lineN) {
    if (lineN > doc2.lastLine()) {
      return lineN;
    }
    var line = getLine(doc2, lineN), merged;
    if (!lineIsHidden(doc2, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }
  function lineIsHidden(doc2, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
        sp = sps[i2];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc2, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
      sp = line.markedSpans[i2];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
        return true;
      }
    }
  }
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
      var line = chunk.lines[i2];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i\$12 = 0; i\$12 < p.children.length; ++i\$12) {
        var cur = p.children[i\$12];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found\$1 = merged.find(0, true);
      len -= cur.text.length - found\$1.from.ch;
      cur = found\$1.to.line;
      len += cur.text.length - found\$1.to.ch;
    }
    return len;
  }
  function findMaxLine(cm) {
    var d = cm.display, doc2 = cm.doc;
    d.maxLine = getLine(doc2, doc2.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc2.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  var Line = function(text, markedSpans, estimateHeight2) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight2 ? estimateHeight2(this) : 1;
  };
  Line.prototype.lineNo = function() {
    return lineNo(this);
  };
  eventMixin(Line);
  function updateLine(line, text, markedSpans, estimateHeight2) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\\s*\$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\\S+/g, "cm-\$&"));
  }
  function buildLineContent(cm, lineView) {
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content,
      col: 0,
      pos: 0,
      cm,
      trailingSpace: false,
      splitSpaces: cm.getOption("lineWrapping")
    };
    lineView.measure = {};
    for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
      var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }
      if (i2 == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }
    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }
    return builder;
  }
  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "•", "cm-invalidchar");
    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt\$1 = void 0;
        if (m[0] == "	") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt\$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt\$1.setAttribute("role", "presentation");
          txt\$1.setAttribute("cm-text", "	");
          builder.col += tabWidth;
        } else if (m[0] == "\\r" || m[0] == "\\n") {
          txt\$1 = content.appendChild(elt("span", m[0] == "\\r" ? "␍" : "␤", "cm-invalidchar"));
          txt\$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt\$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt\$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt\$1]));
          } else {
            content.appendChild(txt\$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt\$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
            token.setAttribute(attr, attributes[attr]);
          }
        }
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore, result = "";
    for (var i2 = 0; i2 < text.length; i2++) {
      var ch = text.charAt(i2);
      if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
        ch = " ";
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (; ; ) {
        var part = void 0;
        for (var i2 = 0; i2 < order.length; i2++) {
          part = order[i2];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, css, attributes);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i\$12 = 1; i\$12 < styles.length; i\$12 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i\$12]), interpretTokenStyle(styles[i\$12 + 1], builder.cm.options));
      }
      return;
    }
    var len = allText.length, pos = 0, i2 = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (; ; ) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [], endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            if (m.title) {
              (attributes || (attributes = {})).title = m.title;
            }
            if (m.attributes) {
              for (var attr in m.attributes) {
                (attributes || (attributes = {}))[attr] = m.attributes[attr];
              }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j\$1 = 0; j\$1 < endStyles.length; j\$1 += 2) {
            if (endStyles[j\$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j\$1];
            }
          }
        }
        if (!collapsed || collapsed.from == pos) {
          for (var j\$2 = 0; j\$2 < foundBookmarks.length; ++j\$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j\$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(
            builder,
            (collapsed.to == null ? len + 1 : collapsed.to) - pos,
            collapsed.marker,
            collapsed.from == null
          );
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(
              builder,
              tokenText,
              style ? style + spanStyle : spanStyle,
              spanStartStyle,
              pos + tokenText.length == nextChange ? spanEndStyle : "",
              css,
              attributes
            );
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i2++]);
        style = interpretTokenStyle(styles[i2++], builder.cm.options);
      }
    }
  }
  function LineView(doc2, line, lineN) {
    this.line = line;
    this.rest = visualLineContinued(line);
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc2, line);
  }
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }
  var operationGroup = null;
  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }
  function fireCallbacksForOps(group) {
    var callbacks = group.delayedCallbacks, i2 = 0;
    do {
      for (; i2 < callbacks.length; i2++) {
        callbacks[i2].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i2 < callbacks.length);
  }
  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }
    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }
  var orphanDelayedCallbacks = null;
  function signalLater(emitter, type2) {
    var arr = getHandlers(emitter, type2);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function(i3) {
      list.push(function() {
        return arr[i3].apply(null, args);
      });
    };
    for (var i2 = 0; i2 < arr.length; ++i2)
      loop(i2);
  }
  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i2 = 0; i2 < delayed.length; ++i2) {
      delayed[i2]();
    }
  }
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type2 = lineView.changes[j];
      if (type2 == "text") {
        updateLineText(cm, lineView);
      } else if (type2 == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type2 == "class") {
        updateLineClasses(cm, lineView);
      } else if (type2 == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }
  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }
  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }
  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt(
        "div",
        null,
        "CodeMirror-gutter-background " + lineView.line.gutterClass,
        "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"
      );
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap\$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap\$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(
          elt(
            "div",
            lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"
          )
        );
      }
      if (markers) {
        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
          if (found) {
            gutterWrap.appendChild(elt(
              "div",
              [found],
              "CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"
            ));
          }
        }
      }
    }
  }
  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }
    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
        insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
      }
    }
  }
  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
      var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }
  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }
  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains2(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }
  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i2 = 0; i2 < rects.length - 1; i2++) {
          var cur = rects[i2], next = rects[i2 + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return { map: lineView.measure.map, cache: lineView.measure.cache };
    }
    if (lineView.rest) {
      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
        if (lineView.rest[i2] == line) {
          return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
        }
      }
      for (var i\$12 = 0; i\$12 < lineView.rest.length; i\$12++) {
        if (lineNo(lineView.rest[i\$12]) > lineN) {
          return { map: lineView.measure.maps[i\$12], cache: lineView.measure.caches[i\$12], before: true };
        }
      }
    }
  }
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }
    var info = mapFromLineView(view, line, lineN);
    return {
      line,
      view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  }
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }
  var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
  function nodeAndOffsetInLineMap(map2, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    for (var i2 = 0; i2 < map2.length; i2 += 3) {
      mStart = map2[i2];
      mEnd = map2[i2 + 1];
      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map2[i2 + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
            node = map2[(i2 -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
            node = map2[(i2 += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
  }
  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i2 = 0; i2 < rects.length; i2++) {
        if ((rect = rects[i2]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i\$12 = rects.length - 1; i\$12 >= 0; i\$12--) {
        if ((rect = rects[i\$12]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }
  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
    var rect;
    if (node.nodeType == 3) {
      for (var i\$12 = 0; i\$12 < 4; i\$12++) {
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
      } else {
        rect = nullRect;
      }
    }
    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i2 = 0;
    for (; i2 < heights.length - 1; i2++) {
      if (mid < heights[i2]) {
        break;
      }
    }
    var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top,
      bottom: bot
    };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }
    return result;
  }
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }
  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          lineView.measure.caches[i2] = {};
        }
      }
    }
  }
  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i2 = 0; i2 < cm.display.view.length; i2++) {
      clearLineMeasurementCacheFor(cm.display.view[i2]);
    }
  }
  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }
  function pageScrollX(doc2) {
    if (chrome && android) {
      return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
    }
    return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
  }
  function pageScrollY(doc2) {
    if (chrome && android) {
      return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
    }
    return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
  }
  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) {
      for (var i2 = 0; i2 < widgets.length; ++i2) {
        if (widgets[i2].above) {
          height += widgetHeight(widgets[i2]);
        }
      }
    }
    return height;
  }
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left, top = coords.top;
    if (context == "page") {
      left -= pageScrollX(doc(cm));
      top -= pageScrollY(doc(cm));
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch2, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }
    function getBidi(ch2, partPos2, invert) {
      var part = order[partPos2], right = part.level == 1;
      return get(invert ? ch2 - 1 : ch2, right != invert);
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }
    return val;
  }
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return { left, right: left, top, bottom: top + lineObj.height };
  }
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = outside;
    }
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc2 = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc2.first, 0, null, -1, -1);
    }
    var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
    }
    if (x < 0) {
      x = 0;
    }
    var lineObj = getLine(doc2, lineN);
    for (; ; ) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) {
        return found;
      }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) {
        return rangeEnd;
      }
      lineObj = getLine(doc2, lineN = rangeEnd.line);
    }
  }
  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function(ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function(ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return { begin, end };
  }
  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  }
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }
  function coordsCharInner(cm, lineObj, lineNo2, x, y) {
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    var widgetHeight2 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;
    var order = getOrder(lineObj, cm.doc.direction);
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }
    var chAround = null, boxAround = null;
    var ch = findFirst(function(ch2) {
      var box = measureCharPrepared(cm, preparedMeasure, ch2);
      box.top += widgetHeight2;
      box.bottom += widgetHeight2;
      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }
      if (box.top <= y && box.left <= x) {
        chAround = ch2;
        boxAround = box;
      }
      return true;
    }, begin, end);
    var baseX, sticky, outside = false;
    if (boxAround) {
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      }
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
      var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }
    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
  }
  function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
    var index = findFirst(function(i2) {
      var part2 = order[i2], ltr2 = part2.level != 1;
      return boxIsAfter(cursorCoords(
        cm,
        Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),
        "line",
        lineObj,
        preparedMeasure
      ), x, y, true);
    }, 0, order.length - 1);
    var part = order[index];
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(
        cm,
        Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),
        "line",
        lineObj,
        preparedMeasure
      );
      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }
    return part;
  }
  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }
    var part = null, closestDist = null;
    for (var i2 = 0; i2 < order.length; i2++) {
      var p = order[i2];
      if (p.from >= end || p.to <= begin) {
        continue;
      }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) {
      part = order[order.length - 1];
    }
    if (part.from < begin) {
      part = { from: begin, to: part.to, level: part.level };
    }
    if (part.to > end) {
      part = { from: part.from, to: end, level: part.level };
    }
    return part;
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      for (var i2 = 0; i2 < 49; ++i2) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
      var id2 = cm.display.gutterSpecs[i2].className;
      left[id2] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id2] = n.clientWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }
      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i2 = 0; i2 < line.widgets.length; i2++) {
          if (line.widgets[i2].height) {
            widgetsHeight += line.widgets[i2].height;
          }
        }
      }
      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }
  function estimateLineHeights(cm) {
    var doc2 = cm.doc, est = estimateHeight(cm);
    doc2.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }
    var x, y, space2 = display.lineSpace.getBoundingClientRect();
    try {
      x = e.clientX - space2.left;
      y = e.clientY - space2.top;
    } catch (e\$1) {
      return null;
    }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i2 = 0; i2 < view.length; i2++) {
      n -= view[i2].size;
      if (n < 0) {
        return i2;
      }
    }
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }
    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }
    cm.curOp.viewChanged = true;
    if (from >= display.viewTo) {
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      resetView(cm);
    } else if (from <= display.viewFrom) {
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      var cut\$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut\$1) {
        display.view = display.view.slice(0, cut\$1.index);
        display.viewTo = cut\$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }
    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }
  function regLineChange(cm, line, type2) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }
    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type2) == -1) {
      arr.push(type2);
    }
  }
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }
  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return { index, lineN: newN };
    }
    var n = cm.display.viewFrom;
    for (var i2 = 0; i2 < index; i2++) {
      n += view[i2].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;
      newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return { index, lineN: newN };
  }
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i2 = 0; i2 < view.length; i2++) {
      var lineView = view[i2];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }
  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }
  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc2 = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();
    var customCursor = cm.options.\$customCursor;
    if (customCursor) {
      primary = true;
    }
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      if (!primary && i2 == doc2.sel.primIndex) {
        continue;
      }
      var range2 = doc2.sel.ranges[i2];
      if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range2.empty();
      if (customCursor) {
        var head = customCursor(cm, range2);
        if (head) {
          drawSelectionCursor(cm, head, curFragment);
        }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range2.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range2, selFragment);
      }
    }
    return result;
  }
  function drawSelectionCursor(cm, head, output2) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
    var cursor = output2.appendChild(elt("div", " ", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }
    if (pos.other) {
      var otherCursor = output2.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
    }
  }
  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  }
  function drawSelectionRange(cm, range2, output2) {
    var display = cm.display, doc2 = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc2.direction == "ltr";
    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\\n                             height: " + (bottom - top) + "px"));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc2, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }
      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop2)[prop2];
      }
      var order = getOrder(lineObj, doc2.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i2 == 0, last = !order || i2 == order.length - 1;
        if (toPos.top - fromPos.top <= 3) {
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }
        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }
        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }
        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }
        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return { start, end };
    }
    var sFrom = range2.from(), sTo = range2.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }
    output2.appendChild(fragment);
  }
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on2 = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function() {
        if (!cm.hasFocus()) {
          onBlur(cm);
        }
        display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }
  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) {
        onFocus(cm);
      }
    }
  }
  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        if (cm.state.focused) {
          onBlur(cm);
        }
      }
    }, 100);
  }
  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
      cm.state.delayingBlurEvent = false;
    }
    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function() {
            return cm.display.input.reset(true);
          }, 20);
        }
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }
    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i2 = 0; i2 < display.view.length; i2++) {
      var cur = display.view[i2], wrapping = cm.options.lineWrapping;
      var height = void 0, width = 0;
      if (cur.hidden) {
        continue;
      }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        if (!wrapping && cur.text.firstChild) {
          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
        }
      }
      var diff = cur.line.height - height;
      if (diff > 5e-3 || diff < -5e-3) {
        if (oldHeight < viewTop) {
          mustScroll -= diff;
        }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) {
      display.scroller.scrollTop += mustScroll;
    }
  }
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i2 = 0; i2 < line.widgets.length; ++i2) {
        var w = line.widgets[i2], parent = w.node.parentNode;
        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  }
  function visibleLines(display, doc2, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
    var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
        from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return { from, to: Math.max(to, from + 1) };
  }
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    var doc2 = display.wrapper.ownerDocument;
    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "​", null, "position: absolute;\\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return rect;
  }
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) {
      rect.top = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen2 = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen2) {
      rect.bottom = rect.top + screen2;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen2) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }
    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) {
      rect.right = rect.left + screenw;
    }
    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }
  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
  }
  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }
    if (x != null) {
      cm.curOp.scrollLeft = x;
    }
    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }
  function scrollToRange(cm, range2) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range2;
  }
  function resolveScrollToPos(cm) {
    var range2 = cm.curOp.scrollToPos;
    if (range2) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
      scrollToCoordsRange(cm, from, to, range2.margin);
    }
  }
  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    if (!gecko) {
      updateDisplaySimple(cm, { top: val });
    }
    setScrollTop(cm, val, true);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }
  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  }
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }
  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);
    place(horiz);
    on(vert, "scroll", function() {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false;
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };
  NativeScrollbars.prototype.update = function(measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;
    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }
    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }
    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }
      this.checkedZeroWidth = true;
    }
    return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
  };
  NativeScrollbars.prototype.setScrollLeft = function(pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }
    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };
  NativeScrollbars.prototype.setScrollTop = function(pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }
    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };
  NativeScrollbars.prototype.zeroWidthHack = function() {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.visibility = this.vert.style.visibility = "hidden";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };
  NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {
    bar.style.visibility = "";
    function maybeDisable() {
      var box = bar.getBoundingClientRect();
      var elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt2 != bar) {
        bar.style.visibility = "hidden";
      } else {
        delay.set(1e3, maybeDisable);
      }
    }
    delay.set(1e3, maybeDisable);
  };
  NativeScrollbars.prototype.clear = function() {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };
  var NullScrollbars = function() {
  };
  NullScrollbars.prototype.update = function() {
    return { bottom: 0, right: 0 };
  };
  NullScrollbars.prototype.setScrollLeft = function() {
  };
  NullScrollbars.prototype.setScrollTop = function() {
  };
  NullScrollbars.prototype.clear = function() {
  };
  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  }
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }
  var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      on(node, "mousedown", function() {
        if (cm.state.focused) {
          setTimeout(function() {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: 0,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,
      // Unique ID
      markArrays: null
      // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) {
      finishOperation(op, function(group) {
        for (var i2 = 0; i2 < group.ops.length; i2++) {
          group.ops[i2].cm.curOp = null;
        }
        endOperations(group);
      });
    }
  }
  function endOperations(group) {
    var ops = group.ops;
    for (var i2 = 0; i2 < ops.length; i2++) {
      endOperation_R1(ops[i2]);
    }
    for (var i\$12 = 0; i\$12 < ops.length; i\$12++) {
      endOperation_W1(ops[i\$12]);
    }
    for (var i\$22 = 0; i\$22 < ops.length; i\$22++) {
      endOperation_R2(ops[i\$22]);
    }
    for (var i\$3 = 0; i\$3 < ops.length; i\$3++) {
      endOperation_W2(ops[i\$3]);
    }
    for (var i\$4 = 0; i\$4 < ops.length; i\$4++) {
      endOperation_finish(ops[i\$4]);
    }
  }
  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }
    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
  }
  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }
  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }
    op.barMeasure = measureForScrollbars(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }
    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }
  function endOperation_W2(op) {
    var cm = op.cm;
    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }
    var takeFocus = op.focus && op.focus == activeElt(doc(cm));
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }
    if (op.selectionChanged) {
      restartBlink(cm);
    }
    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }
  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc2 = cm.doc;
    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }
    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }
    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    }
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(
        cm,
        clipPos(doc2, op.scrollToPos.from),
        clipPos(doc2, op.scrollToPos.to),
        op.scrollToPos.margin
      );
      maybeScrollWindow(cm, rect);
    }
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i2 = 0; i2 < hidden.length; ++i2) {
        if (!hidden[i2].lines.length) {
          signal(hidden[i2], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i\$12 = 0; i\$12 < unhidden.length; ++i\$12) {
        if (unhidden[i\$12].lines.length) {
          signal(unhidden[i\$12], "unhide");
        }
      }
    }
    if (display.wrapper.offsetHeight) {
      doc2.scrollTop = cm.display.scroller.scrollTop;
    }
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  function operation(cm, f) {
    return function() {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  function methodOp(f) {
    return function() {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }
  function highlightWorker(cm) {
    var doc2 = cm.doc;
    if (doc2.highlightFrontier >= cm.display.viewTo) {
      return;
    }
    var end = +/* @__PURE__ */ new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc2.highlightFrontier);
    var changedLines = [];
    doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
      if (context.line >= cm.display.viewFrom) {
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) {
          context.state = resetState;
        }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
          ischange = oldStyles[i2] != line.styles[i2];
        }
        if (ischange) {
          changedLines.push(context.line);
        }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+/* @__PURE__ */ new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc2.highlightFrontier = context.line;
    doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function() {
        for (var i2 = 0; i2 < changedLines.length; i2++) {
          regLineChange(cm, changedLines[i2], "text");
        }
      });
    }
  }
  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport;
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };
  DisplayUpdate.prototype.signal = function(emitter, type2) {
    if (hasHandler(emitter, type2)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i2 = 0; i2 < this.events.length; i2++) {
      signal.apply(null, this.events[i2]);
    }
  };
  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }
  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }
    var active = activeElt(doc(cm));
    if (!active || !contains2(cm.display.lineDiv, active)) {
      return null;
    }
    var result = { activeElt: active };
    if (window.getSelection) {
      var sel = win(cm).getSelection();
      if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result;
  }
  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(snapshot.activeElt.ownerDocument)) {
      return;
    }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)\$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
      var doc2 = snapshot.activeElt.ownerDocument;
      var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
      range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range2.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range2);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc2 = cm.doc;
    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }
    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }
    var end = doc2.first + doc2.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc2.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }
    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    restoreSelection(selSnapshot);
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;
    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }
    display.updateLineNumbers = null;
    return true;
  }
  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true; ; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        if (viewport && viewport.top != null) {
          viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
        }
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }
    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }
  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node2) {
      var next = node2.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node2) {
        node2.style.display = "none";
      } else {
        node2.parentNode.removeChild(node2);
      }
      return next;
    }
    var view = display.view, lineN = display.viewFrom;
    for (var i2 = 0; i2 < view.length; i2++) {
      var lineView = view[i2];
      if (lineView.hidden) ;
      else if (!lineView.node || lineView.node.parentNode != container) {
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }
  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    signalLater(display, "gutterChanged", display);
  }
  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i2 = 0; i2 < view.length; i2++) {
      if (!view[i2].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i2].gutter) {
            view[i2].gutter.style.left = left;
          }
          if (view[i2].gutterBackground) {
            view[i2].gutterBackground.style.left = left;
          }
        }
        var align = view[i2].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt(
        "div",
        [elt("div", last)],
        "CodeMirror-linenumber CodeMirror-gutter-elt"
      ));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true;
    }
    return false;
  }
  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i2 = 0; i2 < gutters.length; i2++) {
      var name = gutters[i2], style = null;
      if (typeof name != "string") {
        style = name.style;
        name = name.className;
      }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) {
          continue;
        } else {
          sawLineNumbers = true;
        }
      }
      result.push({ className: name, style });
    }
    if (lineNumbers && !sawLineNumbers) {
      result.push({ className: "CodeMirror-linenumbers", style: null });
    }
    return result;
  }
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i2 = 0; i2 < specs.length; ++i2) {
      var ref = specs[i2];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) {
        gElt.style.cssText = style;
      }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }
  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }
  function Display(place, doc2, input, options) {
    var d = this;
    this.input = input;
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    d.measure = elt("div", null, "CodeMirror-measure");
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    d.lineSpace = eltP(
      "div",
      [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
      null,
      "position: relative; outline: none"
    );
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    d.mover = elt("div", [lines], null, "position: relative");
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    if (chrome && chrome_version >= 105) {
      d.wrapper.style.clipPath = "inset(0px)";
    }
    d.wrapper.setAttribute("translate", "no");
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }
    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }
    d.viewFrom = d.viewTo = doc2.first;
    d.reportedViewFrom = d.reportedViewTo = doc2.first;
    d.view = [];
    d.renderedView = null;
    d.externalMeasured = null;
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    d.shift = false;
    d.selForContextMenu = null;
    d.activeTouch = null;
    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);
    input.init(d);
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie) {
    wheelPixelsPerUnit = -0.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -0.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }
  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return { x: dx, y: dy };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }
  function onScrollWheel(cm, e) {
    if (chrome && chrome_version == 102) {
      if (cm.display.chromeScrollHack == null) {
        cm.display.sizer.style.pointerEvents = "none";
      } else {
        clearTimeout(cm.display.chromeScrollHack);
      }
      cm.display.chromeScrollHack = setTimeout(function() {
        cm.display.chromeScrollHack = null;
        cm.display.sizer.style.pointerEvents = "";
      }, 100);
    }
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }
    var display = cm.display, scroll = display.scroller;
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i2 = 0; i2 < view.length; i2++) {
          if (view[i2].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
      }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null;
      return;
    }
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, { top, bottom: bot });
    }
    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };
  Selection.prototype.primary = function() {
    return this.ranges[this.primIndex];
  };
  Selection.prototype.equals = function(other) {
    if (other == this) {
      return true;
    }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      var here = this.ranges[i2], there = other.ranges[i2];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }
    return true;
  };
  Selection.prototype.deepCopy = function() {
    var out = [];
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
    }
    return new Selection(out, this.primIndex);
  };
  Selection.prototype.somethingSelected = function() {
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      if (!this.ranges[i2].empty()) {
        return true;
      }
    }
    return false;
  };
  Selection.prototype.contains = function(pos, end) {
    if (!end) {
      end = pos;
    }
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      var range2 = this.ranges[i2];
      if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
        return i2;
      }
    }
    return -1;
  };
  var Range = function(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  Range.prototype.from = function() {
    return minPos(this.anchor, this.head);
  };
  Range.prototype.to = function() {
    return maxPos(this.anchor, this.head);
  };
  Range.prototype.empty = function() {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  };
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i2 = 1; i2 < ranges.length; i2++) {
      var cur = ranges[i2], prev = ranges[i2 - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i2 <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }
  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(
      change.from.line + change.text.length - 1,
      lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)
    );
  }
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }
  function computeSelAfterChange(doc2, change) {
    var out = [];
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      var range2 = doc2.sel.ranges[i2];
      out.push(new Range(
        adjustForChange(range2.anchor, change),
        adjustForChange(range2.head, change)
      ));
    }
    return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
  }
  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }
  function computeReplacedSel(doc2, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
    for (var i2 = 0; i2 < changes.length; i2++) {
      var change = changes[i2];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
        out[i2] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i2] = new Range(from, from);
      }
    }
    return new Selection(out, doc2.sel.primIndex);
  }
  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }
  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }
  function isWholeLineUpdate(doc2, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
  }
  function updateDoc(doc2, change, markedSpans, estimateHeight2) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text2, spans) {
      updateLine(line, text2, spans, estimateHeight2);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i2 = start; i2 < end; ++i2) {
        result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
      }
      return result;
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (change.full) {
      doc2.insert(0, linesFor(0, text.length));
      doc2.remove(text.length, doc2.size - text.length);
    } else if (isWholeLineUpdate(doc2, change)) {
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc2.remove(from.line, nlines);
      }
      if (added.length) {
        doc2.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added\$1 = linesFor(1, text.length - 1);
        added\$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc2.insert(from.line + 1, added\$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc2.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added\$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc2.remove(from.line + 1, nlines - 1);
      }
      doc2.insert(from.line + 1, added\$2);
    }
    signalLater(doc2, "change", doc2, change);
  }
  function linkedDocs(doc2, f, sharedHistOnly) {
    function propagate(doc3, skip, sharedHist) {
      if (doc3.linked) {
        for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
          var rel = doc3.linked[i2];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc3, shared);
        }
      }
    }
    propagate(doc2, null, true);
  }
  function attachDoc(cm, doc2) {
    if (doc2.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc2;
    doc2.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc2.direction;
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc2.modeOption;
    regChange(cm);
  }
  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }
  function directionChanged(cm) {
    runInOp(cm, function() {
      setDirectionClass(cm);
      regChange(cm);
    });
  }
  function History(prev) {
    this.done = [];
    this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }
  function historyChangeFromChange(doc2, change) {
    var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
    attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc2, function(doc3) {
      return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }
  function addChangeToHistory(doc2, change, selAfter, opId) {
    var hist = doc2.history;
    hist.undone.length = 0;
    var time = +/* @__PURE__ */ new Date(), cur;
    var last;
    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc2, change));
      }
    } else {
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc2.sel, hist.done);
      }
      cur = {
        changes: [historyChangeFromChange(doc2, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;
    if (!last) {
      signal(doc2, "historyAdded");
    }
  }
  function selectionEventCanBeMerged(doc2, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
  }
  function addSelectionToHistory(doc2, sel, opId, options) {
    var hist = doc2.history, origin = options && options.origin;
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }
    hist.lastSelTime = +/* @__PURE__ */ new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }
  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }
  function attachLocalSpans(doc2, change, from, to) {
    var existing = change["spans_" + doc2.id], n = 0;
    doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i2 = 0; i2 < spans.length; ++i2) {
      if (spans[i2].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i2);
        }
      } else if (out) {
        out.push(spans[i2]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc2, change) {
    var found = change["spans_" + doc2.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i2 = 0; i2 < change.text.length; ++i2) {
      nw.push(removeClearedSpans(found[i2]));
    }
    return nw;
  }
  function mergeOldSpans(doc2, change) {
    var old = getOldSpans(doc2, change);
    var stretched = stretchSpansOverChange(doc2, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }
    for (var i2 = 0; i2 < old.length; ++i2) {
      var oldCur = old[i2], stretchCur = stretched[i2];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i2] = stretchCur;
      }
    }
    return old;
  }
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i2 = 0; i2 < events.length; ++i2) {
      var event = events[i2];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = void 0;
        newChanges.push({ from: change.from, to: change.to, text: change.text });
        if (newGroup) {
          for (var prop2 in change) {
            if (m = prop2.match(/^spans_(\\d+)\$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop2] = change[prop2];
                delete change[prop2];
              }
            }
          }
        }
      }
    }
    return copy;
  }
  function extendRange(range2, head, other, extend) {
    if (extend) {
      var anchor = range2.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }
  function extendSelection(doc2, head, other, options, extend) {
    if (extend == null) {
      extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
    }
    setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend)], 0), options);
  }
  function extendSelections(doc2, heads, options) {
    var out = [];
    var extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend);
    }
    var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
    setSelection(doc2, newSel, options);
  }
  function replaceOneSelection(doc2, i2, range2, options) {
    var ranges = doc2.sel.ranges.slice(0);
    ranges[i2] = range2;
    setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
  }
  function setSimpleSelection(doc2, anchor, head, options) {
    setSelection(doc2, simpleSelection(anchor, head), options);
  }
  function filterSelectionChange(doc2, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          this.ranges[i2] = new Range(
            clipPos(doc2, ranges[i2].anchor),
            clipPos(doc2, ranges[i2].head)
          );
        }
      },
      origin: options && options.origin
    };
    signal(doc2, "beforeSelectionChange", doc2, obj);
    if (doc2.cm) {
      signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }
  function setSelectionReplaceHistory(doc2, sel, options) {
    var done = doc2.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc2, sel, options);
    } else {
      setSelection(doc2, sel, options);
    }
  }
  function setSelection(doc2, sel, options) {
    setSelectionNoUndo(doc2, sel, options);
    addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
  }
  function setSelectionNoUndo(doc2, sel, options) {
    if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc2, sel, options);
    }
    var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
    if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
      ensureCursorVisible(doc2.cm);
    }
  }
  function setSelectionInner(doc2, sel) {
    if (sel.equals(doc2.sel)) {
      return;
    }
    doc2.sel = sel;
    if (doc2.cm) {
      doc2.cm.curOp.updateInput = 1;
      doc2.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc2.cm);
    }
    signalLater(doc2, "cursorActivity", doc2);
  }
  function reCheckSelection(doc2) {
    setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
  }
  function skipAtomicInSelection(doc2, sel, bias, mayClear) {
    var out;
    for (var i2 = 0; i2 < sel.ranges.length; i2++) {
      var range2 = sel.ranges[i2];
      var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
      var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
      var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range2.anchor || newHead != range2.head) {
        if (!out) {
          out = sel.ranges.slice(0, i2);
        }
        out[i2] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
  }
  function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
    var line = getLine(doc2, pos.line);
    if (line.markedSpans) {
      for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
        var sp = line.markedSpans[i2], m = sp.marker;
        var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i2;
                continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }
          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
            if (dir < 0 ? preventCursorRight : preventCursorLeft) {
              near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc2, near, pos, dir, mayClear);
            }
          }
          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? preventCursorLeft : preventCursorRight) {
            far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }
  function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
    if (!found) {
      doc2.cantEdit = true;
      return Pos(doc2.first, 0);
    }
    return found;
  }
  function movePos(doc2, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc2.first) {
        return clipPos(doc2, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
      if (pos.line < doc2.first + doc2.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }
  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }
  function filterChange(doc2, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function(from, to, text, origin) {
        if (from) {
          obj.from = clipPos(doc2, from);
        }
        if (to) {
          obj.to = clipPos(doc2, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== void 0) {
          obj.origin = origin;
        }
      };
    }
    signal(doc2, "beforeChange", doc2, obj);
    if (doc2.cm) {
      signal(doc2.cm, "beforeChange", doc2.cm, obj);
    }
    if (obj.canceled) {
      if (doc2.cm) {
        doc2.cm.curOp.updateInput = 2;
      }
      return null;
    }
    return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
  }
  function makeChange(doc2, change, ignoreReadOnly) {
    if (doc2.cm) {
      if (!doc2.cm.curOp) {
        return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
      }
      if (doc2.cm.state.suppressEdits) {
        return;
      }
    }
    if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
      change = filterChange(doc2, change, true);
      if (!change) {
        return;
      }
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
    if (split) {
      for (var i2 = split.length - 1; i2 >= 0; --i2) {
        makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
      }
    } else {
      makeChangeInner(doc2, change);
    }
  }
  function makeChangeInner(doc2, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc2, change);
    addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
    var rebased = [];
    linkedDocs(doc2, function(doc3, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
        rebaseHist(doc3.history, change);
        rebased.push(doc3.history);
      }
      makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
    });
  }
  function makeChangeFromHistory(doc2, type2, allowSelectionOnly) {
    var suppress = doc2.cm && doc2.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) {
      return;
    }
    var hist = doc2.history, event, selAfter = doc2.sel;
    var source = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
    var i2 = 0;
    for (; i2 < source.length; i2++) {
      event = source[i2];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
        break;
      }
    }
    if (i2 == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;
    for (; ; ) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc2.sel)) {
          setSelection(doc2, event, { clearRedo: false });
          return;
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return;
      } else {
        break;
      }
    }
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({ changes: antiChanges, generation: hist.generation });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
    var loop = function(i3) {
      var change = event.changes[i3];
      change.origin = type2;
      if (filter && !filterChange(doc2, change, false)) {
        source.length = 0;
        return {};
      }
      antiChanges.push(historyChangeFromChange(doc2, change));
      var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);
      makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
      if (!i3 && doc2.cm) {
        doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
      }
      var rebased = [];
      linkedDocs(doc2, function(doc3, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
          rebaseHist(doc3.history, change);
          rebased.push(doc3.history);
        }
        makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
      });
    };
    for (var i\$12 = event.changes.length - 1; i\$12 >= 0; --i\$12) {
      var returned = loop(i\$12);
      if (returned) return returned.v;
    }
  }
  function shiftDoc(doc2, distance) {
    if (distance == 0) {
      return;
    }
    doc2.first += distance;
    doc2.sel = new Selection(map(doc2.sel.ranges, function(range2) {
      return new Range(
        Pos(range2.anchor.line + distance, range2.anchor.ch),
        Pos(range2.head.line + distance, range2.head.ch)
      );
    }), doc2.sel.primIndex);
    if (doc2.cm) {
      regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
      for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc2.cm, l, "gutter");
      }
    }
  }
  function makeChangeSingleDoc(doc2, change, selAfter, spans) {
    if (doc2.cm && !doc2.cm.curOp) {
      return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
    }
    if (change.to.line < doc2.first) {
      shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc2.lastLine()) {
      return;
    }
    if (change.from.line < doc2.first) {
      var shift = change.text.length - 1 - (doc2.first - change.from.line);
      shiftDoc(doc2, shift);
      change = {
        from: Pos(doc2.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc2.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc2, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc2, change.from, change.to);
    if (!selAfter) {
      selAfter = computeSelAfterChange(doc2, change);
    }
    if (doc2.cm) {
      makeChangeSingleDocInEditor(doc2.cm, change, spans);
    } else {
      updateDoc(doc2, change, spans);
    }
    setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
    if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
      doc2.cantEdit = false;
    }
  }
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));
      doc2.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (doc2.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }
    updateDoc(doc2, change, spans, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }
    retreatFrontier(doc2, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }
    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from,
        to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }
  function replaceRange(doc2, code, from, to, origin) {
    var assign;
    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      assign = [to, from], from = assign[0], to = assign[1];
    }
    if (typeof code == "string") {
      code = doc2.splitLines(code);
    }
    makeChange(doc2, { from, to, text: code, origin });
  }
  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      var sub = array[i2], ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i2] = sub.deepCopy();
          sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j\$1 = 0; j\$1 < sub.changes.length; ++j\$1) {
        var cur = sub.changes[j\$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i2 + 1);
        i2 = 0;
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function changeLine(doc2, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") {
      line = getLine(doc2, clipLine(doc2, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc2.cm) {
      regLineChange(doc2.cm, no, changeType);
    }
    return line;
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i2 = 0; i2 < lines.length; ++i2) {
      lines[i2].parent = this;
      height += lines[i2].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i2 = at, e = at + n; i2 < e; ++i2) {
        var line = this.lines[i2];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i2 = 0; i2 < lines.length; ++i2) {
        lines[i2].parent = this;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at) {
        if (op(this.lines[at])) {
          return true;
        }
      }
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i2 = 0; i2 < children.length; ++i2) {
      var ch = children[i2];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function() {
      return this.size;
    },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i2--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        this.children[i2].collapse(lines);
      }
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length; ) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i2, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  };
  var LineWidget = function(doc2, node, options) {
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this[opt] = options[opt];
        }
      }
    }
    this.doc = doc2;
    this.node = node;
  };
  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i2 = 0; i2 < ws.length; ++i2) {
      if (ws[i2] == this) {
        ws.splice(i2--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function() {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };
  LineWidget.prototype.changed = function() {
    var this\$1\$1 = this;
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    if (!lineIsHidden(this.doc, line)) {
      updateLineHeight(line, line.height + diff);
    }
    if (cm) {
      runInOp(cm, function() {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this\$1\$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);
  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }
  function addLineWidget(doc2, handle, node, options) {
    var widget = new LineWidget(doc2, node, options);
    var cm = doc2.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc2, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc2, line)) {
        var aboveVisible = heightAtLine(line) < doc2.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    if (cm) {
      signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    }
    return widget;
  }
  var nextMarkerId = 0;
  var TextMarker = function(doc2, type2) {
    this.lines = [];
    this.type = type2;
    this.doc = doc2;
    this.id = ++nextMarkerId;
  };
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null, max = null;
    for (var i2 = 0; i2 < this.lines.length; ++i2) {
      var line = this.lines[i2];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i\$12 = 0; i\$12 < this.lines.length; ++i\$12) {
        var visual = visualLine(this.lines[i\$12]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i2 = 0; i2 < this.lines.length; ++i2) {
      var line = this.lines[i2];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && { from, to };
  };
  TextMarker.prototype.changed = function() {
    var this\$1\$1 = this;
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
      signalLater(cm, "markerChanged", cm, this\$1\$1);
    });
  };
  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);
  function markText(doc2, from, to, options, type2) {
    if (options && options.shared) {
      return markTextShared(doc2, from, to, options, type2);
    }
    if (doc2.cm && !doc2.cm.curOp) {
      return operation(doc2.cm, markText)(doc2, from, to, options, type2);
    }
    var marker = new TextMarker(doc2, type2), diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }
    if (marker.addToHistory) {
      addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
    }
    var curLine = from.line, cm = doc2.cm, updateMaxLine;
    doc2.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(
        marker,
        curLine == from.line ? from.ch : null,
        curLine == to.line ? to.ch : null
      ), doc2.cm && doc2.cm.curOp);
      ++curLine;
    });
    if (marker.collapsed) {
      doc2.iter(from.line, to.line + 1, function(line) {
        if (lineIsHidden(doc2, line)) {
          updateLineHeight(line, 0);
        }
      });
    }
    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function() {
        return marker.clear();
      });
    }
    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc2.history.done.length || doc2.history.undone.length) {
        doc2.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
        for (var i2 = from.line; i2 <= to.line; i2++) {
          regLineChange(cm, i2, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i2 = 0; i2 < markers.length; ++i2) {
      markers[i2].parent = this;
    }
  };
  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i2 = 0; i2 < this.markers.length; ++i2) {
      this.markers[i2].clear();
    }
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  eventMixin(SharedTextMarker);
  function markTextShared(doc2, from, to, options, type2) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc2, from, to, options, type2)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc2, function(doc3) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options, type2));
      for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
        if (doc3.linked[i2].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function findSharedMarkers(doc2) {
    return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m) {
      return m.parent;
    });
  }
  function copySharedMarkers(doc2, markers) {
    for (var i2 = 0; i2 < markers.length; i2++) {
      var marker = markers[i2], pos = marker.find();
      var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }
  function detachSharedMarkers(markers) {
    var loop = function(i3) {
      var marker = markers[i3], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function(d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };
    for (var i2 = 0; i2 < markers.length; i2++) loop(i2);
  }
  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }
    if (firstLine == null) {
      firstLine = 0;
    }
    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;
    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, { from: start, to: start, text });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i2 = 0; i2 < lines.length; ++i2) {
        height += lines[i2].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.
    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);
      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      if (lineSep === "") {
        return lines.join("");
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function(line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function(line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function(line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },
    lineCount: function() {
      return this.size;
    },
    firstLine: function() {
      return this.first;
    },
    lastLine: function() {
      return this.first + this.size - 1;
    },
    clipPos: function(pos) {
      return clipPos(this, pos);
    },
    getCursor: function(start) {
      var range2 = this.sel.primary(), pos;
      if (start == null || start == "head") {
        pos = range2.head;
      } else if (start == "anchor") {
        pos = range2.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range2.to();
      } else {
        pos = range2.from();
      }
      return pos;
    },
    listSelections: function() {
      return this.sel.ranges;
    },
    somethingSelected: function() {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        out[i2] = new Range(
          clipPos(this, ranges[i2].anchor),
          clipPos(this, ranges[i2].head || ranges[i2].anchor)
        );
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),
    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this.lineSeparator());
        }
        parts[i2] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
        dup[i2] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
        var range2 = sel.ranges[i2];
        changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i\$12 = changes.length - 1; i\$12 >= 0; i\$12--) {
        makeChange(this, changes[i\$12]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function() {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function() {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function() {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function() {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function(val) {
      this.extend = val;
    },
    getExtending: function() {
      return this.extend;
    },
    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i2 = 0; i2 < hist.done.length; i2++) {
        if (!hist.done[i2].ranges) {
          ++done;
        }
      }
      for (var i\$12 = 0; i\$12 < hist.undone.length; i\$12++) {
        if (!hist.undone[i\$12].ranges) {
          ++undone;
        }
      }
      return { undo: done, redo: undone };
    },
    clearHistory: function() {
      var this\$1\$1 = this;
      this.history = new History(this.history);
      linkedDocs(this, function(doc2) {
        return doc2.history = this\$1\$1.history;
      }, true);
    },
    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function(gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function() {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function(line2) {
        var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line2.gutterMarkers = null;
        }
        return true;
      });
    }),
    clearGutter: docMethodOp(function(gutterID) {
      var this\$1\$1 = this;
      this.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this\$1\$1, line, "gutter", function() {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
      });
    }),
    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop2]) {
          line[prop2] = cls;
        } else if (classTest(cls).test(line[prop2])) {
          return false;
        } else {
          line[prop2] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop2];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop2] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) {
      widget.clear();
    },
    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from);
      to = clipPos(this, to);
      var found = [], lineNo2 = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i2 = 0; i2 < spans.length; i2++) {
            var span = spans[i2];
            if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo2;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            if (sps[i2].from != null) {
              markers.push(sps[i2].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function(off2) {
      var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function(line) {
        var sz = line.text.length + sepSize;
        if (sz > off2) {
          ch = off2;
          return true;
        }
        off2 -= sz;
        ++lineNo2;
      });
      return clipPos(this, Pos(lineNo2, ch));
    },
    indexFromPos: function(coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function(line) {
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function(copyHistory) {
      var doc2 = new Doc(
        getLines(this, this.first, this.first + this.size),
        this.modeOption,
        this.first,
        this.lineSep,
        this.direction
      );
      doc2.scrollTop = this.scrollTop;
      doc2.scrollLeft = this.scrollLeft;
      doc2.sel = this.sel;
      doc2.extend = false;
      if (copyHistory) {
        doc2.history.undoDepth = this.history.undoDepth;
        doc2.setHistory(this.getHistory());
      }
      return doc2;
    },
    linkedDoc: function(options) {
      if (!options) {
        options = {};
      }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history;
      }
      (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
      copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror2) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i2 = 0; i2 < this.linked.length; ++i2) {
          var link = this.linked[i2];
          if (link.doc != other) {
            continue;
          }
          this.linked.splice(i2, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break;
        }
      }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc2) {
          return splitIds.push(doc2.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {
      linkedDocs(this, f);
    },
    getMode: function() {
      return this.mode;
    },
    getEditor: function() {
      return this.cm;
    },
    splitLines: function(str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function() {
      return this.lineSep || "\\n";
    },
    setDirection: docMethodOp(function(dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }
      if (dir == this.direction) {
        return;
      }
      this.direction = dir;
      this.iter(function(line) {
        return line.order = null;
      });
      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +/* @__PURE__ */ new Date();
    }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function() {
        if (++read == n) {
          operation(cm, function() {
            pos = clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(
                text.filter(function(t) {
                  return t != null;
                }).join(cm.doc.lineSeparator())
              ),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function(file, i3) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return;
        }
        var reader = new FileReader();
        reader.onerror = function() {
          return markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.onload = function() {
          var content = reader.result;
          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          text[i3] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i2 = 0; i2 < files.length; i2++) {
        readTextFromFile(files[i2], i2);
      }
    } else {
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        setTimeout(function() {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text\$1 = e.dataTransfer.getData("Text");
        if (text\$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i\$12 = 0; i\$12 < selected.length; ++i\$12) {
              replaceRange(cm.doc, "", selected[i\$12].anchor, selected[i\$12].head, "drag");
            }
          }
          cm.replaceSelection(text\$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e\$1) {
      }
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }
  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }
  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }
  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i2 = 0; i2 < byClass.length; i2++) {
      var cm = byClass[i2].CodeMirror;
      if (cm) {
        editors.push(cm);
      }
    }
    if (editors.length) {
      editors[0].operation(function() {
        for (var i3 = 0; i3 < editors.length; i3++) {
          f(editors[i3]);
        }
      });
    }
  }
  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function() {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    on(window, "blur", function() {
      return forEachCodeMirror(onBlur);
    });
  }
  function onResize(cm) {
    var d = cm.display;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }
  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "\`",
    219: "[",
    220: "\\\\",
    221: "]",
    222: "'",
    224: "Mod",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  };
  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  for (var i\$1 = 65; i\$1 <= 90; i\$1++) {
    keyNames[i\$1] = String.fromCharCode(i\$1);
  }
  for (var i\$2 = 1; i\$2 <= 12; i\$2++) {
    keyNames[i\$2 + 111] = keyNames[i\$2 + 63235] = "F" + i\$2;
  }
  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  function normalizeKeyName(name) {
    var parts = name.split(/-(?!\$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i2 = 0; i2 < parts.length - 1; i2++) {
      var mod = parts[i2];
      if (/^(cmd|meta|m)\$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?\$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)\$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?\$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)\$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];
          continue;
        }
        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i2 = 0; i2 < keys.length; i2++) {
          var val = void 0, name = void 0;
          if (i2 == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i2 + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop2 in copy) {
      keymap[prop2] = copy[prop2];
    }
    return keymap;
  }
  function lookupKey(key, map2, handle, context) {
    map2 = getKeyMap(map2);
    var found = map2.call ? map2.call(key, context) : map2[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }
    if (map2.fallthrough) {
      if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
        return lookupKey(key, map2.fallthrough, handle, context);
      }
      for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {
        var result = lookupKey(key, map2.fallthrough[i2], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) {
      return false;
    }
    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }
    return addModifierNames(name, event, noShift);
  }
  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    for (var i2 = 0; i2 < ranges.length; i2++) {
      var toKill = compute(ranges[i2]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    runInOp(cm, function() {
      for (var i3 = kill.length - 1; i3 >= 0; i3--) {
        replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }
  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }
  function endOfLine(visually, cm, lineObj, lineNo2, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") {
        dir = -dir;
      }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function(ch2) {
            return measureCharPrepared(cm, prep, ch2).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }
        return new Pos(lineNo2, ch, sticky);
      }
    }
    return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }
  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) {
      return moveLogically(line, start, dir);
    }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      return moveLogically(line, start, dir);
    }
    var mv = function(pos, dir2) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
    };
    var prep;
    var getWrappedLineExtent = function(ch2) {
      if (!cm.options.lineWrapping) {
        return { begin: 0, end: line.text.length };
      }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch2);
    };
    var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    }
    var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
      var getRes = function(ch3, moveInStorageOrder3) {
        return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
      };
      for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
        var part2 = bidi[partPos2];
        var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
        var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
        if (part2.from <= ch2 && ch2 < part2.to) {
          return getRes(ch2, moveInStorageOrder2);
        }
        ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
        if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
          return getRes(ch2, moveInStorageOrder2);
        }
      }
    };
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
    if (res) {
      return res;
    }
    var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) {
        return res;
      }
    }
    return null;
  }
  var commands = {
    selectAll,
    singleSelection: function(cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        if (range2.empty()) {
          var len = getLine(cm.doc, range2.head.line).text.length;
          if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
            return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
          } else {
            return { from: range2.head, to: Pos(range2.head.line, len) };
          }
        } else {
          return { from: range2.from(), to: range2.to() };
        }
      });
    },
    deleteLine: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        return {
          from: Pos(range2.from().line, 0),
          to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        return {
          from: Pos(range2.from().line, 0),
          to: range2.from()
        };
      });
    },
    delWrappedLineLeft: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        var top = cm.charCoords(range2.head, "div").top + 5;
        var leftPos = cm.coordsChar({ left: 0, top }, "div");
        return { from: leftPos, to: range2.from() };
      });
    },
    delWrappedLineRight: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        var top = cm.charCoords(range2.head, "div").top + 5;
        var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
        return { from: range2.from(), to: rightPos };
      });
    },
    undo: function(cm) {
      return cm.undo();
    },
    redo: function(cm) {
      return cm.redo();
    },
    undoSelection: function(cm) {
      return cm.undoSelection();
    },
    redoSelection: function(cm) {
      return cm.redoSelection();
    },
    goDocStart: function(cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function(cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineStart(cm, range2.head.line);
        },
        { origin: "+move", bias: 1 }
      );
    },
    goLineStartSmart: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineStartSmart(cm, range2.head);
        },
        { origin: "+move", bias: 1 }
      );
    },
    goLineEnd: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineEnd(cm, range2.head.line);
        },
        { origin: "+move", bias: -1 }
      );
    },
    goLineRight: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        return cm.coordsChar({ left: 0, top }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        var pos = cm.coordsChar({ left: 0, top }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {
          return lineStartSmart(cm, range2.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function(cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function(cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function(cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function(cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function(cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function(cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function(cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function(cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function(cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function(cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function(cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function(cm) {
      return cm.deleteH(-1, "codepoint");
    },
    delCharAfter: function(cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function(cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function(cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function(cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function(cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function(cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function(cm) {
      return cm.indentSelection("add");
    },
    indentLess: function(cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function(cm) {
      return cm.replaceSelection("	");
    },
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var pos = ranges[i2].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function(cm) {
      return runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          if (!ranges[i2].empty()) {
            continue;
          }
          var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(
                line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                Pos(cur.line, cur.ch - 2),
                cur,
                "+transpose"
              );
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(
                  line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),
                  Pos(cur.line - 1, prev.length - 1),
                  cur,
                  "+transpose"
                );
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      return runInOp(cm, function() {
        var sels = cm.listSelections();
        for (var i2 = sels.length - 1; i2 >= 0; i2--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
        }
        sels = cm.listSelections();
        for (var i\$12 = 0; i\$12 < sels.length; i\$12++) {
          cm.indentLine(sels[i\$12].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function(cm) {
      return cm.replaceSelection("\\n", "start");
    },
    toggleOverwrite: function(cm) {
      return cm.toggleOverwrite();
    }
  };
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, visual, lineN, 1);
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, line, lineN, -1);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }
    return start;
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function lookupKeyForEditor(cm, name, handle) {
    for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
      var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }
  var stopSeq = new Delayed();
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      if (/\\'\$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function() {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }
    return dispatchKeyInner(cm, name, e, handle);
  }
  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);
    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }
    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return !!result;
  }
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }
    if (e.shiftKey && !cm.state.keySeq) {
      return dispatchKey(cm, "Shift-" + name, e, function(b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function(b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function(b) {
        return doHandleBinding(cm, b);
      });
    }
  }
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function(b) {
      return doHandleBinding(cm, b, true);
    });
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) {
      return;
    }
    cm.curOp.focus = activeElt(doc(cm));
    if (signalDOMEvent(cm, e)) {
      return;
    }
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
      document.execCommand("cut");
    }
    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }
  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");
    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }
  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }
  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) {
      return;
    }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (ch == "\\b") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }
  var DOUBLECLICK_DELAY = 400;
  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };
  PastClick.prototype.compare = function(time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };
  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +/* @__PURE__ */ new Date();
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  }
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function() {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat2 = pos ? clickRepeat(pos, button) : "single";
    win(cm).focus();
    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }
    if (pos && handleMappedButton(cm, button, pos, repeat2, e)) {
      return;
    }
    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat2, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }
      setTimeout(function() {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        cm.display.input.onContextMenu(e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }
  function handleMappedButton(cm, button, pos, repeat2, event) {
    var name = "Click";
    if (repeat2 == "double") {
      name = "Double" + name;
    } else if (repeat2 == "triple") {
      name = "Triple" + name;
    }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }
      if (!bound) {
        return false;
      }
      var done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done;
    });
  }
  function configureMouse(cm, repeat2, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat2, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat2 == "single" ? "char" : repeat2 == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }
    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }
    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }
    return value;
  }
  function leftButtonDown(cm, pos, repeat2, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt(doc(cm));
    }
    var behavior = configureMouse(cm, repeat2, event);
    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat2 == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  }
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function(e) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) {
          cm.state.delayingBlurEvent = false;
        } else {
          delayBlurEvent(cm);
        }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        }
        if (webkit && !safari || ie && ie_version == 9) {
          setTimeout(function() {
            display.wrapper.ownerDocument.body.focus({ preventScroll: true });
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function() {
      return moved = true;
    };
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      return display.input.focus();
    }, 20);
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
  }
  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }
    if (unit == "word") {
      return cm.findWordAt(pos);
    }
    if (unit == "line") {
      return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }
    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  }
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) {
      delayBlurEvent(cm);
    }
    var display = cm.display, doc\$1 = cm.doc;
    e_preventDefault(event);
    var ourRange, ourIndex, startSel = doc\$1.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc\$1.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc\$1.sel.primary();
      ourIndex = doc\$1.sel.primIndex;
    }
    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range2 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) {
        ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
      } else {
        ourRange = range2;
      }
    }
    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc\$1, new Selection([ourRange], 0), sel_mouse);
      startSel = doc\$1.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(
        doc\$1,
        normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
        { scroll: false, origin: "*mouse" }
      );
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(
        doc\$1,
        normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
        { scroll: false, origin: "*mouse" }
      );
      startSel = doc\$1.sel;
    } else {
      replaceOneSelection(doc\$1, ourIndex, ourRange, sel_mouse);
    }
    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;
      if (behavior.unit == "rectangle") {
        var ranges2 = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc\$1, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc\$1, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc\$1, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges2.length) {
          ranges2.push(new Range(start, start));
        }
        setSelection(
          doc\$1,
          normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),
          { origin: "*mouse", scroll: false }
        );
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range3 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range3.anchor, anchor) > 0) {
          head = range3.head;
          anchor = minPos(oldRange.from(), range3.anchor);
        } else {
          head = range3.anchor;
          anchor = maxPos(oldRange.to(), range3.head);
        }
        var ranges\$1 = startSel.ranges.slice(0);
        ranges\$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc\$1, anchor), head));
        setSelection(doc\$1, normalizeSelection(cm, ranges\$1, ourIndex), sel_mouse);
      }
    }
    var editorSize = display.wrapper.getBoundingClientRect();
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt(doc(cm));
        extendTo(cur);
        var visible = visibleLines(display, doc\$1);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function() {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function() {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }
    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc\$1.history.lastSelOrigin = null;
    }
    var move = operation(cm, function(e) {
      if (e.buttons === 0 || !e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }
  function bidiSimplify(cm, range2) {
    var anchor = range2.anchor;
    var head = range2.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range2;
    }
    var order = getOrder(anchorLine);
    if (!order) {
      return range2;
    }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range2;
    }
    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) {
      return range2;
    }
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }
    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
  }
  function gutterEvent(cm, e, type2, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e\$1) {
        return false;
      }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }
    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();
    if (mY > lineBox.bottom || !hasHandler(cm, type2)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;
    for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
      var g = display.gutters.childNodes[i2];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i2];
        signal(cm, type2, cm, line, gutter.className, e);
        return e_defaultPrevented(e);
      }
    }
  }
  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    if (!captureRightClick) {
      cm.display.input.onContextMenu(e);
    }
  }
  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") + cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");
    clearCaches(cm);
  }
  var Init = { toString: function() {
    return "CodeMirror.Init";
  } };
  var defaults = {};
  var optionHandlers = {};
  function defineOptions(CodeMirror3) {
    var optionHandlers2 = CodeMirror3.optionHandlers;
    function option(name, deflt, handle, notOnInit) {
      CodeMirror3.defaults[name] = deflt;
      if (handle) {
        optionHandlers2[name] = notOnInit ? function(cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }
    CodeMirror3.defineOption = option;
    CodeMirror3.Init = Init;
    option("value", "", function(cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function(cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function(cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function(cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [], lineNo2 = cm.doc.first;
      cm.doc.iter(function(line) {
        for (var pos = 0; ; ) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo2, found));
        }
        lineNo2++;
      });
      for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
        replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
      }
    });
    option("specialChars", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
      throw new Error("inputStyle can not (yet) be changed in a running editor");
    }, true);
    option("spellcheck", false, function(cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("autocorrect", false, function(cm, val) {
      return cm.getInputField().autocorrect = val;
    }, true);
    option("autocapitalize", false, function(cm, val) {
      return cm.getInputField().autocapitalize = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function(cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function(cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function(cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function(cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function(cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function(cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function(cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function(integer) {
      return integer;
    }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);
    option("readOnly", false, function(cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("screenReaderLabel", null, function(cm, val) {
      val = val === "" ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });
    option("disableInput", false, function(cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function(cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function(cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 1e4, resetModeState, true);
    option("moveInputWithCursor", true, function(cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function(cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function(cm, val) {
      return cm.doc.setDirection(val);
    }, true);
    option("phrases", null);
  }
  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function() {
      return updateScrollbars(cm);
    }, 100);
  }
  function CodeMirror2(place, options) {
    var this\$1\$1 = this;
    if (!(this instanceof CodeMirror2)) {
      return new CodeMirror2(place, options);
    }
    this.options = options = options ? copyObj(options) : {};
    copyObj(defaults, options, false);
    var doc2 = options.value;
    if (typeof doc2 == "string") {
      doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
    } else if (options.mode) {
      doc2.modeOption = options.mode;
    }
    this.doc = doc2;
    var input = new CodeMirror2.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc2, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1,
      cutIncoming: -1,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };
    if (options.autofocus && !mobile) {
      display.input.focus();
    }
    if (ie && ie_version < 11) {
      setTimeout(function() {
        return this\$1\$1.display.input.reset(true);
      }, 20);
    }
    registerEventHandlers(this);
    ensureGlobalHandlers();
    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc2);
    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(function() {
        if (this\$1\$1.hasFocus() && !this\$1\$1.state.focused) {
          onFocus(this\$1\$1);
        }
      }, 20);
    } else {
      onBlur(this);
    }
    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i2 = 0; i2 < initHooks.length; ++i2) {
      initHooks[i2](this);
    }
    endOperation(this);
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }
  CodeMirror2.defaults = defaults;
  CodeMirror2.optionHandlers = optionHandlers;
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function(e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    on(d.scroller, "contextmenu", function(e) {
      return onContextMenu(cm, e);
    });
    on(d.input.getField(), "contextmenu", function(e) {
      if (!d.scroller.contains(e.target)) {
        onContextMenu(cm, e);
      }
    });
    var touchFinished, prevTouch = { end: 0 };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {
          return d.activeTouch = null;
        }, 1e3);
        prevTouch = d.activeTouch;
        prevTouch.end = +/* @__PURE__ */ new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +/* @__PURE__ */ new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range2;
        if (!touch.prev || farAway(touch, touch.prev)) {
          range2 = new Range(pos, pos);
        } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
          range2 = cm.findWordAt(pos);
        } else {
          range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        cm.setSelection(range2.anchor, range2.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scroller, "mousewheel", function(e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function(e) {
      return onScrollWheel(cm, e);
    });
    on(d.wrapper, "scroll", function() {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function(e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function(e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function(e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function(e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function(e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function(e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function(e) {
      return onBlur(cm, e);
    });
  }
  var initHooks = [];
  CodeMirror2.defineInitHook = function(f) {
    return initHooks.push(f);
  };
  function indentLine(cm, n, how, aggressive) {
    var doc2 = cm.doc, state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      if (!doc2.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;
    if (!aggressive && !/\\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc2.first) {
        indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
        pos += tabSize;
        indentString += "	";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }
    if (indentString != curSpaceString) {
      replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      for (var i\$12 = 0; i\$12 < doc2.sel.ranges.length; i\$12++) {
        var range2 = doc2.sel.ranges[i\$12];
        if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
          var pos\$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc2, i\$12, new Range(pos\$1, pos\$1));
          break;
        }
      }
    }
  }
  var lastCopied = null;
  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }
  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc2 = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc2.sel;
    }
    var recent = +/* @__PURE__ */ new Date() - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
            multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function(l) {
          return [l];
        });
      }
    }
    var updateInput = cm.curOp.updateInput;
    for (var i\$12 = sel.ranges.length - 1; i\$12 >= 0; i\$12--) {
      var range2 = sel.ranges[i\$12];
      var from = range2.from(), to = range2.to();
      if (range2.empty()) {
        if (deleted && deleted > 0) {
          from = Pos(from.line, from.ch - deleted);
        } else if (cm.state.overwrite && !paste) {
          to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
        } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\\n") == textLines.join("\\n")) {
          from = to = Pos(from.line, 0);
        }
      }
      var changeEvent = {
        from,
        to,
        text: multiPaste ? multiPaste[i\$12 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }
    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) {
      cm.curOp.updateInput = updateInput;
    }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }
  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
        runInOp(cm, function() {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }
  function triggerElectric(cm, inserted) {
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;
    for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
      var range2 = sel.ranges[i2];
      if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range2.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range2.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
          indented = indentLine(cm, range2.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range2.head.line);
      }
    }
  }
  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
      var line = cm.doc.sel.ranges[i2].head.line;
      var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return { text, ranges };
  }
  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "on" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }
  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    if (ios) {
      te.style.border = "1px solid black";
    }
    return div;
  }
  function addEditorMethods(CodeMirror3) {
    var optionHandlers2 = CodeMirror3.optionHandlers;
    var helpers = CodeMirror3.helpers = {};
    CodeMirror3.prototype = {
      constructor: CodeMirror3,
      focus: function() {
        win(this).focus();
        this.display.input.focus();
      },
      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers2.hasOwnProperty(option)) {
          operation(this, optionHandlers2[option])(this, value, old);
        }
        signal(this, "optionChange", this, option);
      },
      getOption: function(option) {
        return this.options[option];
      },
      getDoc: function() {
        return this.doc;
      },
      addKeyMap: function(map2, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map2));
      },
      removeKeyMap: function(map2) {
        var maps = this.state.keyMaps;
        for (var i2 = 0; i2 < maps.length; ++i2) {
          if (maps[i2] == map2 || maps[i2].name == map2) {
            maps.splice(i2, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(
          this.state.overlays,
          {
            mode,
            modeSpec: spec,
            opaque: options && options.opaque,
            priority: options && options.priority || 0
          },
          function(overlay) {
            return overlay.priority;
          }
        );
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i2 = 0; i2 < overlays.length; ++i2) {
          var cur = overlays[i2].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i2, 1);
            this.state.modeGen++;
            regChange(this);
            return;
          }
        }
      }),
      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var range2 = ranges[i2];
          if (!range2.empty()) {
            var from = range2.from(), to = range2.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this, j, how);
            }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
              replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
            }
          } else if (range2.head.line > end) {
            indentLine(this, range2.head.line, how, true);
            end = range2.head.line;
            if (i2 == this.doc.sel.primIndex) {
              ensureCursorVisible(this);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type2;
        if (ch == 0) {
          type2 = styles[2];
        } else {
          for (; ; ) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type2 = styles[mid * 2 + 2];
              break;
            }
          }
        }
        var cut = type2 ? type2.indexOf("overlay ") : -1;
        return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
      },
      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function(pos, type2) {
        return this.getHelpers(pos, type2)[0];
      },
      getHelpers: function(pos, type2) {
        var found = [];
        if (!helpers.hasOwnProperty(type2)) {
          return found;
        }
        var help = helpers[type2], mode = this.getModeAt(pos);
        if (typeof mode[type2] == "string") {
          if (help[mode[type2]]) {
            found.push(help[mode[type2]]);
          }
        } else if (mode[type2]) {
          for (var i2 = 0; i2 < mode[type2].length; i2++) {
            var val = help[mode[type2][i2]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i\$12 = 0; i\$12 < help._global.length; i\$12++) {
          var cur = help._global[i\$12];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },
      getStateAfter: function(line, precise) {
        var doc2 = this.doc;
        line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function(start, mode) {
        var pos, range2 = this.doc.sel.primary();
        if (start == null) {
          pos = range2.head;
        } else if (typeof start == "object") {
          pos = clipPos(this.doc, start);
        } else {
          pos = start ? range2.from() : range2.to();
        }
        return cursorCoords(this, pos, mode || "page");
      },
      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function() {
        return textHeight(this.display);
      },
      defaultCharWidth: function() {
        return charWidth(this.display);
      },
      getViewport: function() {
        return { from: this.display.viewFrom, to: this.display.viewTo };
      },
      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function(text) {
        triggerElectric(this, text);
      }),
      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i2 = 0; i2 < amount; ++i2) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveH: methodOp(function(dir, unit) {
        var this\$1\$1 = this;
        this.extendSelectionsBy(function(range2) {
          if (this\$1\$1.display.shift || this\$1\$1.doc.extend || range2.empty()) {
            return findPosH(this\$1\$1.doc, range2.head, dir, unit, this\$1\$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range2.from() : range2.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc2 = this.doc;
        if (sel.somethingSelected()) {
          doc2.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function(range2) {
            var other = findPosH(doc2, range2.head, dir, unit, false);
            return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
          });
        }
      }),
      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i2 = 0; i2 < amount; ++i2) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveV: methodOp(function(dir, unit) {
        var this\$1\$1 = this;
        var doc2 = this.doc, goals = [];
        var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
        doc2.extendSelectionsBy(function(range2) {
          if (collapse) {
            return dir < 0 ? range2.from() : range2.to();
          }
          var headPos = cursorCoords(this\$1\$1, range2.head, "div");
          if (range2.goalColumn != null) {
            headPos.left = range2.goalColumn;
          }
          goals.push(headPos.left);
          var pos = findPosV(this\$1\$1, headPos, dir, unit);
          if (unit == "page" && range2 == doc2.sel.primary()) {
            addToScrollTop(this\$1\$1, charCoords(this\$1\$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            doc2.sel.ranges[i2].goalColumn = goals[i2];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc2 = this.doc, line = getLine(doc2, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function(ch) {
            return isWordChar(ch, helper);
          } : /\\s/.test(startChar) ? function(ch) {
            return /\\s/.test(ch);
          } : function(ch) {
            return !/\\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }
        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() {
        return this.display.input.getField() == activeElt(doc(this));
      },
      isReadOnly: function() {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function(x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function(range2, margin) {
        if (range2 == null) {
          range2 = { from: this.doc.sel.primary().head, to: null };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range2 == "number") {
          range2 = { from: Pos(range2, 0), to: null };
        } else if (range2.from == null) {
          range2 = { from: range2, to: null };
        }
        if (!range2.to) {
          range2.to = range2.from;
        }
        range2.margin = margin || 0;
        if (range2.from.line != null) {
          scrollToRange(this, range2);
        } else {
          scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
        }
      }),
      setSize: methodOp(function(width, height) {
        var this\$1\$1 = this;
        var interpret = function(val) {
          return typeof val == "number" || /^\\d+\$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo2 = this.display.viewFrom;
        this.doc.iter(lineNo2, this.display.viewTo, function(line) {
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; i2++) {
              if (line.widgets[i2].noHScroll) {
                regLineChange(this\$1\$1, lineNo2, "widget");
                break;
              }
            }
          }
          ++lineNo2;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function(f) {
        return runInOp(this, f);
      },
      startOperation: function() {
        return startOperation(this);
      },
      endOperation: function() {
        return endOperation(this);
      },
      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function(doc2) {
        var old = this.doc;
        old.cm = null;
        if (this.state.selectingText) {
          this.state.selectingText();
        }
        attachDoc(this, doc2);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
      },
      getInputField: function() {
        return this.display.input.getField();
      },
      getWrapperElement: function() {
        return this.display.wrapper;
      },
      getScrollerElement: function() {
        return this.display.scroller;
      },
      getGutterElement: function() {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror3);
    CodeMirror3.registerHelper = function(type2, name, value) {
      if (!helpers.hasOwnProperty(type2)) {
        helpers[type2] = CodeMirror3[type2] = { _global: [] };
      }
      helpers[type2][name] = value;
    };
    CodeMirror3.registerGlobalHelper = function(type2, name, predicate, value) {
      CodeMirror3.registerHelper(type2, name, value);
      helpers[type2]._global.push({ pred: predicate, val: value });
    };
  }
  function findPosH(doc2, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc2, pos.line);
    var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc2.first || l >= doc2.first + doc2.size) {
        return false;
      }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc2, l);
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc2.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }
      return true;
    }
    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
      for (var first = true; ; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(pos.ch) || "\\n";
        var type2 = isWordChar(cur, helper) ? "w" : group && cur == "\\n" ? "n" : !group || /\\s/.test(cur) ? null : "p";
        if (group && !first && !type2) {
          type2 = "s";
        }
        if (sawType && sawType != type2) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }
          break;
        }
        if (type2) {
          sawType = type2;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc2, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc2 = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (; ; ) {
      target = coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc2.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };
  ContentEditableInput.prototype.init = function(display) {
    var this\$1\$1 = this;
    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) {
          return true;
        }
        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {
          break;
        }
      }
      return false;
    }
    on(div, "paste", function(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      if (ie_version <= 11) {
        setTimeout(operation(cm, function() {
          return this\$1\$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function(e) {
      this\$1\$1.composing = { data: e.data, done: false };
    });
    on(div, "compositionupdate", function(e) {
      if (!this\$1\$1.composing) {
        this\$1\$1.composing = { data: e.data, done: false };
      }
    });
    on(div, "compositionend", function(e) {
      if (this\$1\$1.composing) {
        if (e.data != this\$1\$1.composing.data) {
          this\$1\$1.readFromDOMSoon();
        }
        this\$1\$1.composing.done = true;
      }
    });
    on(div, "touchstart", function() {
      return input.forceCompositionEnd();
    });
    on(div, "input", function() {
      if (!this\$1\$1.composing) {
        this\$1\$1.readFromDOMSoon();
      }
    });
    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.operation(function() {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\\n");
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      disableBrowserMagic(te);
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\\n");
      var hadFocus = activeElt(div.ownerDocument);
      selectInput(te);
      setTimeout(function() {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };
  ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
    if (label) {
      this.div.setAttribute("aria-label", label);
    } else {
      this.div.removeAttribute("aria-label");
    }
  };
  ContentEditableInput.prototype.prepareSelection = function() {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt(this.div.ownerDocument) == this.div;
    return result;
  };
  ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }
    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }
    this.showMultipleSelections(info);
  };
  ContentEditableInput.prototype.getSelection = function() {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  };
  ContentEditableInput.prototype.showPrimarySelection = function() {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();
    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }
    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }
    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
    }
    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }
    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {
    }
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }
    this.rememberSelection();
  };
  ContentEditableInput.prototype.startGracePeriod = function() {
    var this\$1\$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function() {
      this\$1\$1.gracePeriod = false;
      if (this\$1\$1.selectionChanged()) {
        this\$1\$1.cm.operation(function() {
          return this\$1\$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };
  ContentEditableInput.prototype.showMultipleSelections = function(info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };
  ContentEditableInput.prototype.rememberSelection = function() {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };
  ContentEditableInput.prototype.selectionInEditor = function() {
    var sel = this.getSelection();
    if (!sel.rangeCount) {
      return false;
    }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains2(this.div, node);
  };
  ContentEditableInput.prototype.focus = function() {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt(this.div.ownerDocument) != this.div) {
        this.showSelection(this.prepareSelection(), true);
      }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function() {
    this.div.blur();
  };
  ContentEditableInput.prototype.getField = function() {
    return this.div;
  };
  ContentEditableInput.prototype.supportsTouch = function() {
    return true;
  };
  ContentEditableInput.prototype.receivedFocus = function() {
    var this\$1\$1 = this;
    var input = this;
    if (this.selectionInEditor()) {
      setTimeout(function() {
        return this\$1\$1.pollSelection();
      }, 20);
    } else {
      runInOp(this.cm, function() {
        return input.cm.curOp.selectionChanged = true;
      });
    }
    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };
  ContentEditableInput.prototype.selectionChanged = function() {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };
  ContentEditableInput.prototype.pollSelection = function() {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }
    var sel = this.getSelection(), cm = this.cm;
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing) {
      return;
    }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function() {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };
  ContentEditableInput.prototype.pollContent = function() {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }
    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }
    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }
    if (!fromNode) {
      return false;
    }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }
    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(
      newBot.length - (newText.length == 1 ? cutFront : 0),
      oldBot.length - (oldText.length == 1 ? cutFront : 0)
    );
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    }
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }
    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+\$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  };
  ContentEditableInput.prototype.ensurePolled = function() {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function() {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function() {
    if (!this.composing) {
      return;
    }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function() {
    var this\$1\$1 = this;
    if (this.readDOMTimeout != null) {
      return;
    }
    this.readDOMTimeout = setTimeout(function() {
      this\$1\$1.readDOMTimeout = null;
      if (this\$1\$1.composing) {
        if (this\$1\$1.composing.done) {
          this\$1\$1.composing = null;
        } else {
          return;
        }
      }
      this\$1\$1.updateFromDOM();
    }, 80);
  };
  ContentEditableInput.prototype.updateFromDOM = function() {
    var this\$1\$1 = this;
    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function() {
        return regChange(this\$1\$1.cm);
      });
    }
  };
  ContentEditableInput.prototype.setUneditable = function(node) {
    node.contentEditable = "false";
  };
  ContentEditableInput.prototype.onKeyPress = function(e) {
    if (e.charCode == 0 || this.composing) {
      return;
    }
    e.preventDefault();
    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };
  ContentEditableInput.prototype.readOnlyChanged = function(val) {
    this.div.contentEditable = String(val != "nocursor");
  };
  ContentEditableInput.prototype.onContextMenu = function() {
  };
  ContentEditableInput.prototype.resetPosition = function() {
  };
  ContentEditableInput.prototype.needsContentAttribute = true;
  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }
  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }
    return false;
  }
  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }
    return pos;
  }
  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id2) {
      return function(marker) {
        return marker.id == id2;
      };
    }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) {
          text += lineSep;
        }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range2;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range2 = found[0].find(0))) {
            addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        var isBlock = /^(pre|div|p|li|table|br)\$/i.test(node.nodeName);
        if (!/^br\$/i.test(node.nodeName) && node.textContent.length == 0) {
          return;
        }
        if (isBlock) {
          close();
        }
        for (var i2 = 0; i2 < node.childNodes.length; i2++) {
          walk(node.childNodes[i2]);
        }
        if (/^(pre|p)\$/i.test(node.nodeName)) {
          extraLinebreak = true;
        }
        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\\u200b/g, "").replace(/\\u00a0/g, " "));
      }
    }
    for (; ; ) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text;
  }
  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;
      offset = 0;
    } else {
      for (lineNode = node; ; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i2 = 0; i2 < cm.display.view.length; i2++) {
      var lineView = cm.display.view[i2];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }
  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains2(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }
    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure, maps = measure.maps;
    function find(textNode2, topNode2, offset2) {
      for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
        var map2 = i2 < 0 ? measure.map : maps[i2];
        for (var j = 0; j < map2.length; j += 3) {
          var curNode = map2[j + 2];
          if (curNode == textNode2 || curNode == topNode2) {
            var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
            var ch = map2[j] + offset2;
            if (offset2 < 0 || curNode != textNode2) {
              ch = map2[j + (offset2 ? 1 : 0)];
            }
            return Pos(line2, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist\$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist\$1), bad);
      } else {
        dist\$1 += before.textContent.length;
      }
    }
  }
  var TextareaInput = function(cm) {
    this.cm = cm;
    this.prevInput = "";
    this.pollingFast = false;
    this.polling = new Delayed();
    this.hasSelection = false;
    this.composing = null;
    this.resetting = false;
  };
  TextareaInput.prototype.init = function(display) {
    var this\$1\$1 = this;
    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;
    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
    if (ios) {
      te.style.width = "0px";
    }
    on(te, "input", function() {
      if (ie && ie_version >= 9 && this\$1\$1.hasSelection) {
        this\$1\$1.hasSelection = null;
      }
      input.poll();
    });
    on(te, "paste", function(e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
      input.fastPoll();
    });
    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") {
        cm.state.cutIncoming = +/* @__PURE__ */ new Date();
      }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function(e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
        input.focus();
        return;
      }
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });
    on(display.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function() {
      var start = cm.getCursor("from");
      if (input.composing) {
        input.composing.range.clear();
      }
      input.composing = {
        start,
        range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
      };
    });
    on(te, "compositionend", function() {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };
  TextareaInput.prototype.createField = function(_display) {
    this.wrapper = hiddenTextarea();
    this.textarea = this.wrapper.firstChild;
    var opts2 = this.cm.options;
    disableBrowserMagic(this.textarea, opts2.spellcheck, opts2.autocorrect, opts2.autocapitalize);
  };
  TextareaInput.prototype.screenReaderLabelChanged = function(label) {
    if (label) {
      this.textarea.setAttribute("aria-label", label);
    } else {
      this.textarea.removeAttribute("aria-label");
    }
  };
  TextareaInput.prototype.prepareSelection = function() {
    var cm = this.cm, display = cm.display, doc2 = cm.doc;
    var result = prepareSelection(cm);
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(
        display.wrapper.clientHeight - 10,
        headPos.top + lineOff.top - wrapOff.top
      ));
      result.teLeft = Math.max(0, Math.min(
        display.wrapper.clientWidth - 10,
        headPos.left + lineOff.left - wrapOff.left
      ));
    }
    return result;
  };
  TextareaInput.prototype.showSelection = function(drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };
  TextareaInput.prototype.reset = function(typing) {
    if (this.contextMenuPending || this.composing && typing) {
      return;
    }
    var cm = this.cm;
    this.resetting = true;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) {
        selectInput(this.textarea);
      }
      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
    this.resetting = false;
  };
  TextareaInput.prototype.getField = function() {
    return this.textarea;
  };
  TextareaInput.prototype.supportsTouch = function() {
    return false;
  };
  TextareaInput.prototype.focus = function() {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(this.textarea.ownerDocument) != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {
      }
    }
  };
  TextareaInput.prototype.blur = function() {
    this.textarea.blur();
  };
  TextareaInput.prototype.resetPosition = function() {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };
  TextareaInput.prototype.receivedFocus = function() {
    this.slowPoll();
  };
  TextareaInput.prototype.slowPoll = function() {
    var this\$1\$1 = this;
    if (this.pollingFast) {
      return;
    }
    this.polling.set(this.cm.options.pollInterval, function() {
      this\$1\$1.poll();
      if (this\$1\$1.cm.state.focused) {
        this\$1\$1.slowPoll();
      }
    });
  };
  TextareaInput.prototype.fastPoll = function() {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }
    input.polling.set(20, p);
  };
  TextareaInput.prototype.poll = function() {
    var this\$1\$1 = this;
    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }
    var text = input.value;
    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    }
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }
    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 8203 && !prevInput) {
        prevInput = "​";
      }
      if (first == 8666) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    }
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }
    runInOp(cm, function() {
      applyTextInput(
        cm,
        text.slice(same),
        prevInput.length - same,
        null,
        this\$1\$1.composing ? "*compose" : null
      );
      if (text.length > 1e3 || text.indexOf("\\n") > -1) {
        input.value = this\$1\$1.prevInput = "";
      } else {
        this\$1\$1.prevInput = text;
      }
      if (this\$1\$1.composing) {
        this\$1\$1.composing.range.clear();
        this\$1\$1.composing.range = cm.markText(
          this\$1\$1.composing.start,
          cm.getCursor("to"),
          { className: "CodeMirror-composing" }
        );
      }
    });
    return true;
  };
  TextareaInput.prototype.ensurePolled = function() {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };
  TextareaInput.prototype.onKeyPress = function() {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }
    this.fastPoll();
  };
  TextareaInput.prototype.onContextMenu = function(e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) {
      input.contextMenuPending();
    }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) {
      return;
    }
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }
    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) {
      oldScrollY = te.ownerDocument.defaultView.scrollY;
    }
    display.input.focus();
    if (webkit) {
      te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
    }
    display.input.reset();
    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "​" + (selected ? te.value : "");
        te.value = "⇚";
        te.value = extval;
        input.prevInput = selected ? "" : "​";
        te.selectionStart = 1;
        te.selectionEnd = extval.length;
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) {
        return;
      }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      }
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }
        var i2 = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "​") {
            operation(cm, selectAll)(cm);
          } else if (i2++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };
  TextareaInput.prototype.readOnlyChanged = function(val) {
    if (!val) {
      this.reset();
    }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };
  TextareaInput.prototype.setUneditable = function() {
  };
  TextareaInput.prototype.needsContentAttribute = false;
  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    if (options.autofocus == null) {
      var hasFocus = activeElt(textarea.ownerDocument);
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {
        }
      }
    }
    options.finishInit = function(cm2) {
      cm2.save = save;
      cm2.getTextArea = function() {
        return textarea;
      };
      cm2.toTextArea = function() {
        cm2.toTextArea = isNaN;
        save();
        textarea.parentNode.removeChild(cm2.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };
    textarea.style.display = "none";
    var cm = CodeMirror2(
      function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      },
      options
    );
    return cm;
  }
  function addLegacyProps(CodeMirror3) {
    CodeMirror3.off = off;
    CodeMirror3.on = on;
    CodeMirror3.wheelEventPixels = wheelEventPixels;
    CodeMirror3.Doc = Doc;
    CodeMirror3.splitLines = splitLinesAuto;
    CodeMirror3.countColumn = countColumn;
    CodeMirror3.findColumn = findColumn;
    CodeMirror3.isWordChar = isWordCharBasic;
    CodeMirror3.Pass = Pass;
    CodeMirror3.signal = signal;
    CodeMirror3.Line = Line;
    CodeMirror3.changeEnd = changeEnd;
    CodeMirror3.scrollbarModel = scrollbarModel;
    CodeMirror3.Pos = Pos;
    CodeMirror3.cmpPos = cmp;
    CodeMirror3.modes = modes;
    CodeMirror3.mimeModes = mimeModes;
    CodeMirror3.resolveMode = resolveMode;
    CodeMirror3.getMode = getMode;
    CodeMirror3.modeExtensions = modeExtensions;
    CodeMirror3.extendMode = extendMode;
    CodeMirror3.copyState = copyState;
    CodeMirror3.startState = startState;
    CodeMirror3.innerMode = innerMode;
    CodeMirror3.commands = commands;
    CodeMirror3.keyMap = keyMap;
    CodeMirror3.keyName = keyName;
    CodeMirror3.isModifierKey = isModifierKey;
    CodeMirror3.lookupKey = lookupKey;
    CodeMirror3.normalizeKeyMap = normalizeKeyMap;
    CodeMirror3.StringStream = StringStream;
    CodeMirror3.SharedTextMarker = SharedTextMarker;
    CodeMirror3.TextMarker = TextMarker;
    CodeMirror3.LineWidget = LineWidget;
    CodeMirror3.e_preventDefault = e_preventDefault;
    CodeMirror3.e_stopPropagation = e_stopPropagation;
    CodeMirror3.e_stop = e_stop;
    CodeMirror3.addClass = addClass;
    CodeMirror3.contains = contains2;
    CodeMirror3.rmClass = rmClass;
    CodeMirror3.keyNames = keyNames;
  }
  defineOptions(CodeMirror2);
  addEditorMethods(CodeMirror2);
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror2.prototype[prop] = /* @__PURE__ */ function(method) {
        return function() {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }
  eventMixin(Doc);
  CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
  CodeMirror2.defineMode = function(name) {
    if (!CodeMirror2.defaults.mode && name != "null") {
      CodeMirror2.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };
  CodeMirror2.defineMIME = defineMIME;
  CodeMirror2.defineMode("null", function() {
    return { token: function(stream) {
      return stream.skipToEnd();
    } };
  });
  CodeMirror2.defineMIME("text/plain", "null");
  CodeMirror2.defineExtension = function(name, func) {
    CodeMirror2.prototype[name] = func;
  };
  CodeMirror2.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror2.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror2);
  CodeMirror2.version = "5.65.12";
  return CodeMirror2;
});
const AR_CONTEXT_CHARS = {
  "الف": {
    general: { char: "ا", code: "ا" },
    isolated: { char: "ﺍ", code: "ﺍ" },
    end: { char: "ﺎ", code: "ﺎ" }
  },
  "باء": {
    general: { char: "ب", code: "ب" },
    isolated: { char: "ﺏ", code: "ﺏ" },
    end: { char: "ﺐ", code: "ﺐ" },
    middle: { char: "ﺒ", code: "ﺒ" },
    beginning: { char: "ﺑ", code: "ﺑ" }
  },
  "تاء": {
    general: { char: "ت", code: "ت" },
    isolated: { char: "ﺕ", code: "ﺕ" },
    end: { char: "ﺖ", code: "ﺖ" },
    middle: { char: "ﺘ", code: "ﺘ" },
    beginning: { char: "ﺗ", code: "ﺗ" }
  },
  "ثاء": {
    general: { char: "ث", code: "ث" },
    isolated: { char: "ﺙ", code: "ﺙ" },
    end: { char: "ﺚ", code: "ﺚ" },
    middle: { char: "ﺜ", code: "ﺜ" },
    beginning: { char: "ﺛ", code: "ﺛ" }
  },
  "جيم": {
    general: { char: "ج", code: "ج" },
    isolated: { char: "ﺝ", code: "ﺝ" },
    end: { char: "ﺞ", code: "ﺞ" },
    middle: { char: "ﺠ", code: "ﺠ" },
    beginning: { char: "ﺟ", code: "ﺟ" }
  },
  "حاء": {
    general: { char: "ح", code: "ح" },
    isolated: { char: "ﺡ", code: "ﺡ" },
    end: { char: "ﺢ", code: "ﺢ" },
    middle: { char: "ﺤ", code: "ﺤ" },
    beginning: { char: "ﺣ", code: "ﺣ" }
  },
  "خاء": {
    general: { char: "خ", code: "خ" },
    isolated: { char: "ﺥ", code: "ﺥ" },
    end: { char: "ﺦ", code: "ﺦ" },
    middle: { char: "ﺨ", code: "ﺨ" },
    beginning: { char: "ﺧ", code: "ﺧ" }
  },
  "دال": {
    general: { char: "د", code: "د" },
    isolated: { char: "ﺩ", code: "ﺩ" },
    end: { char: "ﺪ", code: "ﺪ" }
  },
  "ذال": {
    general: { char: "ذ", code: "ذ" },
    isolated: { char: "ﺫ", code: "ﺫ" },
    end: { char: "ﺬ", code: "ﺬ" }
  },
  "راء": {
    general: { char: "ر", code: "ر" },
    isolated: { char: "ﺭ", code: "ﺭ" },
    end: { char: "ﺮ", code: "ﺮ" }
  },
  "زين": {
    general: { char: "ز", code: "ز" },
    isolated: { char: "ﺯ", code: "ﺯ" },
    end: { char: "ﺰ", code: "ﺰ" }
  },
  "سين": {
    general: { char: "س", code: "س" },
    isolated: { char: "ﺱ", code: "ﺱ" },
    end: { char: "ﺲ", code: "ﺲ" },
    middle: { char: "ﺴ", code: "ﺴ" },
    beginning: { char: "ﺳ", code: "ﺳ" }
  },
  "شين": {
    general: { char: "ش", code: "ش" },
    isolated: { char: "ﺵ", code: "ﺵ" },
    end: { char: "ﺶ", code: "ﺶ" },
    middle: { char: "ﺸ", code: "ﺸ" },
    beginning: { char: "ﺷ", code: "ﺷ" }
  },
  "صاد": {
    general: { char: "ص", code: "ص" },
    isolated: { char: "ﺹ", code: "ﺹ" },
    end: { char: "ﺺ", code: "ﺺ" },
    middle: { char: "ﺼ", code: "ﺼ" },
    beginning: { char: "ﺻ", code: "ﺻ" }
  },
  "ضاض": {
    general: { char: "ض", code: "ض" },
    isolated: { char: "ﺽ", code: "ﺽ" },
    end: { char: "ﺾ", code: "ﺾ" },
    middle: { char: "ﻀ", code: "ﻀ" },
    beginning: { char: "ﺿ", code: "ﺿ" }
  },
  "طاء": {
    general: { char: "ط", code: "ط" },
    isolated: { char: "ﻁ", code: "ﻁ" },
    end: { char: "ﻂ", code: "ﻂ" },
    middle: { char: "ﻄ", code: "ﻄ" },
    beginning: { char: "ﻃ", code: "ﻃ" }
  },
  "ظاء": {
    general: { char: "ظ", code: "ظ" },
    isolated: { char: "ﻅ", code: "ﻅ" },
    end: { char: "ﻆ", code: "ﻆ" },
    middle: { char: "ﻈ", code: "ﻈ" },
    beginning: { char: "ﻇ", code: "ﻇ" }
  },
  "عين": {
    general: { char: "ع", code: "ع" },
    isolated: { char: "ﻉ", code: "ﻉ" },
    end: { char: "ﻊ", code: "ﻊ" },
    middle: { char: "ﻌ", code: "ﻌ" },
    beginning: { char: "ﻋ", code: "ﻋ" }
  },
  "غين": {
    general: { char: "غ", code: "غ" },
    isolated: { char: "ﻍ", code: "ﻍ" },
    end: { char: "ﻎ", code: "ﻎ" },
    middle: { char: "ﻐ", code: "ﻐ" },
    beginning: { char: "ﻏ", code: "ﻏ" }
  },
  "فاء": {
    general: { char: "ف", code: "ف" },
    isolated: { char: "ﻑ", code: "ﻑ" },
    end: { char: "ﻒ", code: "ﻒ" },
    middle: { char: "ﻔ", code: "ﻔ" },
    beginning: { char: "ﻓ", code: "ﻓ" }
  },
  "قاف": {
    general: { char: "ق", code: "ق" },
    isolated: { char: "ﻕ", code: "ﻕ" },
    end: { char: "ﻖ", code: "ﻖ" },
    middle: { char: "ﻘ", code: "ﻘ" },
    beginning: { char: "ﻗ", code: "ﻗ" }
  },
  "كاف": {
    general: { char: "ك", code: "ك" },
    isolated: { char: "ﻙ", code: "ﻙ" },
    end: { char: "ﻚ", code: "ﻚ" },
    middle: { char: "ﻜ", code: "ﻜ" },
    beginning: { char: "ﻛ", code: "ﻛ" }
  },
  "لام": {
    general: { char: "ل", code: "ل" },
    isolated: { char: "ﻝ", code: "ﻝ" },
    end: { char: "ﻞ", code: "ﻞ" },
    middle: { char: "ﻠ", code: "ﻠ" },
    beginning: { char: "ﻟ", code: "ﻟ" }
  },
  "ميم": {
    general: { char: "م", code: "م" },
    isolated: { char: "ﻡ", code: "ﻡ" },
    end: { char: "ﻢ", code: "ﻢ" },
    middle: { char: "ﻤ", code: "ﻤ" },
    beginning: { char: "ﻣ", code: "ﻣ" }
  },
  "نون": {
    general: { char: "ن", code: "ن" },
    isolated: { char: "ﻥ", code: "ﻥ" },
    end: { char: "ﻦ", code: "ﻦ" },
    middle: { char: "ﻨ", code: "ﻨ" },
    beginning: { char: "ﻧ", code: "ﻧ" }
  },
  "هاء": {
    general: { char: "ه", code: "ه" },
    isolated: { char: "ﻩ", code: "ﻩ" },
    end: { char: "ﻪ", code: "ﻪ" },
    middle: { char: "ﻬ", code: "ﻬ" },
    beginning: { char: "ﻫ", code: "ﻫ" }
  },
  "واو": {
    general: { char: "و", code: "و" },
    isolated: { char: "ﻭ", code: "ﻭ" },
    end: { char: "ﻮ", code: "ﻮ" }
  },
  "ياء": {
    general: { char: "ي", code: "ي" },
    isolated: { char: "ﻱ", code: "ﻱ" },
    end: { char: "ﻲ", code: "ﻲ" },
    middle: { char: "ﻴ", code: "ﻴ" },
    beginning: { char: "ﻳ", code: "ﻳ" }
  },
  "الف_مد": {
    general: { char: "آ", code: "آ" },
    isolated: { char: "ﺁ", code: "ﺁ" },
    end: { char: "ﺂ", code: "ﺂ" }
  },
  "تاء_مربوطة": {
    general: { char: "ة", code: "ة" },
    isolated: { char: "ﺓ", code: "ﺓ" },
    end: { char: "ﺔ", code: "ﺔ" }
  },
  "الف_مقصورة": {
    general: { char: "ى", code: "ى" },
    isolated: { char: "ﻯ", code: "ﻯ" },
    end: { char: "ﻰ", code: "ﻰ" }
  },
  // Arabic Presentation Forms-B
  // https://en.wikipedia.org/wiki/Arabic_Presentation_Forms-B 
  "همزة_ياء": {
    general: { char: "ئ", code: "ئ" },
    isolated: { char: "ﺉ", code: "ﺉ" },
    end: { char: "ﺊ", code: "ﺊ" },
    middle: { char: "ﺌ", code: "ﺌ" },
    beginning: { char: "ﺋ", code: "ﺋ" }
  }
};
const EXTENDABLE_CHARS = (() => {
  let chars = [];
  Object.values(AR_CONTEXT_CHARS).forEach((v2) => {
    if (v2.middle) {
      chars.push(v2.general.code);
      chars.push(v2.middle.code);
      chars.push(v2.beginning.code);
    }
  });
  return chars;
})();
function tatweelRegex(id2) {
  let res = [];
  id2.split("").forEach((c) => {
    if (EXTENDABLE_CHARS.includes(c)) {
      res.push(\`\${c}ـ*\`);
    } else if (c === "ـ") ;
    else {
      res.push(c);
    }
  });
  return res.join("");
}
function toEasternDigits(n) {
  let chars = ("" + n).split("");
  let ar = chars.map((d) => {
    switch (d) {
      case "0":
        return "٠";
      case "1":
        return "١";
      case "2":
        return "٢";
      case "3":
        return "٣";
      case "4":
        return "٤";
      case "5":
        return "٥";
      case "6":
        return "٦";
      case "7":
        return "٧";
      case "8":
        return "٨";
      case "9":
        return "٩";
    }
  });
  return ar.join("");
}
const OPERATORS = [
  "!",
  "?",
  "؟",
  "_",
  "[",
  "(",
  ".",
  "*",
  "×",
  "/",
  "÷",
  "+",
  "-",
  "<",
  "<=",
  "≤",
  ">",
  ">=",
  "≥",
  "==",
  "!=",
  "≠",
  "<<",
  ">>",
  "&",
  "ࢱ",
  "|و|",
  "^",
  "⊕",
  "|",
  "|ء|",
  "&&",
  "ࢱࢱ",
  "|وو|",
  "||",
  "|ءء|",
  ":>",
  "|>",
  "||>",
  "=",
  "+=",
  "-=",
  "*=",
  "×=",
  "/=",
  "÷=",
  "&=",
  "ࢱ=",
  "|=",
  "^=",
  ">>=",
  "<<=",
  ":+",
  "::",
  // separators and other symbols:
  "\$",
  "%",
  "٪",
  "#",
  "⎔",
  "~",
  "]",
  "{",
  "}",
  "\\\\)",
  "'",
  '"',
  "»",
  "«",
  "‹",
  "›"
];
const KEYWORDS = {
  use: { ar: "احضر", en: "use" },
  where: { ar: "حيث", en: "where" },
  when: { ar: "عندما", en: "when" },
  ret: { ar: "اعد", en: "return" },
  _let: { ar: "عرف", en: "let" },
  _const: { ar: "ثابت", en: "const" },
  _var: { ar: "متغير", en: "var" },
  fn: { ar: "دل", en: "fn" },
  struct: { ar: "نوع", en: "type" },
  impl: { ar: "اضافة", en: "impl" },
  trait: { ar: "سمة", en: "trait" },
  // not keywords but for highlighting purposes:
  methods: { ar: "@", en: "@" },
  res: { ar: "𞹍", en: "𞹍" },
  ok: { ar: "✓", en: "✓" },
  err: { ar: "✗", en: "✗" }
};
const ATOMS = {
  float: { ar: "عائم", en: "float" },
  int: { ar: "صحيح", en: "int" },
  str: { ar: "سلسلة", en: "str" },
  bool: { ar: "منطقي", en: "bool" },
  char: { ar: "محرف", en: "char" }
};
const BUILTINS = {
  _true: { ar: "صحيح", en: "true" },
  _false: { ar: "غير_صحيح", en: "false" },
  void: { ar: "لا_شيء", en: "void" }
};
const RESERVED = {
  ...KEYWORDS,
  ...ATOMS,
  ...BUILTINS
};
const idStart = "[\\\\p{L}_]";
const idPart = "[\\\\p{L}\\\\p{N}_]";
const id = \`(?:\${idStart}\${idPart}*)\`;
const notIdPart = "[^\\\\p{L}\\\\p{N}_]";
const easternDigit = "[٠-٩]";
const easternDecimal = \`(?:,\${easternDigit}+)\`;
const easternFloat = \`\${easternDigit}+\${easternDecimal}?\`;
const westernDigit = "[0-9]";
const westernDecimal = \`(?:\\\\.\${westernDigit}+)\`;
const westernFloat = \`\${westernDigit}+\${westernDecimal}?\`;
const backslash = \`\\\\\\\\\`;
const slash = \`\\\\/\`;
const dash = \`\\\\-\`;
const openCurly = \`\\\\{\`;
const closeCurly = \`\\\\}\`;
const openParen = \`\\\\(\`;
const closeParen = \`\\\\)\`;
const space = \`\\\\s\`;
const params = \`\${openParen}?\${space}*\${closeParen}?\`;
const attrRegex = () => RegExp(\`(?:(?:#|#)\${id})\`, "u");
const fnRegex = () => RegExp(\`(?:~\${id}?\${space}*\${params}\${space}*->)\`, "u");
const commonStartRules = [
  { regex: attrRegex(), token: "meta" },
  { regex: fnRegex(), token: ["def", null, "operator", null, "operator", null, "operator", "operator"] },
  { regex: RegExp(\`[\${OPERATORS.join("")}]+\`), token: "operator" },
  { regex: /[\\{\\[\\(]>/, indent: true },
  { regex: /[\\}\\]\\)]/, dedent: true }
];
const meta = {
  dontIndentStates: ["comment"],
  electricInput: /^\\s-\\}\$/,
  fold: "brace"
};
!function() {
  !function() {
    var n = [function(t3, e2, i) {
      var n2 = i(1).Beautifier, u2 = i(5).Options;
      t3.exports = function(t4, e3) {
        return new n2(t4, e3).beautify();
      }, t3.exports.defaultOptions = function() {
        return new u2();
      };
    }, function(t3, e2, i) {
      var n2 = i(2).Output, u2 = i(3).Token, o = i(4), _ = i(5).Options, s = i(7).Tokenizer, r = i(7).line_starters, h = i(7).positionable_operators, p = i(7).TOKEN;
      function l(t4, e3) {
        return -1 !== e3.indexOf(t4);
      }
      function a(t4, e3) {
        return t4 && t4.type === p.RESERVED && t4.text === e3;
      }
      function f(t4, e3) {
        return t4 && t4.type === p.RESERVED && l(t4.text, e3);
      }
      var c = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"], d = function(t4) {
        for (var e3 = {}, i2 = 0; i2 < t4.length; i2++) e3[t4[i2].replace(/-/g, "_")] = t4[i2];
        return e3;
      }(["before-newline", "after-newline", "preserve-newline"]), b = [d.before_newline, d.preserve_newline], g = "BlockStatement", k = "Statement", m = "ObjectLiteral", w = "ArrayLiteral", y = "ForInitializer", x = "Conditional", v2 = "Expression";
      function E(t4, e3) {
        e3.multiline_frame || e3.mode === y || e3.mode === x || t4.remove_indent(e3.start_line_index);
      }
      function R(t4) {
        return t4 === w;
      }
      function O(t4) {
        return l(t4, [v2, y, x]);
      }
      function T(t4, e3) {
        e3 = e3 || {}, this._source_text = t4 || "", this._output = null, this._tokens = null, this._last_last_text = null, this._flags = null, this._previous_flags = null, this._flag_store = null, this._options = new _(e3);
      }
      T.prototype.create_flags = function(t4, e3) {
        var i2 = 0;
        return t4 && (i2 = t4.indentation_level, !this._output.just_added_newline() && t4.line_indent_level > i2 && (i2 = t4.line_indent_level)), { mode: e3, parent: t4, last_token: t4 ? t4.last_token : new u2(p.START_BLOCK, ""), last_word: t4 ? t4.last_word : "", declaration_statement: false, declaration_assignment: false, multiline_frame: false, inline_frame: false, if_block: false, else_block: false, class_start_block: false, do_block: false, do_while: false, import_block: false, in_case_statement: false, in_case: false, case_body: false, case_block: false, indentation_level: i2, alignment: 0, line_indent_level: t4 ? t4.line_indent_level : i2, start_line_index: this._output.get_line_number(), ternary_depth: 0 };
      }, T.prototype._reset = function(t4) {
        var e3 = t4.match(/^[\\t ]*/)[0], e3 = (this._last_last_text = "", this._output = new n2(this._options, e3), this._output.raw = this._options.test_output_raw, this._flag_store = [], this.set_mode(g), new s(t4, this._options));
        return this._tokens = e3.tokenize(), t4;
      }, T.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t4 = this._reset(this._source_text), e3 = this._options.eol, i2 = ("auto" === this._options.eol && (e3 = "\\n", t4 && o.lineBreak.test(t4 || "") && (e3 = t4.match(o.lineBreak)[0])), this._tokens.next()); i2; ) this.handle_token(i2), this._last_last_text = this._flags.last_token.text, this._flags.last_token = i2, i2 = this._tokens.next();
        return this._output.get_code(e3);
      }, T.prototype.handle_token = function(t4, e3) {
        t4.type === p.START_EXPR ? this.handle_start_expr(t4) : t4.type === p.END_EXPR ? this.handle_end_expr(t4) : t4.type === p.START_BLOCK ? this.handle_start_block(t4) : t4.type === p.END_BLOCK ? this.handle_end_block(t4) : t4.type === p.WORD || t4.type === p.RESERVED ? this.handle_word(t4) : t4.type === p.SEMICOLON ? this.handle_semicolon(t4) : t4.type === p.STRING ? this.handle_string(t4) : t4.type === p.EQUALS ? this.handle_equals(t4) : t4.type === p.OPERATOR ? this.handle_operator(t4) : t4.type === p.COMMA ? this.handle_comma(t4) : t4.type === p.BLOCK_COMMENT ? this.handle_block_comment(t4, e3) : t4.type === p.COMMENT ? this.handle_comment(t4, e3) : t4.type === p.DOT ? this.handle_dot(t4) : t4.type === p.EOF ? this.handle_eof(t4) : (t4.type, p.UNKNOWN, this.handle_unknown(t4, e3));
      }, T.prototype.handle_whitespace_and_comments = function(t4, e3) {
        var i2 = t4.newlines, n3 = this._options.keep_array_indentation && R(this._flags.mode);
        if (t4.comments_before) for (var u3 = t4.comments_before.next(); u3; ) this.handle_whitespace_and_comments(u3, e3), this.handle_token(u3, e3), u3 = t4.comments_before.next();
        if (n3) for (var _2 = 0; _2 < i2; _2 += 1) this.print_newline(0 < _2, e3);
        else if (this._options.max_preserve_newlines && i2 > this._options.max_preserve_newlines && (i2 = this._options.max_preserve_newlines), this._options.preserve_newlines && 1 < i2) {
          this.print_newline(false, e3);
          for (var s2 = 1; s2 < i2; s2 += 1) this.print_newline(true, e3);
        }
      };
      var A = ["async", "break", "continue", "return", "throw", "yield"];
      T.prototype.allow_wrap_or_preserved_newline = function(t4, e3) {
        e3 = void 0 !== e3 && e3, this._output.just_added_newline() || (e3 = this._options.preserve_newlines && t4.newlines || e3, (l(this._flags.last_token.text, h) || l(t4.text, h)) && (t4 = l(this._flags.last_token.text, h) && l(this._options.operator_position, b) || l(t4.text, h), e3 = e3 && t4), e3 ? this.print_newline(false, true) : this._options.wrap_line_length && !f(this._flags.last_token, A) && this._output.set_wrap_point());
      }, T.prototype.print_newline = function(t4, e3) {
        if (!e3 && ";" !== this._flags.last_token.text && "," !== this._flags.last_token.text && "=" !== this._flags.last_token.text && (this._flags.last_token.type !== p.OPERATOR || "--" === this._flags.last_token.text || "++" === this._flags.last_token.text)) for (var i2 = this._tokens.peek(); !(this._flags.mode !== k || this._flags.if_block && a(i2, "else") || this._flags.do_block); ) this.restore_mode();
        this._output.add_new_line(t4) && (this._flags.multiline_frame = true);
      }, T.prototype.print_token_line_indentation = function(t4) {
        this._output.just_added_newline() && (this._options.keep_array_indentation && t4.newlines && ("[" === t4.text || R(this._flags.mode)) ? (this._output.current_line.set_indent(-1), this._output.current_line.push(t4.whitespace_before), this._output.space_before_token = false) : this._output.set_indent(this._flags.indentation_level, this._flags.alignment) && (this._flags.line_indent_level = this._flags.indentation_level));
      }, T.prototype.print_token = function(t4) {
        var e3;
        this._output.raw ? this._output.add_raw_token(t4) : (this._options.comma_first && t4.previous && t4.previous.type === p.COMMA && this._output.just_added_newline() && "," === this._output.previous_line.last() && (e3 = this._output.previous_line.pop(), this._output.previous_line.is_empty() && (this._output.previous_line.push(e3), this._output.trim(true), this._output.current_line.pop(), this._output.trim()), this.print_token_line_indentation(t4), this._output.add_token(","), this._output.space_before_token = true), this.print_token_line_indentation(t4), this._output.non_breaking_space = true, this._output.add_token(t4.text), this._output.previous_token_wrapped && (this._flags.multiline_frame = true));
      }, T.prototype.indent = function() {
        this._flags.indentation_level += 1, this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }, T.prototype.deindent = function() {
        0 < this._flags.indentation_level && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level) && (--this._flags.indentation_level, this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
      }, T.prototype.set_mode = function(t4) {
        this._flags ? (this._flag_store.push(this._flags), this._previous_flags = this._flags) : this._previous_flags = this.create_flags(null, t4), this._flags = this.create_flags(this._previous_flags, t4), this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }, T.prototype.restore_mode = function() {
        0 < this._flag_store.length && (this._previous_flags = this._flags, this._flags = this._flag_store.pop(), this._previous_flags.mode === k && E(this._output, this._previous_flags), this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
      }, T.prototype.start_of_object_property = function() {
        return this._flags.parent.mode === m && this._flags.mode === k && (":" === this._flags.last_token.text && 0 === this._flags.ternary_depth || f(this._flags.last_token, ["get", "set"]));
      }, T.prototype.start_of_statement = function(t4) {
        return !!(f(this._flags.last_token, ["var", "let", "const"]) && t4.type === p.WORD || a(this._flags.last_token, "do") || !(this._flags.parent.mode === m && this._flags.mode === k) && f(this._flags.last_token, A) && !t4.newlines || a(this._flags.last_token, "else") && !(a(t4, "if") && !t4.comments_before) || this._flags.last_token.type === p.END_EXPR && (this._previous_flags.mode === y || this._previous_flags.mode === x) || this._flags.last_token.type === p.WORD && this._flags.mode === g && !this._flags.in_case && !("--" === t4.text || "++" === t4.text) && "function" !== this._last_last_text && t4.type !== p.WORD && t4.type !== p.RESERVED || this._flags.mode === m && (":" === this._flags.last_token.text && 0 === this._flags.ternary_depth || f(this._flags.last_token, ["get", "set"]))) && (this.set_mode(k), this.indent(), this.handle_whitespace_and_comments(t4, true), this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4, f(t4, ["do", "for", "if", "while"])), true);
      }, T.prototype.handle_start_expr = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4);
        var e3, i2, n3 = v2;
        if ("[" === t4.text) {
          if (this._flags.last_token.type === p.WORD || ")" === this._flags.last_token.text) return f(this._flags.last_token, r) && (this._output.space_before_token = true), this.print_token(t4), this.set_mode(n3), this.indent(), void (this._options.space_in_paren && (this._output.space_before_token = true));
          n3 = w, !R(this._flags.mode) || "[" !== this._flags.last_token.text && ("," !== this._flags.last_token.text || "]" !== this._last_last_text && "}" !== this._last_last_text) || this._options.keep_array_indentation || this.print_newline(), l(this._flags.last_token.type, [p.START_EXPR, p.END_EXPR, p.WORD, p.OPERATOR, p.DOT]) || (this._output.space_before_token = true);
        } else this._flags.last_token.type === p.RESERVED ? "for" === this._flags.last_token.text ? (this._output.space_before_token = this._options.space_before_conditional, n3 = y) : l(this._flags.last_token.text, ["if", "while", "switch"]) ? (this._output.space_before_token = this._options.space_before_conditional, n3 = x) : l(this._flags.last_word, ["await", "async"]) ? this._output.space_before_token = true : "import" === this._flags.last_token.text && "" === t4.whitespace_before ? this._output.space_before_token = false : !l(this._flags.last_token.text, r) && "catch" !== this._flags.last_token.text || (this._output.space_before_token = true) : this._flags.last_token.type === p.EQUALS || this._flags.last_token.type === p.OPERATOR ? this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4) : this._flags.last_token.type === p.WORD ? (this._output.space_before_token = false, e3 = this._tokens.peek(-3), this._options.space_after_named_function && e3 && (i2 = this._tokens.peek(-4), f(e3, ["async", "function"]) || "*" === e3.text && f(i2, ["async", "function"]) ? this._output.space_before_token = true : this._flags.mode === m ? "{" !== e3.text && "," !== e3.text && ("*" !== e3.text || "{" !== i2.text && "," !== i2.text) || (this._output.space_before_token = true) : this._flags.parent && this._flags.parent.class_start_block && (this._output.space_before_token = true))) : this.allow_wrap_or_preserved_newline(t4), (this._flags.last_token.type === p.RESERVED && ("function" === this._flags.last_word || "typeof" === this._flags.last_word) || "*" === this._flags.last_token.text && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === m && l(this._last_last_text, ["{", ","]))) && (this._output.space_before_token = this._options.space_after_anon_function);
        ";" === this._flags.last_token.text || this._flags.last_token.type === p.START_BLOCK ? this.print_newline() : this._flags.last_token.type !== p.END_EXPR && this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.END_BLOCK && "." !== this._flags.last_token.text && this._flags.last_token.type !== p.COMMA || this.allow_wrap_or_preserved_newline(t4, t4.newlines), this.print_token(t4), this.set_mode(n3), this._options.space_in_paren && (this._output.space_before_token = true), this.indent();
      }, T.prototype.handle_end_expr = function(t4) {
        for (; this._flags.mode === k; ) this.restore_mode();
        this.handle_whitespace_and_comments(t4), this._flags.multiline_frame && this.allow_wrap_or_preserved_newline(t4, "]" === t4.text && R(this._flags.mode) && !this._options.keep_array_indentation), this._options.space_in_paren && (this._flags.last_token.type !== p.START_EXPR || this._options.space_in_empty_paren ? this._output.space_before_token = true : (this._output.trim(), this._output.space_before_token = false)), this.deindent(), this.print_token(t4), this.restore_mode(), E(this._output, this._previous_flags), this._flags.do_while && this._previous_flags.mode === x && (this._previous_flags.mode = v2, this._flags.do_block = false, this._flags.do_while = false);
      }, T.prototype.handle_start_block = function(t4) {
        this.handle_whitespace_and_comments(t4);
        var e3 = this._tokens.peek(), i2 = this._tokens.peek(1), i2 = ("switch" === this._flags.last_word && this._flags.last_token.type === p.END_EXPR ? (this.set_mode(g), this._flags.in_case_statement = true) : this._flags.case_body ? this.set_mode(g) : i2 && (l(i2.text, [":", ","]) && l(e3.type, [p.STRING, p.WORD, p.RESERVED]) || l(e3.text, ["get", "set", "..."]) && l(i2.type, [p.WORD, p.RESERVED])) ? l(this._last_last_text, ["class", "interface"]) && !l(i2.text, [":", ","]) ? this.set_mode(g) : this.set_mode(m) : (this._flags.last_token.type !== p.OPERATOR || "=>" !== this._flags.last_token.text) && (l(this._flags.last_token.type, [p.EQUALS, p.START_EXPR, p.COMMA, p.OPERATOR]) || f(this._flags.last_token, ["return", "throw", "import", "default"])) ? this.set_mode(m) : this.set_mode(g), this._flags.last_token && f(this._flags.last_token.previous, ["class", "extends"]) && (this._flags.class_start_block = true), !e3.comments_before && "}" === e3.text), e3 = i2 && "function" === this._flags.last_word && this._flags.last_token.type === p.END_EXPR;
        if (this._options.brace_preserve_inline) {
          var n3 = 0, u3 = null;
          this._flags.inline_frame = true;
          do {
            if ((u3 = this._tokens.peek((n3 += 1) - 1)).newlines) {
              this._flags.inline_frame = false;
              break;
            }
          } while (u3.type !== p.EOF && (u3.type !== p.END_BLOCK || u3.opened !== t4));
        }
        ("expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines) && !this._flags.inline_frame ? this._flags.last_token.type !== p.OPERATOR && (e3 || this._flags.last_token.type === p.EQUALS || f(this._flags.last_token, c) && "else" !== this._flags.last_token.text) ? this._output.space_before_token = true : this.print_newline(false, true) : (!R(this._previous_flags.mode) || this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.COMMA || (this._flags.last_token.type !== p.COMMA && !this._options.space_in_paren || (this._output.space_before_token = true), (this._flags.last_token.type === p.COMMA || this._flags.last_token.type === p.START_EXPR && this._flags.inline_frame) && (this.allow_wrap_or_preserved_newline(t4), this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame, this._flags.multiline_frame = false)), this._flags.last_token.type !== p.OPERATOR && this._flags.last_token.type !== p.START_EXPR && (l(this._flags.last_token.type, [p.START_BLOCK, p.SEMICOLON]) && !this._flags.inline_frame ? this.print_newline() : this._output.space_before_token = true)), this.print_token(t4), this.indent(), i2 || this._options.brace_preserve_inline && this._flags.inline_frame || this.print_newline();
      }, T.prototype.handle_end_block = function(t4) {
        for (this.handle_whitespace_and_comments(t4); this._flags.mode === k; ) this.restore_mode();
        var e3 = this._flags.last_token.type === p.START_BLOCK;
        this._flags.inline_frame && !e3 ? this._output.space_before_token = true : "expand" === this._options.brace_style ? e3 || this.print_newline() : e3 || (R(this._flags.mode) && this._options.keep_array_indentation ? (this._options.keep_array_indentation = false, this.print_newline(), this._options.keep_array_indentation = true) : this.print_newline()), this.restore_mode(), this.print_token(t4);
      }, T.prototype.handle_word = function(t4) {
        if (t4.type === p.RESERVED && (l(t4.text, ["set", "get"]) && this._flags.mode !== m || "import" === t4.text && l(this._tokens.peek().text, ["(", "."]) || l(t4.text, ["as", "from"]) && !this._flags.import_block || this._flags.mode === m && ":" === this._tokens.peek().text) && (t4.type = p.WORD), this.start_of_statement(t4) ? f(this._flags.last_token, ["var", "let", "const"]) && t4.type === p.WORD && (this._flags.declaration_statement = true) : !t4.newlines || O(this._flags.mode) || this._flags.last_token.type === p.OPERATOR && "--" !== this._flags.last_token.text && "++" !== this._flags.last_token.text || this._flags.last_token.type === p.EQUALS || !this._options.preserve_newlines && f(this._flags.last_token, ["var", "let", "const", "set", "get"]) ? this.handle_whitespace_and_comments(t4) : (this.handle_whitespace_and_comments(t4), this.print_newline()), this._flags.do_block && !this._flags.do_while) {
          if (a(t4, "while")) return this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true, void (this._flags.do_while = true);
          this.print_newline(), this._flags.do_block = false;
        }
        if (this._flags.if_block) if (!this._flags.else_block && a(t4, "else")) this._flags.else_block = true;
        else {
          for (; this._flags.mode === k; ) this.restore_mode();
          this._flags.if_block = false, this._flags.else_block = false;
        }
        if (this._flags.in_case_statement && f(t4, ["case", "default"])) return this.print_newline(), this._flags.case_block || !this._flags.case_body && !this._options.jslint_happy || this.deindent(), this._flags.case_body = false, this.print_token(t4), void (this._flags.in_case = true);
        if (this._flags.last_token.type !== p.COMMA && this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.EQUALS && this._flags.last_token.type !== p.OPERATOR || this.start_of_object_property() || l(this._flags.last_token.text, ["+", "-"]) && ":" === this._last_last_text && this._flags.parent.mode === m || this.allow_wrap_or_preserved_newline(t4), a(t4, "function")) return !(l(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !l(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) && this._flags.last_token.type !== p.OPERATOR) || this._output.just_added_blankline() || t4.comments_before || (this.print_newline(), this.print_newline(true)), this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD ? f(this._flags.last_token, ["get", "set", "new", "export"]) || f(this._flags.last_token, A) || a(this._flags.last_token, "default") && "export" === this._last_last_text || "declare" === this._flags.last_token.text ? this._output.space_before_token = true : this.print_newline() : this._flags.last_token.type === p.OPERATOR || "=" === this._flags.last_token.text ? this._output.space_before_token = true : !this._flags.multiline_frame && (O(this._flags.mode) || R(this._flags.mode)) || this.print_newline(), this.print_token(t4), void (this._flags.last_word = t4.text);
        var e3 = "NONE";
        this._flags.last_token.type === p.END_BLOCK ? this._previous_flags.inline_frame ? e3 = "SPACE" : !f(t4, ["else", "catch", "finally", "from"]) || "expand" === this._options.brace_style || "end-expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines ? e3 = "NEWLINE" : (e3 = "SPACE", this._output.space_before_token = true) : this._flags.last_token.type === p.SEMICOLON && this._flags.mode === g ? e3 = "NEWLINE" : this._flags.last_token.type === p.SEMICOLON && O(this._flags.mode) ? e3 = "SPACE" : this._flags.last_token.type === p.STRING ? e3 = "NEWLINE" : this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD || "*" === this._flags.last_token.text && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === m && l(this._last_last_text, ["{", ","])) ? e3 = "SPACE" : this._flags.last_token.type === p.START_BLOCK ? e3 = this._flags.inline_frame ? "SPACE" : "NEWLINE" : this._flags.last_token.type === p.END_EXPR && (this._output.space_before_token = true, e3 = "NEWLINE"), f(t4, r) && ")" !== this._flags.last_token.text && (e3 = this._flags.inline_frame || "else" === this._flags.last_token.text || "export" === this._flags.last_token.text ? "SPACE" : "NEWLINE"), f(t4, ["else", "catch", "finally"]) ? (this._flags.last_token.type !== p.END_BLOCK || this._previous_flags.mode !== g || "expand" === this._options.brace_style || "end-expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines) && !this._flags.inline_frame ? this.print_newline() : (this._output.trim(true), "}" !== this._output.current_line.last() && this.print_newline(), this._output.space_before_token = true) : "NEWLINE" === e3 ? f(this._flags.last_token, c) || "declare" === this._flags.last_token.text && f(t4, ["var", "let", "const"]) ? this._output.space_before_token = true : this._flags.last_token.type !== p.END_EXPR ? this._flags.last_token.type === p.START_EXPR && f(t4, ["var", "let", "const"]) || ":" === this._flags.last_token.text || (a(t4, "if") && a(t4.previous, "else") ? this._output.space_before_token = true : this.print_newline()) : f(t4, r) && ")" !== this._flags.last_token.text && this.print_newline() : this._flags.multiline_frame && R(this._flags.mode) && "," === this._flags.last_token.text && "}" === this._last_last_text ? this.print_newline() : "SPACE" === e3 && (this._output.space_before_token = true), !t4.previous || t4.previous.type !== p.WORD && t4.previous.type !== p.RESERVED || (this._output.space_before_token = true), this.print_token(t4), this._flags.last_word = t4.text, t4.type === p.RESERVED && ("do" === t4.text ? this._flags.do_block = true : "if" === t4.text ? this._flags.if_block = true : "import" === t4.text ? this._flags.import_block = true : this._flags.import_block && a(t4, "from") && (this._flags.import_block = false));
      }, T.prototype.handle_semicolon = function(t4) {
        this.start_of_statement(t4) ? this._output.space_before_token = false : this.handle_whitespace_and_comments(t4);
        for (var e3 = this._tokens.peek(); !(this._flags.mode !== k || this._flags.if_block && a(e3, "else") || this._flags.do_block); ) this.restore_mode();
        this._flags.import_block && (this._flags.import_block = false), this.print_token(t4);
      }, T.prototype.handle_string = function(t4) {
        t4.text.startsWith("\`") && 0 === t4.newlines && "" === t4.whitespace_before && (")" === t4.previous.text || this._flags.last_token.type === p.WORD) || (this.start_of_statement(t4) ? this._output.space_before_token = true : (this.handle_whitespace_and_comments(t4), this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD || this._flags.inline_frame ? this._output.space_before_token = true : this._flags.last_token.type === p.COMMA || this._flags.last_token.type === p.START_EXPR || this._flags.last_token.type === p.EQUALS || this._flags.last_token.type === p.OPERATOR ? this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4) : !t4.text.startsWith("\`") || this._flags.last_token.type !== p.END_EXPR || "]" !== t4.previous.text && ")" !== t4.previous.text || 0 !== t4.newlines ? this.print_newline() : this._output.space_before_token = true)), this.print_token(t4);
      }, T.prototype.handle_equals = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4), this._flags.declaration_statement && (this._flags.declaration_assignment = true), this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true;
      }, T.prototype.handle_comma = function(t4) {
        this.handle_whitespace_and_comments(t4, true), this.print_token(t4), this._output.space_before_token = true, this._flags.declaration_statement ? (O(this._flags.parent.mode) && (this._flags.declaration_assignment = false), this._flags.declaration_assignment ? (this._flags.declaration_assignment = false, this.print_newline(false, true)) : this._options.comma_first && this.allow_wrap_or_preserved_newline(t4)) : this._flags.mode === m || this._flags.mode === k && this._flags.parent.mode === m ? (this._flags.mode === k && this.restore_mode(), this._flags.inline_frame || this.print_newline()) : this._options.comma_first && this.allow_wrap_or_preserved_newline(t4);
      }, T.prototype.handle_operator = function(t4) {
        var e3 = "*" === t4.text && (f(this._flags.last_token, ["function", "yield"]) || l(this._flags.last_token.type, [p.START_BLOCK, p.COMMA, p.END_BLOCK, p.SEMICOLON])), i2 = l(t4.text, ["-", "+"]) && (l(this._flags.last_token.type, [p.START_BLOCK, p.START_EXPR, p.EQUALS, p.OPERATOR]) || l(this._flags.last_token.text, r) || "," === this._flags.last_token.text);
        if (this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4, !e3), "*" === t4.text && this._flags.last_token.type === p.DOT) this.print_token(t4);
        else if ("::" === t4.text) this.print_token(t4);
        else if (l(t4.text, ["-", "+"]) && this.start_of_object_property()) this.print_token(t4);
        else {
          if (this._flags.last_token.type === p.OPERATOR && l(this._options.operator_position, b) && this.allow_wrap_or_preserved_newline(t4), ":" === t4.text && this._flags.in_case) return this.print_token(t4), this._flags.in_case = false, this._flags.case_body = true, void (this._tokens.peek().type !== p.START_BLOCK ? (this.indent(), this.print_newline(), this._flags.case_block = false) : (this._flags.case_block = true, this._output.space_before_token = true));
          var n3 = true, u3 = true, _2 = false;
          if (":" === t4.text ? 0 === this._flags.ternary_depth ? n3 = false : (--this._flags.ternary_depth, _2 = true) : "?" === t4.text && (this._flags.ternary_depth += 1), !i2 && !e3 && this._options.preserve_newlines && l(t4.text, h)) {
            var s2 = ":" === t4.text, a2 = s2 && _2, o2 = s2 && !_2;
            switch (this._options.operator_position) {
              case d.before_newline:
                return this._output.space_before_token = !o2, this.print_token(t4), s2 && !a2 || this.allow_wrap_or_preserved_newline(t4), void (this._output.space_before_token = true);
              case d.after_newline:
                return this._output.space_before_token = true, !s2 || a2 ? this._tokens.peek().newlines ? this.print_newline(false, true) : this.allow_wrap_or_preserved_newline(t4) : this._output.space_before_token = false, this.print_token(t4), void (this._output.space_before_token = true);
              case d.preserve_newline:
                return o2 || this.allow_wrap_or_preserved_newline(t4), n3 = !(this._output.just_added_newline() || o2), this._output.space_before_token = n3, this.print_token(t4), void (this._output.space_before_token = true);
            }
          }
          e3 ? (this.allow_wrap_or_preserved_newline(t4), n3 = false, u3 = (_2 = this._tokens.peek()) && l(_2.type, [p.WORD, p.RESERVED])) : "..." === t4.text ? (this.allow_wrap_or_preserved_newline(t4), n3 = this._flags.last_token.type === p.START_BLOCK, u3 = false) : (l(t4.text, ["--", "++", "!", "~"]) || i2) && (this._flags.last_token.type !== p.COMMA && this._flags.last_token.type !== p.START_EXPR || this.allow_wrap_or_preserved_newline(t4), u3 = n3 = false, !t4.newlines || "--" !== t4.text && "++" !== t4.text && "~" !== t4.text || ((e3 = f(this._flags.last_token, c) && t4.newlines) && (this._previous_flags.if_block || this._previous_flags.else_block) && this.restore_mode(), this.print_newline(e3, true)), ";" === this._flags.last_token.text && O(this._flags.mode) && (n3 = true), this._flags.last_token.type === p.RESERVED ? n3 = true : this._flags.last_token.type === p.END_EXPR ? n3 = !("]" === this._flags.last_token.text && ("--" === t4.text || "++" === t4.text)) : this._flags.last_token.type === p.OPERATOR && (n3 = l(t4.text, ["--", "-", "++", "+"]) && l(this._flags.last_token.text, ["--", "-", "++", "+"]), l(t4.text, ["+", "-"]) && l(this._flags.last_token.text, ["--", "++"]) && (u3 = true)), (this._flags.mode !== g || this._flags.inline_frame) && this._flags.mode !== k || "{" !== this._flags.last_token.text && ";" !== this._flags.last_token.text || this.print_newline()), this._output.space_before_token = this._output.space_before_token || n3, this.print_token(t4), this._output.space_before_token = u3;
        }
      }, T.prototype.handle_block_comment = function(t4, e3) {
        return this._output.raw ? (this._output.add_raw_token(t4), void (t4.directives && "end" === t4.directives.preserve && (this._output.raw = this._options.test_output_raw))) : t4.directives ? (this.print_newline(false, e3), this.print_token(t4), "start" === t4.directives.preserve && (this._output.raw = true), void this.print_newline(false, true)) : void (o.newline.test(t4.text) || t4.newlines ? this.print_block_commment(t4, e3) : (this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true));
      }, T.prototype.print_block_commment = function(t4, e3) {
        var i2, n3, u3, _2 = function(t5) {
          for (var e4 = [], i3 = (t5 = t5.replace(o.allLineBreaks, "\\n")).indexOf("\\n"); -1 !== i3; ) e4.push(t5.substring(0, i3)), i3 = (t5 = t5.substring(i3 + 1)).indexOf("\\n");
          return t5.length && e4.push(t5), e4;
        }(t4.text), s2 = t4.whitespace_before, a2 = s2.length;
        if (this.print_newline(false, e3), this.print_token_line_indentation(t4), this._output.add_token(_2[0]), this.print_newline(false, e3), 1 < _2.length) {
          for (n3 = function(t5, e4) {
            for (var i3 = 0; i3 < t5.length; i3++) if (t5[i3].trim().charAt(0) !== e4) return false;
            return true;
          }(_2 = _2.slice(1), "*"), u3 = function(t5, e4) {
            for (var i3, n4 = 0, u4 = t5.length; n4 < u4; n4++) if ((i3 = t5[n4]) && 0 !== i3.indexOf(e4)) return false;
            return true;
          }(_2, s2), n3 && (this._flags.alignment = 1), i2 = 0; i2 < _2.length; i2++) n3 ? (this.print_token_line_indentation(t4), this._output.add_token(_2[i2].replace(/^\\s+/g, ""))) : u3 && _2[i2] ? (this.print_token_line_indentation(t4), this._output.add_token(_2[i2].substring(a2))) : (this._output.current_line.set_indent(-1), this._output.add_token(_2[i2])), this.print_newline(false, e3);
          this._flags.alignment = 0;
        }
      }, T.prototype.handle_comment = function(t4, e3) {
        t4.newlines ? this.print_newline(false, e3) : this._output.trim(true), this._output.space_before_token = true, this.print_token(t4), this.print_newline(false, e3);
      }, T.prototype.handle_dot = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4, true), this._flags.last_token.text.match("^[0-9]+\$") && (this._output.space_before_token = true), f(this._flags.last_token, c) ? this._output.space_before_token = false : this.allow_wrap_or_preserved_newline(t4, ")" === this._flags.last_token.text && this._options.break_chained_methods), this._options.unindent_chained_methods && this._output.just_added_newline() && this.deindent(), this.print_token(t4);
      }, T.prototype.handle_unknown = function(t4, e3) {
        this.print_token(t4), "\\n" === t4.text[t4.text.length - 1] && this.print_newline(false, e3);
      }, T.prototype.handle_eof = function(t4) {
        for (; this._flags.mode === k; ) this.restore_mode();
        this.handle_whitespace_and_comments(t4);
      }, t3.exports.Beautifier = T;
    }, function(t3) {
      function u2(t4) {
        this.__parent = t4, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function i(t4, e3) {
        this.__cache = [""], this.__indent_size = t4.indent_size, this.__indent_string = t4.indent_char, t4.indent_with_tabs || (this.__indent_string = new Array(t4.indent_size + 1).join(t4.indent_char)), e3 = e3 || "", 0 < t4.indent_level && (e3 = new Array(t4.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t4, e3) {
        this.__indent_cache = new i(t4, e3), this.raw = false, this._end_with_newline = t4.end_with_newline, this.indent_size = t4.indent_size, this.wrap_line_length = t4.wrap_line_length, this.indent_empty_lines = t4.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new u2(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      u2.prototype.clone_empty = function() {
        var t4 = new u2(this.__parent);
        return t4.set_indent(this.__indent_count, this.__alignment_count), t4;
      }, u2.prototype.item = function(t4) {
        return t4 < 0 ? this.__items[this.__items.length + t4] : this.__items[t4];
      }, u2.prototype.has_match = function(t4) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t4)) return true;
        return false;
      }, u2.prototype.set_indent = function(t4, e3) {
        this.is_empty() && (this.__indent_count = t4 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, u2.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, u2.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, u2.prototype._allow_wrap = function() {
        var t4;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t4 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t4.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t4.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t4.__items[0] && (t4.__items.splice(0, 1), --t4.__character_count), true);
      }, u2.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, u2.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, u2.prototype.push = function(t4) {
        this.__items.push(t4);
        var e3 = t4.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t4.length - e3 : this.__character_count += t4.length;
      }, u2.prototype.pop = function() {
        var t4 = null;
        return this.is_empty() || (t4 = this.__items.pop(), this.__character_count -= t4.length), t4;
      }, u2.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, u2.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, u2.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, u2.prototype.toString = function() {
        var t4 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t4 = this.__parent.get_indent_string(this.__indent_count)) : (t4 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t4 += this.__items.join("")), t4;
      }, i.prototype.get_indent_size = function(t4, e3) {
        var i2 = this.__base_string_length;
        return i2 = (i2 = t4 < 0 ? 0 : i2) + t4 * this.__indent_size + (e3 = e3 || 0);
      }, i.prototype.get_indent_string = function(t4, e3) {
        var i2 = this.__base_string;
        return e3 = e3 || 0, t4 < 0 && (t4 = 0, i2 = ""), e3 += t4 * this.__indent_size, this.__ensure_cache(e3), i2 += this.__cache[e3];
      }, i.prototype.__ensure_cache = function(t4) {
        for (; t4 >= this.__cache.length; ) this.__add_column();
      }, i.prototype.__add_column = function() {
        var t4, e3 = this.__cache.length, i2 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t4 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, i2 = new Array(t4 + 1).join(this.__indent_string)), e3 && (i2 += new Array(e3 + 1).join(" ")), this.__cache.push(i2);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t4, e3) {
        return this.__indent_cache.get_indent_string(t4, e3);
      }, e2.prototype.get_indent_size = function(t4, e3) {
        return this.__indent_cache.get_indent_size(t4, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t4) {
        return !(this.is_empty() || !t4 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t4) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t4 ? e3.replace(/[\\n]/g, t4) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t4, e3) {
        return this.next_line.set_indent(t4 = t4 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t4, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t4) {
        for (var e3 = 0; e3 < t4.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t4.whitespace_before), this.current_line.push(t4.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t4) {
        this.__add_space_before_token(), this.current_line.push(t4), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t4) {
        for (var e3 = this.__lines.length; t4 < e3; ) this.__lines[t4]._remove_indent(), t4++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t4) {
        for (t4 = void 0 !== t4 && t4, this.current_line.trim(); t4 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t4, e3) {
        for (var i2 = this.__lines.length - 2; 0 <= i2; ) {
          var n2 = this.__lines[i2];
          if (n2.is_empty()) break;
          if (0 !== n2.item(0).indexOf(t4) && n2.item(-1) !== e3) {
            this.__lines.splice(i2 + 1, 0, new u2(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          i2--;
        }
      }, t3.exports.Output = e2;
    }, function(t3) {
      t3.exports.Token = function(t4, e2, i, n2) {
        this.type = t4, this.text = e2, this.comments_before = null, this.newlines = i || 0, this.whitespace_before = n2 || "", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this.directives = null;
      };
    }, function(t3, e2) {
      var i = "\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a", n2 = "\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc", u2 = "\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f", _ = "\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}", s = "(?:" + _ + "|[\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a" + n2 + "])";
      e2.identifier = new RegExp(s + "(?:\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}|[\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f])*", "g"), e2.identifierStart = new RegExp(s), e2.identifierMatch = new RegExp("(?:" + _ + "|[" + i + n2 + u2 + "])+");
      e2.newline = /[\\n\\r\\u2028\\u2029]/, e2.lineBreak = new RegExp("\\r\\n|" + e2.newline.source), e2.allLineBreaks = new RegExp(e2.lineBreak.source, "g");
    }, function(t3, e2, i) {
      var n2 = i(6).Options, u2 = ["before-newline", "after-newline", "preserve-newline"];
      function _(t4) {
        n2.call(this, t4, "js");
        var t4 = this.raw_options.brace_style || null, e3 = ("expand-strict" === t4 ? this.raw_options.brace_style = "expand" : "collapse-preserve-inline" === t4 ? this.raw_options.brace_style = "collapse,preserve-inline" : void 0 !== this.raw_options.braces_on_own_line && (this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse"), this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]));
        this.brace_preserve_inline = false, this.brace_style = "collapse";
        for (var i2 = 0; i2 < e3.length; i2++) "preserve-inline" === e3[i2] ? this.brace_preserve_inline = true : this.brace_style = e3[i2];
        this.unindent_chained_methods = this._get_boolean("unindent_chained_methods"), this.break_chained_methods = this._get_boolean("break_chained_methods"), this.space_in_paren = this._get_boolean("space_in_paren"), this.space_in_empty_paren = this._get_boolean("space_in_empty_paren"), this.jslint_happy = this._get_boolean("jslint_happy"), this.space_after_anon_function = this._get_boolean("space_after_anon_function"), this.space_after_named_function = this._get_boolean("space_after_named_function"), this.keep_array_indentation = this._get_boolean("keep_array_indentation"), this.space_before_conditional = this._get_boolean("space_before_conditional", true), this.unescape_strings = this._get_boolean("unescape_strings"), this.e4x = this._get_boolean("e4x"), this.comma_first = this._get_boolean("comma_first"), this.operator_position = this._get_selection("operator_position", u2), this.test_output_raw = this._get_boolean("test_output_raw"), this.jslint_happy && (this.space_after_anon_function = true);
      }
      _.prototype = new n2(), t3.exports.Options = _;
    }, function(t3) {
      function e2(t4, e3) {
        this.raw_options = i(t4, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function i(t4, e3) {
        var i2, n2 = {};
        for (i2 in t4 = u2(t4)) i2 !== e3 && (n2[i2] = t4[i2]);
        if (e3 && t4[e3]) for (i2 in t4[e3]) n2[i2] = t4[e3][i2];
        return n2;
      }
      function u2(t4) {
        var e3, i2 = {};
        for (e3 in t4) i2[e3.replace(/-/g, "_")] = t4[e3];
        return i2;
      }
      e2.prototype._get_array = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || [];
        return "object" == typeof t4 ? null !== t4 && "function" == typeof t4.concat && (e3 = t4.concat()) : "string" == typeof t4 && (e3 = t4.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t4, e3) {
        t4 = this.raw_options[t4];
        return void 0 === t4 ? !!e3 : !!t4;
      }, e2.prototype._get_characters = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || "";
        return e3 = "string" == typeof t4 ? t4.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t4 = parseInt(t4, 10);
        return t4 = isNaN(t4) ? e3 : t4;
      }, e2.prototype._get_selection = function(t4, e3, i2) {
        i2 = this._get_selection_list(t4, e3, i2);
        if (1 !== i2.length) throw new Error("Invalid Option Value: The option '" + t4 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
        return i2[0];
      }, e2.prototype._get_selection_list = function(t4, e3, i2) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (i2 = i2 || [e3[0]], !this._is_valid_selection(i2, e3)) throw new Error("Invalid Default Value!");
        i2 = this._get_array(t4, i2);
        if (this._is_valid_selection(i2, e3)) return i2;
        throw new Error("Invalid Option Value: The option '" + t4 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
      }, e2.prototype._is_valid_selection = function(t4, e3) {
        return t4.length && e3.length && !t4.some(function(t5) {
          return -1 === e3.indexOf(t5);
        });
      }, t3.exports.Options = e2, t3.exports.normalizeOpts = u2, t3.exports.mergeOpts = i;
    }, function(t3, e2, i) {
      var _ = i(8).InputScanner, n2 = i(9).Tokenizer, u2 = i(9).TOKEN, s = i(13).Directives, r = i(4), a = i(12).Pattern, o = i(14).TemplatablePattern;
      function h(t4, e3) {
        return -1 !== e3.indexOf(t4);
      }
      function p(t4, e3) {
        n2.call(this, t4, e3), this._patterns.whitespace = this._patterns.whitespace.matching(/\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source, /\\u2028\\u2029/.source), t4 = new a(this._input), e3 = new o(this._input).read_options(this._options), this.__patterns = { template: e3, identifier: e3.starting_with(r.identifier).matching(r.identifierMatch), number: t4.matching(d), punct: t4.matching(k), comment: t4.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/), block_comment: t4.starting_with(/\\/\\*/).until_after(/\\*\\//), html_comment_start: t4.matching(/<!--/), html_comment_end: t4.matching(/-->/), include: t4.starting_with(/#include/).until_after(r.lineBreak), shebang: t4.starting_with(/#!/).until_after(r.lineBreak), xml: t4.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\\[CDATA\\[[^\\]]*?\\]\\]|)(\\s*{[^}]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\\s*(\\/?)\\s*>/), single_quote: e3.until(/['\\\\\\n\\r\\u2028\\u2029]/), double_quote: e3.until(/["\\\\\\n\\r\\u2028\\u2029]/), template_text: e3.until(/[\`\\\\\$]/), template_expression: e3.until(/[\`}\\\\]/) };
      }
      var l, f = { START_EXPR: "TK_START_EXPR", END_EXPR: "TK_END_EXPR", START_BLOCK: "TK_START_BLOCK", END_BLOCK: "TK_END_BLOCK", WORD: "TK_WORD", RESERVED: "TK_RESERVED", SEMICOLON: "TK_SEMICOLON", STRING: "TK_STRING", EQUALS: "TK_EQUALS", OPERATOR: "TK_OPERATOR", COMMA: "TK_COMMA", BLOCK_COMMENT: "TK_BLOCK_COMMENT", COMMENT: "TK_COMMENT", DOT: "TK_DOT", UNKNOWN: "TK_UNKNOWN", START: u2.START, RAW: u2.RAW, EOF: u2.EOF }, c = new s(/\\/\\*/, /\\*\\//), d = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\\d[\\d_]*n|(?:\\.\\d[\\d_]*|\\d[\\d_]*\\.?[\\d_]*)(?:[eE][+-]?[\\d_]+)?/, b = /[0-9]/, g = /[^\\d\\.]/, i = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" "), u2 = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |", k = (u2 = (u2 = "\\\\?\\\\.(?!\\\\d) " + (u2 = u2.replace(/[-[\\]{}()*+?.,\\\\^\$|#]/g, "\\\\\$&"))).replace(/ /g, "|"), new RegExp(u2)), s = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(","), u2 = s.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]), m = new RegExp("^(?:" + u2.join("|") + ")\$");
      (p.prototype = new n2())._is_comment = function(t4) {
        return t4.type === f.COMMENT || t4.type === f.BLOCK_COMMENT || t4.type === f.UNKNOWN;
      }, p.prototype._is_opening = function(t4) {
        return t4.type === f.START_BLOCK || t4.type === f.START_EXPR;
      }, p.prototype._is_closing = function(t4, e3) {
        return (t4.type === f.END_BLOCK || t4.type === f.END_EXPR) && e3 && ("]" === t4.text && "[" === e3.text || ")" === t4.text && "(" === e3.text || "}" === t4.text && "{" === e3.text);
      }, p.prototype._reset = function() {
        l = false;
      }, p.prototype._get_next_token = function(t4, e3) {
        this._readWhitespace();
        var i2 = this._input.peek();
        return null === i2 ? this._create_token(f.EOF, "") : this._read_non_javascript(i2) || this._read_string(i2) || this._read_pair(i2, this._input.peek(1)) || this._read_word(t4) || this._read_singles(i2) || this._read_comment(i2) || this._read_regexp(i2, t4) || this._read_xml(i2, t4) || this._read_punctuation() || this._create_token(f.UNKNOWN, this._input.next());
      }, p.prototype._read_word = function(t4) {
        var e3 = this.__patterns.identifier.read();
        return "" !== e3 ? (e3 = e3.replace(r.allLineBreaks, "\\n"), t4.type !== f.DOT && (t4.type !== f.RESERVED || "set" !== t4.text && "get" !== t4.text) && m.test(e3) ? "in" !== e3 && "of" !== e3 || t4.type !== f.WORD && t4.type !== f.STRING ? this._create_token(f.RESERVED, e3) : this._create_token(f.OPERATOR, e3) : this._create_token(f.WORD, e3)) : "" !== (e3 = this.__patterns.number.read()) ? this._create_token(f.WORD, e3) : void 0;
      }, p.prototype._read_singles = function(t4) {
        var e3 = null;
        return "(" === t4 || "[" === t4 ? e3 = this._create_token(f.START_EXPR, t4) : ")" === t4 || "]" === t4 ? e3 = this._create_token(f.END_EXPR, t4) : "{" === t4 ? e3 = this._create_token(f.START_BLOCK, t4) : "}" === t4 ? e3 = this._create_token(f.END_BLOCK, t4) : ";" === t4 ? e3 = this._create_token(f.SEMICOLON, t4) : "." === t4 && g.test(this._input.peek(1)) ? e3 = this._create_token(f.DOT, t4) : "," === t4 && (e3 = this._create_token(f.COMMA, t4)), e3 && this._input.next(), e3;
      }, p.prototype._read_pair = function(t4, e3) {
        var i2 = null;
        return (i2 = "#" === t4 && "{" === e3 ? this._create_token(f.START_BLOCK, t4 + e3) : i2) && (this._input.next(), this._input.next()), i2;
      }, p.prototype._read_punctuation = function() {
        var t4 = this.__patterns.punct.read();
        if ("" !== t4) return "=" === t4 ? this._create_token(f.EQUALS, t4) : "?." === t4 ? this._create_token(f.DOT, t4) : this._create_token(f.OPERATOR, t4);
      }, p.prototype._read_non_javascript = function(t4) {
        var e3 = "";
        if ("#" === t4) {
          if (this._is_first_token() && (e3 = this.__patterns.shebang.read())) return this._create_token(f.UNKNOWN, e3.trim() + "\\n");
          if (e3 = this.__patterns.include.read()) return this._create_token(f.UNKNOWN, e3.trim() + "\\n");
          t4 = this._input.next();
          var i2 = "#";
          if (this._input.hasNext() && this._input.testChar(b)) {
            for (; i2 += t4 = this._input.next(), this._input.hasNext() && "#" !== t4 && "=" !== t4; ) ;
            return "#" !== t4 && ("[" === this._input.peek() && "]" === this._input.peek(1) ? (i2 += "[]", this._input.next(), this._input.next()) : "{" === this._input.peek() && "}" === this._input.peek(1) && (i2 += "{}", this._input.next(), this._input.next())), this._create_token(f.WORD, i2);
          }
          this._input.back();
        } else if ("<" === t4 && this._is_first_token()) {
          if (e3 = this.__patterns.html_comment_start.read()) {
            for (; this._input.hasNext() && !this._input.testChar(r.newline); ) e3 += this._input.next();
            return l = true, this._create_token(f.COMMENT, e3);
          }
        } else if (l && "-" === t4 && (e3 = this.__patterns.html_comment_end.read())) return l = false, this._create_token(f.COMMENT, e3);
        return null;
      }, p.prototype._read_comment = function(t4) {
        var e3, i2 = null;
        return "/" === t4 && (t4 = "", "*" === this._input.peek(1) ? (t4 = this.__patterns.block_comment.read(), (e3 = c.get_directives(t4)) && "start" === e3.ignore && (t4 += c.readIgnored(this._input)), t4 = t4.replace(r.allLineBreaks, "\\n"), (i2 = this._create_token(f.BLOCK_COMMENT, t4)).directives = e3) : "/" === this._input.peek(1) && (t4 = this.__patterns.comment.read(), i2 = this._create_token(f.COMMENT, t4))), i2;
      }, p.prototype._read_string = function(t4) {
        var e3;
        return "\`" === t4 || "'" === t4 || '"' === t4 ? (e3 = this._input.next(), this.has_char_escapes = false, e3 += "\`" === t4 ? this._read_string_recursive("\`", true, "\${") : this._read_string_recursive(t4), this.has_char_escapes && this._options.unescape_strings && (e3 = function(t5) {
          var e4 = "", i2 = 0, n3 = new _(t5), u3 = null;
          for (; n3.hasNext(); ) if ((u3 = n3.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g)) && (e4 += u3[0]), "\\\\" === n3.peek()) {
            if (n3.next(), "x" === n3.peek()) u3 = n3.match(/x([0-9A-Fa-f]{2})/g);
            else {
              if ("u" !== n3.peek()) {
                e4 += "\\\\", n3.hasNext() && (e4 += n3.next());
                continue;
              }
              u3 = (u3 = n3.match(/u([0-9A-Fa-f]{4})/g)) || n3.match(/u\\{([0-9A-Fa-f]+)\\}/g);
            }
            if (!u3) return t5;
            if (126 < (i2 = parseInt(u3[1], 16)) && i2 <= 255 && 0 === u3[0].indexOf("x")) return t5;
            e4 += 0 <= i2 && i2 < 32 || 1114111 < i2 ? "\\\\" + u3[0] : 34 === i2 || 39 === i2 || 92 === i2 ? "\\\\" + String.fromCharCode(i2) : String.fromCharCode(i2);
          }
          return e4;
        }(e3)), this._input.peek() === t4 && (e3 += this._input.next()), e3 = e3.replace(r.allLineBreaks, "\\n"), this._create_token(f.STRING, e3)) : null;
      }, p.prototype._allow_regexp_or_xml = function(t4) {
        return t4.type === f.RESERVED && h(t4.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || t4.type === f.END_EXPR && ")" === t4.text && t4.opened.previous.type === f.RESERVED && h(t4.opened.previous.text, ["if", "while", "for"]) || h(t4.type, [f.COMMENT, f.START_EXPR, f.START_BLOCK, f.START, f.END_BLOCK, f.OPERATOR, f.EQUALS, f.EOF, f.SEMICOLON, f.COMMA]);
      }, p.prototype._read_regexp = function(t4, e3) {
        if ("/" === t4 && this._allow_regexp_or_xml(e3)) {
          for (var i2 = this._input.next(), n3 = false, u3 = false; this._input.hasNext() && (n3 || u3 || this._input.peek() !== t4) && !this._input.testChar(r.newline); ) i2 += this._input.peek(), n3 ? n3 = false : (n3 = "\\\\" === this._input.peek(), "[" === this._input.peek() ? u3 = true : "]" === this._input.peek() && (u3 = false)), this._input.next();
          return this._input.peek() === t4 && (i2 = (i2 += this._input.next()) + this._input.read(r.identifier)), this._create_token(f.STRING, i2);
        }
        return null;
      }, p.prototype._read_xml = function(t4, e3) {
        if (this._options.e4x && "<" === t4 && this._allow_regexp_or_xml(e3)) {
          var i2 = "", n3 = this.__patterns.xml.read_match();
          if (n3) {
            for (var u3 = n3[2].replace(/^{\\s+/, "{").replace(/\\s+}\$/, "}"), _2 = 0 === u3.indexOf("{"), s2 = 0; n3; ) {
              var a2 = !!n3[1], o2 = n3[2];
              if (!(!!n3[n3.length - 1] || "![CDATA[" === o2.slice(0, 8)) && (o2 === u3 || _2 && o2.replace(/^{\\s+/, "{").replace(/\\s+}\$/, "}")) && (a2 ? --s2 : ++s2), i2 += n3[0], s2 <= 0) break;
              n3 = this.__patterns.xml.read_match();
            }
            return n3 || (i2 += this._input.match(/[\\s\\S]*/g)[0]), i2 = i2.replace(r.allLineBreaks, "\\n"), this._create_token(f.STRING, i2);
          }
        }
        return null;
      }, p.prototype._read_string_recursive = function(t4, e3, i2) {
        "'" === t4 ? u3 = this.__patterns.single_quote : '"' === t4 ? u3 = this.__patterns.double_quote : "\`" === t4 ? u3 = this.__patterns.template_text : "}" === t4 && (u3 = this.__patterns.template_expression);
        for (var n3, u3, _2 = u3.read(), s2 = ""; this._input.hasNext(); ) {
          if ((s2 = this._input.next()) === t4 || !e3 && r.newline.test(s2)) {
            this._input.back();
            break;
          }
          "\\\\" === s2 && this._input.hasNext() ? ("x" === (n3 = this._input.peek()) || "u" === n3 ? this.has_char_escapes = true : "\\r" === n3 && "\\n" === this._input.peek(1) && this._input.next(), s2 += this._input.next()) : i2 && ("\${" === i2 && "\$" === s2 && "{" === this._input.peek() && (s2 += this._input.next()), i2 === s2 && (s2 += "\`" === t4 ? this._read_string_recursive("}", e3, "\`") : this._read_string_recursive("\`", e3, "\${"), this._input.hasNext() && (s2 += this._input.next()))), _2 += s2 += u3.read();
        }
        return _2;
      }, t3.exports.Tokenizer = p, t3.exports.TOKEN = f, t3.exports.positionable_operators = i.slice(), t3.exports.line_starters = s.slice();
    }, function(t3) {
      var n2 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t4) {
        this.__input = t4 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__input.charAt(this.__position), this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__input_length ? this.__input.charAt(t4) : e3;
      }, e2.prototype.__match = function(t4, e3) {
        t4.lastIndex = e3;
        var i = t4.exec(this.__input);
        return !i || n2 && t4.sticky || i.index !== e3 && (i = null), i;
      }, e2.prototype.test = function(t4, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t4, e3);
      }, e2.prototype.testChar = function(t4, e3) {
        e3 = this.peek(e3);
        return t4.lastIndex = 0, null !== e3 && t4.test(e3);
      }, e2.prototype.match = function(t4) {
        t4 = this.__match(t4, this.__position);
        return t4 ? this.__position += t4[0].length : t4 = null, t4;
      }, e2.prototype.read = function(t4, e3, i) {
        var n3, u2 = "";
        return t4 && (n3 = this.match(t4)) && (u2 += n3[0]), !e3 || !n3 && t4 || (u2 += this.readUntil(e3, i)), u2;
      }, e2.prototype.readUntil = function(t4, e3) {
        var i = this.__position, t4 = (t4.lastIndex = this.__position, t4.exec(this.__input));
        return t4 ? (i = t4.index, e3 && (i += t4[0].length)) : i = this.__input_length, e3 = this.__input.substring(this.__position, i), this.__position = i, e3;
      }, e2.prototype.readUntilAfter = function(t4) {
        return this.readUntil(t4, true);
      }, e2.prototype.get_regexp = function(t4, e3) {
        var i = null, e3 = e3 && n2 ? "y" : "g";
        return "string" == typeof t4 && "" !== t4 ? i = new RegExp(t4, e3) : t4 && (i = new RegExp(t4.source, e3)), i;
      }, e2.prototype.get_literal_regexp = function(t4) {
        return RegExp(t4.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t4) {
        var e3 = this.__position, t4 = this.readUntilAfter(t4);
        return this.__position = e3, t4;
      }, e2.prototype.lookBack = function(t4) {
        var e3 = this.__position - 1;
        return e3 >= t4.length && this.__input.substring(e3 - t4.length, e3).toLowerCase() === t4;
      }, t3.exports.InputScanner = e2;
    }, function(t3, e2, i) {
      function n2(t4, e3) {
        this._input = new u2(t4), this._options = e3 || {}, this.__tokens = null, this._patterns = {}, this._patterns.whitespace = new a(this._input);
      }
      var u2 = i(8).InputScanner, _ = i(3).Token, s = i(10).TokenStream, a = i(11).WhitespacePattern, o = { START: "TK_START", RAW: "TK_RAW", EOF: "TK_EOF" };
      n2.prototype.tokenize = function() {
        this._input.restart(), this.__tokens = new s(), this._reset();
        for (var t4, e3 = new _(o.START, ""), i2 = null, n3 = [], u3 = new s(); e3.type !== o.EOF; ) {
          for (t4 = this._get_next_token(e3, i2); this._is_comment(t4); ) u3.add(t4), t4 = this._get_next_token(e3, i2);
          u3.isEmpty() || (t4.comments_before = u3, u3 = new s()), t4.parent = i2, this._is_opening(t4) ? (n3.push(i2), i2 = t4) : i2 && this._is_closing(t4, i2) && ((t4.opened = i2).closed = t4, i2 = n3.pop(), t4.parent = i2), (t4.previous = e3).next = t4, this.__tokens.add(t4), e3 = t4;
        }
        return this.__tokens;
      }, n2.prototype._is_first_token = function() {
        return this.__tokens.isEmpty();
      }, n2.prototype._reset = function() {
      }, n2.prototype._get_next_token = function(t4, e3) {
        this._readWhitespace();
        var i2 = this._input.read(/.+/g);
        return i2 ? this._create_token(o.RAW, i2) : this._create_token(o.EOF, "");
      }, n2.prototype._is_comment = function(t4) {
        return false;
      }, n2.prototype._is_opening = function(t4) {
        return false;
      }, n2.prototype._is_closing = function(t4, e3) {
        return false;
      }, n2.prototype._create_token = function(t4, e3) {
        return new _(t4, e3, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
      }, n2.prototype._readWhitespace = function() {
        return this._patterns.whitespace.read();
      }, t3.exports.Tokenizer = n2, t3.exports.TOKEN = o;
    }, function(t3) {
      function e2(t4) {
        this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = t4;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.isEmpty = function() {
        return 0 === this.__tokens_length;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__tokens_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__tokens[this.__position], this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__tokens_length ? this.__tokens[t4] : e3;
      }, e2.prototype.add = function(t4) {
        this.__parent_token && (t4.parent = this.__parent_token), this.__tokens.push(t4), this.__tokens_length += 1;
      }, t3.exports.TokenStream = e2;
    }, function(t3, e2, i) {
      var n2 = i(12).Pattern;
      function u2(t4, e3) {
        n2.call(this, t4, e3), e3 ? this._line_regexp = this._input.get_regexp(e3._line_regexp) : this.__set_whitespace_patterns("", ""), this.newline_count = 0, this.whitespace_before_token = "";
      }
      (u2.prototype = new n2()).__set_whitespace_patterns = function(t4, e3) {
        this._match_pattern = this._input.get_regexp("[" + (t4 += "\\\\t ") + (e3 += "\\\\n\\\\r") + "]+", true), this._newline_regexp = this._input.get_regexp("\\\\r\\\\n|[" + e3 + "]");
      }, u2.prototype.read = function() {
        this.newline_count = 0, this.whitespace_before_token = "";
        var t4, e3 = this._input.read(this._match_pattern);
        return " " === e3 ? this.whitespace_before_token = " " : e3 && (t4 = this.__split(this._newline_regexp, e3), this.newline_count = t4.length - 1, this.whitespace_before_token = t4[this.newline_count]), e3;
      }, u2.prototype.matching = function(t4, e3) {
        var i2 = this._create();
        return i2.__set_whitespace_patterns(t4, e3), i2._update(), i2;
      }, u2.prototype._create = function() {
        return new u2(this._input, this);
      }, u2.prototype.__split = function(t4, e3) {
        for (var i2 = t4.lastIndex = 0, n3 = [], u3 = t4.exec(e3); u3; ) n3.push(e3.substring(i2, u3.index)), i2 = u3.index + u3[0].length, u3 = t4.exec(e3);
        return i2 < e3.length ? n3.push(e3.substring(i2, e3.length)) : n3.push(""), n3;
      }, t3.exports.WhitespacePattern = u2;
    }, function(t3) {
      function e2(t4, e3) {
        this._input = t4, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this._until_after = false, e3 && (this._starting_pattern = this._input.get_regexp(e3._starting_pattern, true), this._match_pattern = this._input.get_regexp(e3._match_pattern, true), this._until_pattern = this._input.get_regexp(e3._until_pattern), this._until_after = e3._until_after);
      }
      e2.prototype.read = function() {
        var t4 = this._input.read(this._starting_pattern);
        return this._starting_pattern && !t4 || (t4 += this._input.read(this._match_pattern, this._until_pattern, this._until_after)), t4;
      }, e2.prototype.read_match = function() {
        return this._input.match(this._match_pattern);
      }, e2.prototype.until_after = function(t4) {
        var e3 = this._create();
        return e3._until_after = true, e3._until_pattern = this._input.get_regexp(t4), e3._update(), e3;
      }, e2.prototype.until = function(t4) {
        var e3 = this._create();
        return e3._until_after = false, e3._until_pattern = this._input.get_regexp(t4), e3._update(), e3;
      }, e2.prototype.starting_with = function(t4) {
        var e3 = this._create();
        return e3._starting_pattern = this._input.get_regexp(t4, true), e3._update(), e3;
      }, e2.prototype.matching = function(t4) {
        var e3 = this._create();
        return e3._match_pattern = this._input.get_regexp(t4, true), e3._update(), e3;
      }, e2.prototype._create = function() {
        return new e2(this._input, this);
      }, e2.prototype._update = function() {
      }, t3.exports.Pattern = e2;
    }, function(t3) {
      function e2(t4, e3) {
        t4 = "string" == typeof t4 ? t4 : t4.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t4 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t4 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t4) {
        if (!t4.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, i = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t4)); i; ) e3[i[1]] = i[2], i = this.__directive_pattern.exec(t4);
        return e3;
      }, e2.prototype.readIgnored = function(t4) {
        return t4.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t3.exports.Directives = e2;
    }, function(t3, e2, i) {
      var n2 = i(12).Pattern, u2 = { django: false, erb: false, handlebars: false, php: false, smarty: false };
      function _(t4, e3) {
        n2.call(this, t4, e3), this.__template_pattern = null, this._disabled = Object.assign({}, u2), this._excluded = Object.assign({}, u2), e3 && (this.__template_pattern = this._input.get_regexp(e3.__template_pattern), this._excluded = Object.assign(this._excluded, e3._excluded), this._disabled = Object.assign(this._disabled, e3._disabled));
        e3 = new n2(t4);
        this.__patterns = { handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars_unescaped: e3.starting_with(/{{{/).until_after(/}}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), php: e3.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/), erb: e3.starting_with(/<%[^%]/).until_after(/[^%]%>/), django: e3.starting_with(/{%/).until_after(/%}/), django_value: e3.starting_with(/{{/).until_after(/}}/), django_comment: e3.starting_with(/{#/).until_after(/#}/), smarty: e3.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/), smarty_comment: e3.starting_with(/{\\*/).until_after(/\\*}/), smarty_literal: e3.starting_with(/{literal}/).until_after(/{\\/literal}/) };
      }
      (_.prototype = new n2())._create = function() {
        return new _(this._input, this);
      }, _.prototype._update = function() {
        this.__set_templated_pattern();
      }, _.prototype.disable = function(t4) {
        var e3 = this._create();
        return e3._disabled[t4] = true, e3._update(), e3;
      }, _.prototype.read_options = function(t4) {
        var e3, i2 = this._create();
        for (e3 in u2) i2._disabled[e3] = -1 === t4.templating.indexOf(e3);
        return i2._update(), i2;
      }, _.prototype.exclude = function(t4) {
        var e3 = this._create();
        return e3._excluded[t4] = true, e3._update(), e3;
      }, _.prototype.read = function() {
        for (var t4 = "", t4 = this._match_pattern ? this._input.read(this._starting_pattern) : this._input.read(this._starting_pattern, this.__template_pattern), e3 = this._read_template(); e3; ) this._match_pattern ? e3 += this._input.read(this._match_pattern) : e3 += this._input.readUntil(this.__template_pattern), t4 += e3, e3 = this._read_template();
        return this._until_after && (t4 += this._input.readUntilAfter(this._until_pattern)), t4;
      }, _.prototype.__set_templated_pattern = function() {
        var t4 = [];
        this._disabled.php || t4.push(this.__patterns.php._starting_pattern.source), this._disabled.handlebars || t4.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.erb || t4.push(this.__patterns.erb._starting_pattern.source), this._disabled.django || (t4.push(this.__patterns.django._starting_pattern.source), t4.push(this.__patterns.django_value._starting_pattern.source), t4.push(this.__patterns.django_comment._starting_pattern.source)), this._disabled.smarty || t4.push(this.__patterns.smarty._starting_pattern.source), this._until_pattern && t4.push(this._until_pattern.source), this.__template_pattern = this._input.get_regexp("(?:" + t4.join("|") + ")");
      }, _.prototype._read_template = function() {
        var t4, e3 = "", i2 = this._input.peek();
        return "<" === i2 ? (t4 = this._input.peek(1), this._disabled.php || this._excluded.php || "?" !== t4 || (e3 = e3 || this.__patterns.php.read()), this._disabled.erb || this._excluded.erb || "%" !== t4 || (e3 = e3 || this.__patterns.erb.read())) : "{" === i2 && (this._disabled.handlebars || this._excluded.handlebars || (e3 = (e3 = (e3 = e3 || this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars_unescaped.read()) || this.__patterns.handlebars.read()), this._disabled.django || (this._excluded.django || this._excluded.handlebars || (e3 = e3 || this.__patterns.django_value.read()), this._excluded.django || (e3 = (e3 = e3 || this.__patterns.django_comment.read()) || this.__patterns.django.read())), this._disabled.smarty || this._disabled.django && this._disabled.handlebars && (e3 = (e3 = (e3 = e3 || this.__patterns.smarty_comment.read()) || this.__patterns.smarty_literal.read()) || this.__patterns.smarty.read())), e3;
      }, t3.exports.TemplatablePattern = _;
    }], u = {};
    var t2 = function t3(e2) {
      var i = u[e2];
      if (void 0 !== i) return i.exports;
      i = u[e2] = { exports: {} };
      return n[e2](i, i.exports, t3), i.exports;
    }(0);
    e = t2;
  }();
  var e, t = e;
  "function" == typeof define && define.amd ? define([], function() {
    return { js_beautify: t };
  }) : "undefined" != typeof exports ? exports.js_beautify = t : "undefined" != typeof window ? window.js_beautify = t : "undefined" != typeof global && (global.js_beautify = t);
}();
!function() {
  !function() {
    var i2 = [, , function(t2) {
      function _3(t3) {
        this.__parent = t3, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function n2(t3, e3) {
        this.__cache = [""], this.__indent_size = t3.indent_size, this.__indent_string = t3.indent_char, t3.indent_with_tabs || (this.__indent_string = new Array(t3.indent_size + 1).join(t3.indent_char)), e3 = e3 || "", 0 < t3.indent_level && (e3 = new Array(t3.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t3, e3) {
        this.__indent_cache = new n2(t3, e3), this.raw = false, this._end_with_newline = t3.end_with_newline, this.indent_size = t3.indent_size, this.wrap_line_length = t3.wrap_line_length, this.indent_empty_lines = t3.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new _3(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      _3.prototype.clone_empty = function() {
        var t3 = new _3(this.__parent);
        return t3.set_indent(this.__indent_count, this.__alignment_count), t3;
      }, _3.prototype.item = function(t3) {
        return t3 < 0 ? this.__items[this.__items.length + t3] : this.__items[t3];
      }, _3.prototype.has_match = function(t3) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t3)) return true;
        return false;
      }, _3.prototype.set_indent = function(t3, e3) {
        this.is_empty() && (this.__indent_count = t3 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, _3.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, _3.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, _3.prototype._allow_wrap = function() {
        var t3;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t3 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t3.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t3.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t3.__items[0] && (t3.__items.splice(0, 1), --t3.__character_count), true);
      }, _3.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, _3.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, _3.prototype.push = function(t3) {
        this.__items.push(t3);
        var e3 = t3.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t3.length - e3 : this.__character_count += t3.length;
      }, _3.prototype.pop = function() {
        var t3 = null;
        return this.is_empty() || (t3 = this.__items.pop(), this.__character_count -= t3.length), t3;
      }, _3.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, _3.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, _3.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, _3.prototype.toString = function() {
        var t3 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t3 = this.__parent.get_indent_string(this.__indent_count)) : (t3 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t3 += this.__items.join("")), t3;
      }, n2.prototype.get_indent_size = function(t3, e3) {
        var n3 = this.__base_string_length;
        return n3 = (n3 = t3 < 0 ? 0 : n3) + t3 * this.__indent_size + (e3 = e3 || 0);
      }, n2.prototype.get_indent_string = function(t3, e3) {
        var n3 = this.__base_string;
        return e3 = e3 || 0, t3 < 0 && (t3 = 0, n3 = ""), e3 += t3 * this.__indent_size, this.__ensure_cache(e3), n3 += this.__cache[e3];
      }, n2.prototype.__ensure_cache = function(t3) {
        for (; t3 >= this.__cache.length; ) this.__add_column();
      }, n2.prototype.__add_column = function() {
        var t3, e3 = this.__cache.length, n3 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t3 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, n3 = new Array(t3 + 1).join(this.__indent_string)), e3 && (n3 += new Array(e3 + 1).join(" ")), this.__cache.push(n3);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t3, e3) {
        return this.__indent_cache.get_indent_string(t3, e3);
      }, e2.prototype.get_indent_size = function(t3, e3) {
        return this.__indent_cache.get_indent_size(t3, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t3) {
        return !(this.is_empty() || !t3 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t3) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t3 ? e3.replace(/[\\n]/g, t3) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t3, e3) {
        return this.next_line.set_indent(t3 = t3 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t3, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t3) {
        for (var e3 = 0; e3 < t3.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t3.whitespace_before), this.current_line.push(t3.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t3) {
        this.__add_space_before_token(), this.current_line.push(t3), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t3) {
        for (var e3 = this.__lines.length; t3 < e3; ) this.__lines[t3]._remove_indent(), t3++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t3) {
        for (t3 = void 0 !== t3 && t3, this.current_line.trim(); t3 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t3, e3) {
        for (var n3 = this.__lines.length - 2; 0 <= n3; ) {
          var i3 = this.__lines[n3];
          if (i3.is_empty()) break;
          if (0 !== i3.item(0).indexOf(t3) && i3.item(-1) !== e3) {
            this.__lines.splice(n3 + 1, 0, new _3(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          n3--;
        }
      }, t2.exports.Output = e2;
    }, function(t2) {
      t2.exports.Token = function(t3, e2, n2, i3) {
        this.type = t3, this.text = e2, this.comments_before = null, this.newlines = n2 || 0, this.whitespace_before = i3 || "", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this.directives = null;
      };
    }, , , function(t2) {
      function e2(t3, e3) {
        this.raw_options = n2(t3, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function n2(t3, e3) {
        var n3, i3 = {};
        for (n3 in t3 = _3(t3)) n3 !== e3 && (i3[n3] = t3[n3]);
        if (e3 && t3[e3]) for (n3 in t3[e3]) i3[n3] = t3[e3][n3];
        return i3;
      }
      function _3(t3) {
        var e3, n3 = {};
        for (e3 in t3) n3[e3.replace(/-/g, "_")] = t3[e3];
        return n3;
      }
      e2.prototype._get_array = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = e3 || [];
        return "object" == typeof t3 ? null !== t3 && "function" == typeof t3.concat && (e3 = t3.concat()) : "string" == typeof t3 && (e3 = t3.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t3, e3) {
        t3 = this.raw_options[t3];
        return void 0 === t3 ? !!e3 : !!t3;
      }, e2.prototype._get_characters = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = e3 || "";
        return e3 = "string" == typeof t3 ? t3.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t3 = parseInt(t3, 10);
        return t3 = isNaN(t3) ? e3 : t3;
      }, e2.prototype._get_selection = function(t3, e3, n3) {
        n3 = this._get_selection_list(t3, e3, n3);
        if (1 !== n3.length) throw new Error("Invalid Option Value: The option '" + t3 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t3] + "'");
        return n3[0];
      }, e2.prototype._get_selection_list = function(t3, e3, n3) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (n3 = n3 || [e3[0]], !this._is_valid_selection(n3, e3)) throw new Error("Invalid Default Value!");
        n3 = this._get_array(t3, n3);
        if (this._is_valid_selection(n3, e3)) return n3;
        throw new Error("Invalid Option Value: The option '" + t3 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t3] + "'");
      }, e2.prototype._is_valid_selection = function(t3, e3) {
        return t3.length && e3.length && !t3.some(function(t4) {
          return -1 === e3.indexOf(t4);
        });
      }, t2.exports.Options = e2, t2.exports.normalizeOpts = _3, t2.exports.mergeOpts = n2;
    }, , function(t2) {
      var i3 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t3) {
        this.__input = t3 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t3 = null;
        return this.hasNext() && (t3 = this.__input.charAt(this.__position), this.__position += 1), t3;
      }, e2.prototype.peek = function(t3) {
        var e3 = null;
        return t3 = t3 || 0, e3 = 0 <= (t3 += this.__position) && t3 < this.__input_length ? this.__input.charAt(t3) : e3;
      }, e2.prototype.__match = function(t3, e3) {
        t3.lastIndex = e3;
        var n2 = t3.exec(this.__input);
        return !n2 || i3 && t3.sticky || n2.index !== e3 && (n2 = null), n2;
      }, e2.prototype.test = function(t3, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t3, e3);
      }, e2.prototype.testChar = function(t3, e3) {
        e3 = this.peek(e3);
        return t3.lastIndex = 0, null !== e3 && t3.test(e3);
      }, e2.prototype.match = function(t3) {
        t3 = this.__match(t3, this.__position);
        return t3 ? this.__position += t3[0].length : t3 = null, t3;
      }, e2.prototype.read = function(t3, e3, n2) {
        var i4, _3 = "";
        return t3 && (i4 = this.match(t3)) && (_3 += i4[0]), !e3 || !i4 && t3 || (_3 += this.readUntil(e3, n2)), _3;
      }, e2.prototype.readUntil = function(t3, e3) {
        var n2 = this.__position, t3 = (t3.lastIndex = this.__position, t3.exec(this.__input));
        return t3 ? (n2 = t3.index, e3 && (n2 += t3[0].length)) : n2 = this.__input_length, e3 = this.__input.substring(this.__position, n2), this.__position = n2, e3;
      }, e2.prototype.readUntilAfter = function(t3) {
        return this.readUntil(t3, true);
      }, e2.prototype.get_regexp = function(t3, e3) {
        var n2 = null, e3 = e3 && i3 ? "y" : "g";
        return "string" == typeof t3 && "" !== t3 ? n2 = new RegExp(t3, e3) : t3 && (n2 = new RegExp(t3.source, e3)), n2;
      }, e2.prototype.get_literal_regexp = function(t3) {
        return RegExp(t3.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t3) {
        var e3 = this.__position, t3 = this.readUntilAfter(t3);
        return this.__position = e3, t3;
      }, e2.prototype.lookBack = function(t3) {
        var e3 = this.__position - 1;
        return e3 >= t3.length && this.__input.substring(e3 - t3.length, e3).toLowerCase() === t3;
      }, t2.exports.InputScanner = e2;
    }, function(t2, e2, n2) {
      function i3(t3, e3) {
        this._input = new _3(t3), this._options = e3 || {}, this.__tokens = null, this._patterns = {}, this._patterns.whitespace = new a(this._input);
      }
      var _3 = n2(8).InputScanner, s = n2(3).Token, r = n2(10).TokenStream, a = n2(11).WhitespacePattern, o = { START: "TK_START", RAW: "TK_RAW", EOF: "TK_EOF" };
      i3.prototype.tokenize = function() {
        this._input.restart(), this.__tokens = new r(), this._reset();
        for (var t3, e3 = new s(o.START, ""), n3 = null, i4 = [], _4 = new r(); e3.type !== o.EOF; ) {
          for (t3 = this._get_next_token(e3, n3); this._is_comment(t3); ) _4.add(t3), t3 = this._get_next_token(e3, n3);
          _4.isEmpty() || (t3.comments_before = _4, _4 = new r()), t3.parent = n3, this._is_opening(t3) ? (i4.push(n3), n3 = t3) : n3 && this._is_closing(t3, n3) && ((t3.opened = n3).closed = t3, n3 = i4.pop(), t3.parent = n3), (t3.previous = e3).next = t3, this.__tokens.add(t3), e3 = t3;
        }
        return this.__tokens;
      }, i3.prototype._is_first_token = function() {
        return this.__tokens.isEmpty();
      }, i3.prototype._reset = function() {
      }, i3.prototype._get_next_token = function(t3, e3) {
        this._readWhitespace();
        var n3 = this._input.read(/.+/g);
        return n3 ? this._create_token(o.RAW, n3) : this._create_token(o.EOF, "");
      }, i3.prototype._is_comment = function(t3) {
        return false;
      }, i3.prototype._is_opening = function(t3) {
        return false;
      }, i3.prototype._is_closing = function(t3, e3) {
        return false;
      }, i3.prototype._create_token = function(t3, e3) {
        return new s(t3, e3, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
      }, i3.prototype._readWhitespace = function() {
        return this._patterns.whitespace.read();
      }, t2.exports.Tokenizer = i3, t2.exports.TOKEN = o;
    }, function(t2) {
      function e2(t3) {
        this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = t3;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.isEmpty = function() {
        return 0 === this.__tokens_length;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__tokens_length;
      }, e2.prototype.next = function() {
        var t3 = null;
        return this.hasNext() && (t3 = this.__tokens[this.__position], this.__position += 1), t3;
      }, e2.prototype.peek = function(t3) {
        var e3 = null;
        return t3 = t3 || 0, e3 = 0 <= (t3 += this.__position) && t3 < this.__tokens_length ? this.__tokens[t3] : e3;
      }, e2.prototype.add = function(t3) {
        this.__parent_token && (t3.parent = this.__parent_token), this.__tokens.push(t3), this.__tokens_length += 1;
      }, t2.exports.TokenStream = e2;
    }, function(t2, e2, n2) {
      var i3 = n2(12).Pattern;
      function _3(t3, e3) {
        i3.call(this, t3, e3), e3 ? this._line_regexp = this._input.get_regexp(e3._line_regexp) : this.__set_whitespace_patterns("", ""), this.newline_count = 0, this.whitespace_before_token = "";
      }
      (_3.prototype = new i3()).__set_whitespace_patterns = function(t3, e3) {
        this._match_pattern = this._input.get_regexp("[" + (t3 += "\\\\t ") + (e3 += "\\\\n\\\\r") + "]+", true), this._newline_regexp = this._input.get_regexp("\\\\r\\\\n|[" + e3 + "]");
      }, _3.prototype.read = function() {
        this.newline_count = 0, this.whitespace_before_token = "";
        var t3, e3 = this._input.read(this._match_pattern);
        return " " === e3 ? this.whitespace_before_token = " " : e3 && (t3 = this.__split(this._newline_regexp, e3), this.newline_count = t3.length - 1, this.whitespace_before_token = t3[this.newline_count]), e3;
      }, _3.prototype.matching = function(t3, e3) {
        var n3 = this._create();
        return n3.__set_whitespace_patterns(t3, e3), n3._update(), n3;
      }, _3.prototype._create = function() {
        return new _3(this._input, this);
      }, _3.prototype.__split = function(t3, e3) {
        for (var n3 = t3.lastIndex = 0, i4 = [], _4 = t3.exec(e3); _4; ) i4.push(e3.substring(n3, _4.index)), n3 = _4.index + _4[0].length, _4 = t3.exec(e3);
        return n3 < e3.length ? i4.push(e3.substring(n3, e3.length)) : i4.push(""), i4;
      }, t2.exports.WhitespacePattern = _3;
    }, function(t2) {
      function e2(t3, e3) {
        this._input = t3, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this._until_after = false, e3 && (this._starting_pattern = this._input.get_regexp(e3._starting_pattern, true), this._match_pattern = this._input.get_regexp(e3._match_pattern, true), this._until_pattern = this._input.get_regexp(e3._until_pattern), this._until_after = e3._until_after);
      }
      e2.prototype.read = function() {
        var t3 = this._input.read(this._starting_pattern);
        return this._starting_pattern && !t3 || (t3 += this._input.read(this._match_pattern, this._until_pattern, this._until_after)), t3;
      }, e2.prototype.read_match = function() {
        return this._input.match(this._match_pattern);
      }, e2.prototype.until_after = function(t3) {
        var e3 = this._create();
        return e3._until_after = true, e3._until_pattern = this._input.get_regexp(t3), e3._update(), e3;
      }, e2.prototype.until = function(t3) {
        var e3 = this._create();
        return e3._until_after = false, e3._until_pattern = this._input.get_regexp(t3), e3._update(), e3;
      }, e2.prototype.starting_with = function(t3) {
        var e3 = this._create();
        return e3._starting_pattern = this._input.get_regexp(t3, true), e3._update(), e3;
      }, e2.prototype.matching = function(t3) {
        var e3 = this._create();
        return e3._match_pattern = this._input.get_regexp(t3, true), e3._update(), e3;
      }, e2.prototype._create = function() {
        return new e2(this._input, this);
      }, e2.prototype._update = function() {
      }, t2.exports.Pattern = e2;
    }, function(t2) {
      function e2(t3, e3) {
        t3 = "string" == typeof t3 ? t3 : t3.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t3 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t3 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t3) {
        if (!t3.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, n2 = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t3)); n2; ) e3[n2[1]] = n2[2], n2 = this.__directive_pattern.exec(t3);
        return e3;
      }, e2.prototype.readIgnored = function(t3) {
        return t3.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t2.exports.Directives = e2;
    }, function(t2, e2, n2) {
      var i3 = n2(12).Pattern, _3 = { django: false, erb: false, handlebars: false, php: false, smarty: false };
      function s(t3, e3) {
        i3.call(this, t3, e3), this.__template_pattern = null, this._disabled = Object.assign({}, _3), this._excluded = Object.assign({}, _3), e3 && (this.__template_pattern = this._input.get_regexp(e3.__template_pattern), this._excluded = Object.assign(this._excluded, e3._excluded), this._disabled = Object.assign(this._disabled, e3._disabled));
        e3 = new i3(t3);
        this.__patterns = { handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars_unescaped: e3.starting_with(/{{{/).until_after(/}}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), php: e3.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/), erb: e3.starting_with(/<%[^%]/).until_after(/[^%]%>/), django: e3.starting_with(/{%/).until_after(/%}/), django_value: e3.starting_with(/{{/).until_after(/}}/), django_comment: e3.starting_with(/{#/).until_after(/#}/), smarty: e3.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/), smarty_comment: e3.starting_with(/{\\*/).until_after(/\\*}/), smarty_literal: e3.starting_with(/{literal}/).until_after(/{\\/literal}/) };
      }
      (s.prototype = new i3())._create = function() {
        return new s(this._input, this);
      }, s.prototype._update = function() {
        this.__set_templated_pattern();
      }, s.prototype.disable = function(t3) {
        var e3 = this._create();
        return e3._disabled[t3] = true, e3._update(), e3;
      }, s.prototype.read_options = function(t3) {
        var e3, n3 = this._create();
        for (e3 in _3) n3._disabled[e3] = -1 === t3.templating.indexOf(e3);
        return n3._update(), n3;
      }, s.prototype.exclude = function(t3) {
        var e3 = this._create();
        return e3._excluded[t3] = true, e3._update(), e3;
      }, s.prototype.read = function() {
        for (var t3 = "", t3 = this._match_pattern ? this._input.read(this._starting_pattern) : this._input.read(this._starting_pattern, this.__template_pattern), e3 = this._read_template(); e3; ) this._match_pattern ? e3 += this._input.read(this._match_pattern) : e3 += this._input.readUntil(this.__template_pattern), t3 += e3, e3 = this._read_template();
        return this._until_after && (t3 += this._input.readUntilAfter(this._until_pattern)), t3;
      }, s.prototype.__set_templated_pattern = function() {
        var t3 = [];
        this._disabled.php || t3.push(this.__patterns.php._starting_pattern.source), this._disabled.handlebars || t3.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.erb || t3.push(this.__patterns.erb._starting_pattern.source), this._disabled.django || (t3.push(this.__patterns.django._starting_pattern.source), t3.push(this.__patterns.django_value._starting_pattern.source), t3.push(this.__patterns.django_comment._starting_pattern.source)), this._disabled.smarty || t3.push(this.__patterns.smarty._starting_pattern.source), this._until_pattern && t3.push(this._until_pattern.source), this.__template_pattern = this._input.get_regexp("(?:" + t3.join("|") + ")");
      }, s.prototype._read_template = function() {
        var t3, e3 = "", n3 = this._input.peek();
        return "<" === n3 ? (t3 = this._input.peek(1), this._disabled.php || this._excluded.php || "?" !== t3 || (e3 = e3 || this.__patterns.php.read()), this._disabled.erb || this._excluded.erb || "%" !== t3 || (e3 = e3 || this.__patterns.erb.read())) : "{" === n3 && (this._disabled.handlebars || this._excluded.handlebars || (e3 = (e3 = (e3 = e3 || this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars_unescaped.read()) || this.__patterns.handlebars.read()), this._disabled.django || (this._excluded.django || this._excluded.handlebars || (e3 = e3 || this.__patterns.django_value.read()), this._excluded.django || (e3 = (e3 = e3 || this.__patterns.django_comment.read()) || this.__patterns.django.read())), this._disabled.smarty || this._disabled.django && this._disabled.handlebars && (e3 = (e3 = (e3 = e3 || this.__patterns.smarty_comment.read()) || this.__patterns.smarty_literal.read()) || this.__patterns.smarty.read())), e3;
      }, t2.exports.TemplatablePattern = s;
    }, , , , function(t2, e2, n2) {
      var _3 = n2(19).Beautifier, i3 = n2(20).Options;
      t2.exports = function(t3, e3, n3, i4) {
        return new _3(t3, e3, n3, i4).beautify();
      }, t2.exports.defaultOptions = function() {
        return new i3();
      };
    }, function(t2, e2, n2) {
      function p(t3, e3) {
        this.indent_level = 0, this.alignment_size = 0, this.max_preserve_newlines = t3.max_preserve_newlines, this.preserve_newlines = t3.preserve_newlines, this._output = new i3(t3, e3);
      }
      function s(t3, e3) {
        var n3 = null, i4 = null;
        return e3.closed ? ("script" === t3 ? n3 = "text/javascript" : "style" === t3 && (n3 = "text/css"), -1 < (n3 = function(t4) {
          for (var e4 = null, n4 = t4.next; n4.type !== u.EOF && t4.closed !== n4; ) {
            if (n4.type === u.ATTRIBUTE && "type" === n4.text) {
              n4.next && n4.next.type === u.EQUALS && n4.next.next && n4.next.next.type === u.VALUE && (e4 = n4.next.next.text);
              break;
            }
            n4 = n4.next;
          }
          return e4;
        }(e3) || n3).search("text/css") ? i4 = "css" : -1 < n3.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) ? i4 = "javascript" : -1 < n3.search(/(text|application|dojo)\\/(x-)?(html)/) ? i4 = "html" : -1 < n3.search(/test\\/null/) && (i4 = "null"), i4) : null;
      }
      var _3 = n2(20).Options, i3 = n2(2).Output, h = n2(21).Tokenizer, u = n2(21).TOKEN, l = /\\r\\n|[\\r\\n]/, c = /\\r\\n|[\\r\\n]/g;
      p.prototype.current_line_has_match = function(t3) {
        return this._output.current_line.has_match(t3);
      }, p.prototype.set_space_before_token = function(t3, e3) {
        this._output.space_before_token = t3, this._output.non_breaking_space = e3;
      }, p.prototype.set_wrap_point = function() {
        this._output.set_indent(this.indent_level, this.alignment_size), this._output.set_wrap_point();
      }, p.prototype.add_raw_token = function(t3) {
        this._output.add_raw_token(t3);
      }, p.prototype.print_preserved_newlines = function(t3) {
        var e3 = 0;
        t3.type !== u.TEXT && t3.previous.type !== u.TEXT && (e3 = t3.newlines ? 1 : 0), this.preserve_newlines && (e3 = t3.newlines < this.max_preserve_newlines + 1 ? t3.newlines : this.max_preserve_newlines + 1);
        for (var n3 = 0; n3 < e3; n3++) this.print_newline(0 < n3);
        return 0 !== e3;
      }, p.prototype.traverse_whitespace = function(t3) {
        return !(!t3.whitespace_before && !t3.newlines) && (this.print_preserved_newlines(t3) || (this._output.space_before_token = true), true);
      }, p.prototype.previous_token_wrapped = function() {
        return this._output.previous_token_wrapped;
      }, p.prototype.print_newline = function(t3) {
        this._output.add_new_line(t3);
      }, p.prototype.print_token = function(t3) {
        t3.text && (this._output.set_indent(this.indent_level, this.alignment_size), this._output.add_token(t3.text));
      }, p.prototype.indent = function() {
        this.indent_level++;
      }, p.prototype.get_full_indent = function(t3) {
        return (t3 = this.indent_level + (t3 || 0)) < 1 ? "" : this._output.get_indent_string(t3);
      };
      function r(t3, e3) {
        return -1 !== e3.indexOf(t3);
      }
      function a(t3, e3, n3) {
        this.parent = t3 || null, this.tag = e3 ? e3.tag_name : "", this.indent_level = n3 || 0, this.parser_token = e3 || null;
      }
      function d(t3) {
        this._printer = t3, this._current_frame = null;
      }
      function g(t3, e3, n3, i4) {
        this._source_text = t3 || "", e3 = e3 || {}, this._js_beautify = n3, this._css_beautify = i4, this._tag_stack = null;
        t3 = new _3(e3, "html");
        this._options = t3, this._is_wrap_attributes_force = "force" === this._options.wrap_attributes.substr(0, "force".length), this._is_wrap_attributes_force_expand_multiline = "force-expand-multiline" === this._options.wrap_attributes, this._is_wrap_attributes_force_aligned = "force-aligned" === this._options.wrap_attributes, this._is_wrap_attributes_aligned_multiple = "aligned-multiple" === this._options.wrap_attributes, this._is_wrap_attributes_preserve = "preserve" === this._options.wrap_attributes.substr(0, "preserve".length), this._is_wrap_attributes_preserve_aligned = "preserve-aligned" === this._options.wrap_attributes;
      }
      d.prototype.get_parser_token = function() {
        return this._current_frame ? this._current_frame.parser_token : null;
      }, d.prototype.record_tag = function(t3) {
        t3 = new a(this._current_frame, t3, this._printer.indent_level);
        this._current_frame = t3;
      }, d.prototype._try_pop_frame = function(t3) {
        var e3 = null;
        return t3 && (e3 = t3.parser_token, this._printer.indent_level = t3.indent_level, this._current_frame = t3.parent), e3;
      }, d.prototype._get_frame = function(t3, e3) {
        for (var n3 = this._current_frame; n3 && -1 === t3.indexOf(n3.tag); ) {
          if (e3 && -1 !== e3.indexOf(n3.tag)) {
            n3 = null;
            break;
          }
          n3 = n3.parent;
        }
        return n3;
      }, d.prototype.try_pop = function(t3, e3) {
        t3 = this._get_frame([t3], e3);
        return this._try_pop_frame(t3);
      }, d.prototype.indent_to_tag = function(t3) {
        t3 = this._get_frame(t3);
        t3 && (this._printer.indent_level = t3.indent_level);
      }, g.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t3 = this._source_text, e3 = this._options.eol, n3 = ("auto" === this._options.eol && (e3 = "\\n", t3 && l.test(t3) && (e3 = t3.match(l)[0])), (t3 = t3.replace(c, "\\n")).match(/^[\\t ]*/)[0]), i4 = { text: "", type: "" }, _4 = new f(), s2 = new p(this._options, n3), r2 = new h(t3, this._options).tokenize(), a2 = (this._tag_stack = new d(s2), null), o2 = r2.next(); o2.type !== u.EOF; ) o2.type === u.TAG_OPEN || o2.type === u.COMMENT ? _4 = a2 = this._handle_tag_open(s2, o2, _4, i4, r2) : o2.type === u.ATTRIBUTE || o2.type === u.EQUALS || o2.type === u.VALUE || o2.type === u.TEXT && !_4.tag_complete ? a2 = this._handle_inside_tag(s2, o2, _4, i4) : o2.type === u.TAG_CLOSE ? a2 = this._handle_tag_close(s2, o2, _4) : o2.type === u.TEXT ? a2 = this._handle_text(s2, o2, _4) : s2.add_raw_token(o2), i4 = a2, o2 = r2.next();
        return s2._output.get_code(e3);
      }, g.prototype._handle_tag_close = function(t3, e3, n3) {
        var i4 = { text: e3.text, type: e3.type };
        return t3.alignment_size = 0, n3.tag_complete = true, t3.set_space_before_token(e3.newlines || "" !== e3.whitespace_before, true), n3.is_unformatted ? t3.add_raw_token(e3) : ("<" === n3.tag_start_char && (t3.set_space_before_token("/" === e3.text[0], true), this._is_wrap_attributes_force_expand_multiline && n3.has_wrapped_attrs && t3.print_newline(false)), t3.print_token(e3)), !n3.indent_content || n3.is_unformatted || n3.is_content_unformatted || (t3.indent(), n3.indent_content = false), n3.is_inline_element || n3.is_unformatted || n3.is_content_unformatted || t3.set_wrap_point(), i4;
      }, g.prototype._handle_inside_tag = function(t3, e3, n3, i4) {
        var _4 = n3.has_wrapped_attrs, s2 = { text: e3.text, type: e3.type };
        return t3.set_space_before_token(e3.newlines || "" !== e3.whitespace_before, true), n3.is_unformatted ? t3.add_raw_token(e3) : "{" === n3.tag_start_char && e3.type === u.TEXT ? t3.print_preserved_newlines(e3) ? (e3.newlines = 0, t3.add_raw_token(e3)) : t3.print_token(e3) : (e3.type === u.ATTRIBUTE ? t3.set_space_before_token(true) : (e3.type === u.EQUALS || e3.type === u.VALUE && e3.previous.type === u.EQUALS) && t3.set_space_before_token(false), e3.type === u.ATTRIBUTE && "<" === n3.tag_start_char && ((this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) && (t3.traverse_whitespace(e3), _4 = _4 || 0 !== e3.newlines), this._is_wrap_attributes_force && n3.attr_count >= this._options.wrap_attributes_min_attrs && (i4.type !== u.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline) && (t3.print_newline(false), _4 = true)), t3.print_token(e3), _4 = _4 || t3.previous_token_wrapped(), n3.has_wrapped_attrs = _4), s2;
      }, g.prototype._handle_text = function(t3, e3, n3) {
        var i4 = { text: e3.text, type: "TK_CONTENT" };
        return n3.custom_beautifier_name ? this._print_custom_beatifier_text(t3, e3, n3) : n3.is_unformatted || n3.is_content_unformatted ? t3.add_raw_token(e3) : (t3.traverse_whitespace(e3), t3.print_token(e3)), i4;
      }, g.prototype._print_custom_beatifier_text = function(t3, e3, n3) {
        var i4 = this;
        if ("" !== e3.text) {
          var _4, s2 = e3.text, r2 = 1, a2 = "", o2 = "", r2 = ("javascript" === n3.custom_beautifier_name && "function" == typeof this._js_beautify ? _4 = this._js_beautify : "css" === n3.custom_beautifier_name && "function" == typeof this._css_beautify ? _4 = this._css_beautify : "html" === n3.custom_beautifier_name && (_4 = function(t4, e4) {
            return new g(t4, e4, i4._js_beautify, i4._css_beautify).beautify();
          }), "keep" === this._options.indent_scripts ? r2 = 0 : "separate" === this._options.indent_scripts && (r2 = -t3.indent_level), t3.get_full_indent(r2));
          if (s2 = s2.replace(/\\n[ \\t]*\$/, ""), "html" !== n3.custom_beautifier_name && "<" === s2[0] && s2.match(/^(<!--|<!\\[CDATA\\[)/)) {
            var n3 = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)\$/.exec(s2);
            if (!n3) return void t3.add_raw_token(e3);
            a2 = r2 + n3[1] + "\\n", s2 = n3[4], n3[5] && (o2 = r2 + n3[5]), s2 = s2.replace(/\\n[ \\t]*\$/, ""), (n3[2] || -1 !== n3[3].indexOf("\\n")) && (n3 = n3[3].match(/[ \\t]+\$/)) && (e3.whitespace_before = n3[0]);
          }
          s2 = s2 && (_4 ? ((n3 = function() {
            this.eol = "\\n";
          }).prototype = this._options.raw_options, _4(r2 + s2, new n3())) : r2 + (s2 = (_4 = e3.whitespace_before) ? s2.replace(new RegExp("\\n(" + _4 + ")?", "g"), "\\n") : s2).replace(/\\n/g, "\\n" + r2)), a2 && (s2 = s2 ? a2 + s2 + "\\n" + o2 : a2 + o2), t3.print_newline(false), s2 && (e3.text = s2, e3.whitespace_before = "", e3.newlines = 0, t3.add_raw_token(e3), t3.print_newline(true));
        }
      }, g.prototype._handle_tag_open = function(t3, e3, n3, i4, _4) {
        var s2 = this._get_tag_open_token(e3);
        if (!n3.is_unformatted && !n3.is_content_unformatted || n3.is_empty_element || e3.type !== u.TAG_OPEN || s2.is_start_tag ? (t3.traverse_whitespace(e3), this._set_tag_position(t3, e3, s2, n3, i4), s2.is_inline_element || t3.set_wrap_point(), t3.print_token(e3)) : (t3.add_raw_token(e3), s2.start_tag_token = this._tag_stack.try_pop(s2.tag_name)), s2.is_start_tag && this._is_wrap_attributes_force) for (var r2, a2 = 0; (r2 = _4.peek(a2)).type === u.ATTRIBUTE && (s2.attr_count += 1), a2 += 1, r2.type !== u.EOF && r2.type !== u.TAG_CLOSE; ) ;
        return (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) && (s2.alignment_size = e3.text.length + 1), s2.tag_complete || s2.is_unformatted || (t3.alignment_size = s2.alignment_size), s2;
      };
      var f = function(t3, e3) {
        var n3;
        this.parent = t3 || null, this.text = "", this.type = "TK_TAG_OPEN", this.tag_name = "", this.is_inline_element = false, this.is_unformatted = false, this.is_content_unformatted = false, this.is_empty_element = false, this.is_start_tag = false, this.is_end_tag = false, this.indent_content = false, this.multiline_content = false, this.custom_beautifier_name = null, this.start_tag_token = null, this.attr_count = 0, this.has_wrapped_attrs = false, this.alignment_size = 0, this.tag_complete = false, this.tag_start_char = "", this.tag_check = "", e3 ? (this.tag_start_char = e3.text[0], this.text = e3.text, "<" === this.tag_start_char ? (n3 = e3.text.match(/^<([^\\s>]*)/), this.tag_check = n3 ? n3[1] : "") : (n3 = e3.text.match(/^{{~?(?:[\\^]|#\\*?)?([^\\s}]+)/), this.tag_check = n3 ? n3[1] : "", (e3.text.startsWith("{{#>") || e3.text.startsWith("{{~#>")) && ">" === this.tag_check[0] && (">" === this.tag_check && null !== e3.next ? this.tag_check = e3.next.text.split(" ")[0] : this.tag_check = e3.text.split(">")[1])), this.tag_check = this.tag_check.toLowerCase(), e3.type === u.COMMENT && (this.tag_complete = true), this.is_start_tag = "/" !== this.tag_check.charAt(0), this.tag_name = this.is_start_tag ? this.tag_check : this.tag_check.substr(1), this.is_end_tag = !this.is_start_tag || e3.closed && "/>" === e3.closed.text, t3 = 2, "{" === this.tag_start_char && 3 <= this.text.length && "~" === this.text.charAt(2) && (t3 = 3), this.is_end_tag = this.is_end_tag || "{" === this.tag_start_char && (this.text.length < 3 || /[^#\\^]/.test(this.text.charAt(t3)))) : this.tag_complete = true;
      }, o = (g.prototype._get_tag_open_token = function(t3) {
        t3 = new f(this._tag_stack.get_parser_token(), t3);
        return t3.alignment_size = this._options.wrap_attributes_indent_size, t3.is_end_tag = t3.is_end_tag || r(t3.tag_check, this._options.void_elements), t3.is_empty_element = t3.tag_complete || t3.is_start_tag && t3.is_end_tag, t3.is_unformatted = !t3.tag_complete && r(t3.tag_check, this._options.unformatted), t3.is_content_unformatted = !t3.is_empty_element && r(t3.tag_check, this._options.content_unformatted), t3.is_inline_element = r(t3.tag_name, this._options.inline) || this._options.inline_custom_elements && t3.tag_name.includes("-") || "{" === t3.tag_start_char, t3;
      }, g.prototype._set_tag_position = function(t3, e3, n3, i4, _4) {
        n3.is_empty_element || (n3.is_end_tag ? n3.start_tag_token = this._tag_stack.try_pop(n3.tag_name) : (this._do_optional_end_element(n3) && !n3.is_inline_element && t3.print_newline(false), this._tag_stack.record_tag(n3), "script" !== n3.tag_name && "style" !== n3.tag_name || n3.is_unformatted || n3.is_content_unformatted || (n3.custom_beautifier_name = s(n3.tag_check, e3)))), r(n3.tag_check, this._options.extra_liners) && (t3.print_newline(false), t3._output.just_added_blankline() || t3.print_newline(true)), n3.is_empty_element ? ("{" === n3.tag_start_char && "else" === n3.tag_check && (this._tag_stack.indent_to_tag(["if", "unless", "each"]), n3.indent_content = true, t3.current_line_has_match(/{{#if/) || t3.print_newline(false)), "!--" === n3.tag_name && _4.type === u.TAG_CLOSE && i4.is_end_tag && -1 === n3.text.indexOf("\\n") || (n3.is_inline_element || n3.is_unformatted || t3.print_newline(false), this._calcluate_parent_multiline(t3, n3))) : n3.is_end_tag ? (e3 = false, e3 = (e3 = n3.start_tag_token && n3.start_tag_token.multiline_content) || !n3.is_inline_element && !(i4.is_inline_element || i4.is_unformatted) && !(_4.type === u.TAG_CLOSE && n3.start_tag_token === i4) && "TK_CONTENT" !== _4.type, (e3 = n3.is_content_unformatted || n3.is_unformatted ? false : e3) && t3.print_newline(false)) : (n3.indent_content = !n3.custom_beautifier_name, "<" === n3.tag_start_char && ("html" === n3.tag_name ? n3.indent_content = this._options.indent_inner_html : "head" === n3.tag_name ? n3.indent_content = this._options.indent_head_inner_html : "body" === n3.tag_name && (n3.indent_content = this._options.indent_body_inner_html)), n3.is_inline_element || n3.is_unformatted || "TK_CONTENT" === _4.type && !n3.is_content_unformatted || t3.print_newline(false), this._calcluate_parent_multiline(t3, n3));
      }, g.prototype._calcluate_parent_multiline = function(t3, e3) {
        !e3.parent || !t3._output.just_added_newline() || (e3.is_inline_element || e3.is_unformatted) && e3.parent.is_inline_element || (e3.parent.multiline_content = true);
      }, ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"]), m = ["a", "audio", "del", "ins", "map", "noscript", "video"];
      g.prototype._do_optional_end_element = function(t3) {
        var e3, n3 = null;
        if (!t3.is_empty_element && t3.is_start_tag && t3.parent) return "body" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("head") : "li" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]) : "dd" === t3.tag_name || "dt" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("dt", ["dl"])) || this._tag_stack.try_pop("dd", ["dl"]) : "p" === t3.parent.tag_name && -1 !== o.indexOf(t3.tag_name) ? (e3 = t3.parent.parent) && -1 !== m.indexOf(e3.tag_name) || (n3 = n3 || this._tag_stack.try_pop("p")) : "rp" === t3.tag_name || "rt" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("rt", ["ruby", "rtc"])) || this._tag_stack.try_pop("rp", ["ruby", "rtc"]) : "optgroup" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("optgroup", ["select"]) : "option" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]) : "colgroup" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("caption", ["table"]) : "thead" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"]) : "tbody" === t3.tag_name || "tfoot" === t3.tag_name ? n3 = (n3 = (n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"])) || this._tag_stack.try_pop("thead", ["table"])) || this._tag_stack.try_pop("tbody", ["table"]) : "tr" === t3.tag_name ? n3 = (n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"])) || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]) : "th" !== t3.tag_name && "td" !== t3.tag_name || (n3 = (n3 = n3 || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"])) || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"])), t3.parent = this._tag_stack.get_parser_token(), n3;
      }, t2.exports.Beautifier = g;
    }, function(t2, e2, n2) {
      var i3 = n2(6).Options;
      function _3(t3) {
        i3.call(this, t3, "html"), 1 === this.templating.length && "auto" === this.templating[0] && (this.templating = ["django", "erb", "handlebars", "php"]), this.indent_inner_html = this._get_boolean("indent_inner_html"), this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true), this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true), this.indent_handlebars = this._get_boolean("indent_handlebars", true), this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]), this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2), this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size), this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]), this.inline = this._get_array("inline", ["a", "abbr", "area", "audio", "b", "bdi", "bdo", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "map", "mark", "math", "meter", "noscript", "object", "output", "progress", "q", "ruby", "s", "samp", "select", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "var", "video", "wbr", "text", "acronym", "big", "strike", "tt"]), this.inline_custom_elements = this._get_boolean("inline_custom_elements", true), this.void_elements = this._get_array("void_elements", ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr", "!doctype", "?xml", "basefont", "isindex"]), this.unformatted = this._get_array("unformatted", []), this.content_unformatted = this._get_array("content_unformatted", ["pre", "textarea"]), this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter"), this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
      }
      _3.prototype = new i3(), t2.exports.Options = _3;
    }, function(t2, e2, n2) {
      function i3(t3, e3) {
        _3.call(this, t3, e3), this._current_tag_name = "";
        var t3 = new a(this._input).read_options(this._options), e3 = new o(this._input);
        this.__patterns = { word: t3.until(/[\\n\\r\\t <]/), single_quote: t3.until_after(/'/), double_quote: t3.until_after(/"/), attribute: t3.until(/[\\n\\r\\t =>]|\\/>/), element_name: t3.until(/[\\n\\r\\t >\\/]/), handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), handlebars_open: e3.until(/[\\n\\r\\t }]/), handlebars_raw_close: e3.until(/}}/), comment: e3.starting_with(/<!--/).until_after(/-->/), cdata: e3.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/), conditional_comment: e3.starting_with(/<!\\[/).until_after(/]>/), processing: e3.starting_with(/<\\?/).until_after(/\\?>/) }, this._options.indent_handlebars && (this.__patterns.word = this.__patterns.word.exclude("handlebars")), this._unformatted_content_delimiter = null, this._options.unformatted_content_delimiter && (t3 = this._input.get_literal_regexp(this._options.unformatted_content_delimiter), this.__patterns.unformatted_content_delimiter = e3.matching(t3).until_after(t3));
      }
      var _3 = n2(9).Tokenizer, s = n2(9).TOKEN, r = n2(13).Directives, a = n2(14).TemplatablePattern, o = n2(12).Pattern, p = { TAG_OPEN: "TK_TAG_OPEN", TAG_CLOSE: "TK_TAG_CLOSE", ATTRIBUTE: "TK_ATTRIBUTE", EQUALS: "TK_EQUALS", VALUE: "TK_VALUE", COMMENT: "TK_COMMENT", TEXT: "TK_TEXT", UNKNOWN: "TK_UNKNOWN", START: s.START, RAW: s.RAW, EOF: s.EOF }, h = new r(/<\\!--/, /-->/);
      (i3.prototype = new _3())._is_comment = function(t3) {
        return false;
      }, i3.prototype._is_opening = function(t3) {
        return t3.type === p.TAG_OPEN;
      }, i3.prototype._is_closing = function(t3, e3) {
        return t3.type === p.TAG_CLOSE && e3 && ((">" === t3.text || "/>" === t3.text) && "<" === e3.text[0] || "}}" === t3.text && "{" === e3.text[0] && "{" === e3.text[1]);
      }, i3.prototype._reset = function() {
        this._current_tag_name = "";
      }, i3.prototype._get_next_token = function(t3, e3) {
        this._readWhitespace();
        var n3 = this._input.peek();
        return null === n3 ? this._create_token(p.EOF, "") : this._read_open_handlebars(n3, e3) || this._read_attribute(n3, t3, e3) || this._read_close(n3, e3) || this._read_raw_content(n3, t3, e3) || this._read_content_word(n3) || this._read_comment_or_cdata(n3) || this._read_processing(n3) || this._read_open(n3, e3) || this._create_token(p.UNKNOWN, this._input.next());
      }, i3.prototype._read_comment_or_cdata = function(t3) {
        var e3 = null, n3 = null, i4 = null;
        return "<" === t3 && ("!" === this._input.peek(1) && ((n3 = this.__patterns.comment.read()) ? (i4 = h.get_directives(n3)) && "start" === i4.ignore && (n3 += h.readIgnored(this._input)) : n3 = this.__patterns.cdata.read()), n3 && ((e3 = this._create_token(p.COMMENT, n3)).directives = i4)), e3;
      }, i3.prototype._read_processing = function(t3) {
        var e3 = null, n3 = null;
        return "<" === t3 && (n3 = "!" !== (t3 = this._input.peek(1)) && "?" !== t3 ? n3 : (n3 = this.__patterns.conditional_comment.read()) || this.__patterns.processing.read()) && ((e3 = this._create_token(p.COMMENT, n3)).directives = null), e3;
      }, i3.prototype._read_open = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 || "<" === t3 && (n3 = this._input.next(), "/" === this._input.peek() && (n3 += this._input.next()), n3 += this.__patterns.element_name.read(), i4 = this._create_token(p.TAG_OPEN, n3)), i4;
      }, i3.prototype._read_open_handlebars = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 || this._options.indent_handlebars && "{" === t3 && "{" === this._input.peek(1) && (i4 = "!" === this._input.peek(2) ? (n3 = (n3 = this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars.read(), this._create_token(p.COMMENT, n3)) : (n3 = this.__patterns.handlebars_open.read(), this._create_token(p.TAG_OPEN, n3))), i4;
      }, i3.prototype._read_close = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 && ("<" === e3.text[0] && (">" === t3 || "/" === t3 && ">" === this._input.peek(1)) ? (n3 = this._input.next(), "/" === t3 && (n3 += this._input.next()), i4 = this._create_token(p.TAG_CLOSE, n3)) : "{" === e3.text[0] && "}" === t3 && "}" === this._input.peek(1) && (this._input.next(), this._input.next(), i4 = this._create_token(p.TAG_CLOSE, "}}"))), i4;
      }, i3.prototype._read_attribute = function(t3, e3, n3) {
        var i4 = null;
        return n3 && "<" === n3.text[0] && ("=" === t3 ? i4 = this._create_token(p.EQUALS, this._input.next()) : '"' === t3 || "'" === t3 ? (n3 = this._input.next(), n3 += ('"' === t3 ? this.__patterns.double_quote : this.__patterns.single_quote).read(), i4 = this._create_token(p.VALUE, n3)) : (t3 = this.__patterns.attribute.read()) && (i4 = e3.type === p.EQUALS ? this._create_token(p.VALUE, t3) : this._create_token(p.ATTRIBUTE, t3))), i4;
      }, i3.prototype._is_content_unformatted = function(t3) {
        return -1 === this._options.void_elements.indexOf(t3) && (-1 !== this._options.content_unformatted.indexOf(t3) || -1 !== this._options.unformatted.indexOf(t3));
      }, i3.prototype._read_raw_content = function(t3, e3, n3) {
        var i4 = "";
        if (n3 && "{" === n3.text[0]) i4 = this.__patterns.handlebars_raw_close.read();
        else if (e3.type === p.TAG_CLOSE && "<" === e3.opened.text[0] && "/" !== e3.text[0]) {
          n3 = e3.opened.text.substr(1).toLowerCase();
          if ("script" === n3 || "style" === n3) {
            e3 = this._read_comment_or_cdata(t3);
            if (e3) return e3.type = p.TEXT, e3;
            i4 = this._input.readUntil(new RegExp("</" + n3 + "[\\\\n\\\\r\\\\t ]*?>", "ig"));
          } else this._is_content_unformatted(n3) && (i4 = this._input.readUntil(new RegExp("</" + n3 + "[\\\\n\\\\r\\\\t ]*?>", "ig")));
        }
        return i4 ? this._create_token(p.TEXT, i4) : null;
      }, i3.prototype._read_content_word = function(t3) {
        var e3 = "";
        if (e3 = (e3 = this._options.unformatted_content_delimiter && t3 === this._options.unformatted_content_delimiter[0] ? this.__patterns.unformatted_content_delimiter.read() : e3) || this.__patterns.word.read()) return this._create_token(p.TEXT, e3);
      }, t2.exports.Tokenizer = i3, t2.exports.TOKEN = p;
    }], _2 = {};
    var t = function t2(e2) {
      var n2 = _2[e2];
      if (void 0 !== n2) return n2.exports;
      n2 = _2[e2] = { exports: {} };
      return i2[e2](n2, n2.exports, t2), n2.exports;
    }(18);
    e = t;
  }();
  var e, n, i, _ = e;
  "function" == typeof define && define.amd ? define(["require", "./beautify", "./beautify-css"], function(t) {
    var n2 = t("./beautify"), i2 = t("./beautify-css");
    return { html_beautify: function(t2, e2) {
      return _(t2, e2, n2.js_beautify, i2.css_beautify);
    } };
  }) : "undefined" != typeof exports ? (n = require("./beautify.js"), i = require("./beautify-css.js"), exports.html_beautify = function(t, e2) {
    return _(t, e2, n.js_beautify, i.css_beautify);
  }) : "undefined" != typeof window ? window.html_beautify = function(t, e2) {
    return _(t, e2, window.js_beautify, window.css_beautify);
  } : "undefined" != typeof global && (global.html_beautify = function(t, e2) {
    return _(t, e2, global.js_beautify, global.css_beautify);
  });
}();
!function() {
  !function() {
    var n = [, , function(t3) {
      function _2(t4) {
        this.__parent = t4, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function i(t4, e3) {
        this.__cache = [""], this.__indent_size = t4.indent_size, this.__indent_string = t4.indent_char, t4.indent_with_tabs || (this.__indent_string = new Array(t4.indent_size + 1).join(t4.indent_char)), e3 = e3 || "", 0 < t4.indent_level && (e3 = new Array(t4.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t4, e3) {
        this.__indent_cache = new i(t4, e3), this.raw = false, this._end_with_newline = t4.end_with_newline, this.indent_size = t4.indent_size, this.wrap_line_length = t4.wrap_line_length, this.indent_empty_lines = t4.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new _2(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      _2.prototype.clone_empty = function() {
        var t4 = new _2(this.__parent);
        return t4.set_indent(this.__indent_count, this.__alignment_count), t4;
      }, _2.prototype.item = function(t4) {
        return t4 < 0 ? this.__items[this.__items.length + t4] : this.__items[t4];
      }, _2.prototype.has_match = function(t4) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t4)) return true;
        return false;
      }, _2.prototype.set_indent = function(t4, e3) {
        this.is_empty() && (this.__indent_count = t4 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, _2.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, _2.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, _2.prototype._allow_wrap = function() {
        var t4;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t4 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t4.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t4.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t4.__items[0] && (t4.__items.splice(0, 1), --t4.__character_count), true);
      }, _2.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, _2.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, _2.prototype.push = function(t4) {
        this.__items.push(t4);
        var e3 = t4.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t4.length - e3 : this.__character_count += t4.length;
      }, _2.prototype.pop = function() {
        var t4 = null;
        return this.is_empty() || (t4 = this.__items.pop(), this.__character_count -= t4.length), t4;
      }, _2.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, _2.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, _2.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, _2.prototype.toString = function() {
        var t4 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t4 = this.__parent.get_indent_string(this.__indent_count)) : (t4 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t4 += this.__items.join("")), t4;
      }, i.prototype.get_indent_size = function(t4, e3) {
        var i2 = this.__base_string_length;
        return i2 = (i2 = t4 < 0 ? 0 : i2) + t4 * this.__indent_size + (e3 = e3 || 0);
      }, i.prototype.get_indent_string = function(t4, e3) {
        var i2 = this.__base_string;
        return e3 = e3 || 0, t4 < 0 && (t4 = 0, i2 = ""), e3 += t4 * this.__indent_size, this.__ensure_cache(e3), i2 += this.__cache[e3];
      }, i.prototype.__ensure_cache = function(t4) {
        for (; t4 >= this.__cache.length; ) this.__add_column();
      }, i.prototype.__add_column = function() {
        var t4, e3 = this.__cache.length, i2 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t4 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, i2 = new Array(t4 + 1).join(this.__indent_string)), e3 && (i2 += new Array(e3 + 1).join(" ")), this.__cache.push(i2);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t4, e3) {
        return this.__indent_cache.get_indent_string(t4, e3);
      }, e2.prototype.get_indent_size = function(t4, e3) {
        return this.__indent_cache.get_indent_size(t4, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t4) {
        return !(this.is_empty() || !t4 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t4) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t4 ? e3.replace(/[\\n]/g, t4) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t4, e3) {
        return this.next_line.set_indent(t4 = t4 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t4, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t4) {
        for (var e3 = 0; e3 < t4.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t4.whitespace_before), this.current_line.push(t4.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t4) {
        this.__add_space_before_token(), this.current_line.push(t4), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t4) {
        for (var e3 = this.__lines.length; t4 < e3; ) this.__lines[t4]._remove_indent(), t4++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t4) {
        for (t4 = void 0 !== t4 && t4, this.current_line.trim(); t4 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t4, e3) {
        for (var i2 = this.__lines.length - 2; 0 <= i2; ) {
          var n2 = this.__lines[i2];
          if (n2.is_empty()) break;
          if (0 !== n2.item(0).indexOf(t4) && n2.item(-1) !== e3) {
            this.__lines.splice(i2 + 1, 0, new _2(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          i2--;
        }
      }, t3.exports.Output = e2;
    }, , , , function(t3) {
      function e2(t4, e3) {
        this.raw_options = i(t4, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function i(t4, e3) {
        var i2, n2 = {};
        for (i2 in t4 = _2(t4)) i2 !== e3 && (n2[i2] = t4[i2]);
        if (e3 && t4[e3]) for (i2 in t4[e3]) n2[i2] = t4[e3][i2];
        return n2;
      }
      function _2(t4) {
        var e3, i2 = {};
        for (e3 in t4) i2[e3.replace(/-/g, "_")] = t4[e3];
        return i2;
      }
      e2.prototype._get_array = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || [];
        return "object" == typeof t4 ? null !== t4 && "function" == typeof t4.concat && (e3 = t4.concat()) : "string" == typeof t4 && (e3 = t4.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t4, e3) {
        t4 = this.raw_options[t4];
        return void 0 === t4 ? !!e3 : !!t4;
      }, e2.prototype._get_characters = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || "";
        return e3 = "string" == typeof t4 ? t4.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t4 = parseInt(t4, 10);
        return t4 = isNaN(t4) ? e3 : t4;
      }, e2.prototype._get_selection = function(t4, e3, i2) {
        i2 = this._get_selection_list(t4, e3, i2);
        if (1 !== i2.length) throw new Error("Invalid Option Value: The option '" + t4 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
        return i2[0];
      }, e2.prototype._get_selection_list = function(t4, e3, i2) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (i2 = i2 || [e3[0]], !this._is_valid_selection(i2, e3)) throw new Error("Invalid Default Value!");
        i2 = this._get_array(t4, i2);
        if (this._is_valid_selection(i2, e3)) return i2;
        throw new Error("Invalid Option Value: The option '" + t4 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
      }, e2.prototype._is_valid_selection = function(t4, e3) {
        return t4.length && e3.length && !t4.some(function(t5) {
          return -1 === e3.indexOf(t5);
        });
      }, t3.exports.Options = e2, t3.exports.normalizeOpts = _2, t3.exports.mergeOpts = i;
    }, , function(t3) {
      var n2 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t4) {
        this.__input = t4 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__input.charAt(this.__position), this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__input_length ? this.__input.charAt(t4) : e3;
      }, e2.prototype.__match = function(t4, e3) {
        t4.lastIndex = e3;
        var i = t4.exec(this.__input);
        return !i || n2 && t4.sticky || i.index !== e3 && (i = null), i;
      }, e2.prototype.test = function(t4, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t4, e3);
      }, e2.prototype.testChar = function(t4, e3) {
        e3 = this.peek(e3);
        return t4.lastIndex = 0, null !== e3 && t4.test(e3);
      }, e2.prototype.match = function(t4) {
        t4 = this.__match(t4, this.__position);
        return t4 ? this.__position += t4[0].length : t4 = null, t4;
      }, e2.prototype.read = function(t4, e3, i) {
        var n3, _2 = "";
        return t4 && (n3 = this.match(t4)) && (_2 += n3[0]), !e3 || !n3 && t4 || (_2 += this.readUntil(e3, i)), _2;
      }, e2.prototype.readUntil = function(t4, e3) {
        var i = this.__position, t4 = (t4.lastIndex = this.__position, t4.exec(this.__input));
        return t4 ? (i = t4.index, e3 && (i += t4[0].length)) : i = this.__input_length, e3 = this.__input.substring(this.__position, i), this.__position = i, e3;
      }, e2.prototype.readUntilAfter = function(t4) {
        return this.readUntil(t4, true);
      }, e2.prototype.get_regexp = function(t4, e3) {
        var i = null, e3 = e3 && n2 ? "y" : "g";
        return "string" == typeof t4 && "" !== t4 ? i = new RegExp(t4, e3) : t4 && (i = new RegExp(t4.source, e3)), i;
      }, e2.prototype.get_literal_regexp = function(t4) {
        return RegExp(t4.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t4) {
        var e3 = this.__position, t4 = this.readUntilAfter(t4);
        return this.__position = e3, t4;
      }, e2.prototype.lookBack = function(t4) {
        var e3 = this.__position - 1;
        return e3 >= t4.length && this.__input.substring(e3 - t4.length, e3).toLowerCase() === t4;
      }, t3.exports.InputScanner = e2;
    }, , , , , function(t3) {
      function e2(t4, e3) {
        t4 = "string" == typeof t4 ? t4 : t4.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t4 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t4 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t4) {
        if (!t4.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, i = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t4)); i; ) e3[i[1]] = i[2], i = this.__directive_pattern.exec(t4);
        return e3;
      }, e2.prototype.readIgnored = function(t4) {
        return t4.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t3.exports.Directives = e2;
    }, , function(t3, e2, i) {
      var n2 = i(16).Beautifier, _2 = i(17).Options;
      t3.exports = function(t4, e3) {
        return new n2(t4, e3).beautify();
      }, t3.exports.defaultOptions = function() {
        return new _2();
      };
    }, function(t3, e2, i) {
      var n2 = i(17).Options, w = i(2).Output, y = i(8).InputScanner, v2 = new (i(13)).Directives(/\\/\\*/, /\\*\\//), m = /\\r\\n|[\\r\\n]/, b = /\\r\\n|[\\r\\n]/g, k = /\\s/, x = /(?:\\s|\\n)+/g, O = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|\$)/g, S = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;
      function _2(t4, e3) {
        this._source_text = t4 || "", this._options = new n2(e3), this._ch = null, this._input = null, this.NESTED_AT_RULE = { page: true, "font-face": true, keyframes: true, media: true, supports: true, document: true }, this.CONDITIONAL_GROUP_RULE = { media: true, supports: true, document: true }, this.NON_SEMICOLON_NEWLINE_PROPERTY = ["grid-template-areas", "grid-template"];
      }
      _2.prototype.eatString = function(t4) {
        var e3 = "";
        for (this._ch = this._input.next(); this._ch; ) {
          if (e3 += this._ch, "\\\\" === this._ch) e3 += this._input.next();
          else if (-1 !== t4.indexOf(this._ch) || "\\n" === this._ch) break;
          this._ch = this._input.next();
        }
        return e3;
      }, _2.prototype.eatWhitespace = function(t4) {
        for (var e3 = k.test(this._input.peek()), i2 = 0; k.test(this._input.peek()); ) this._ch = this._input.next(), t4 && "\\n" === this._ch && (0 === i2 || i2 < this._options.max_preserve_newlines) && (i2++, this._output.add_new_line(true));
        return e3;
      }, _2.prototype.foundNestedPseudoClass = function() {
        for (var t4 = 0, e3 = 1, i2 = this._input.peek(e3); i2; ) {
          if ("{" === i2) return true;
          if ("(" === i2) t4 += 1;
          else if (")" === i2) {
            if (0 === t4) return false;
            --t4;
          } else if (";" === i2 || "}" === i2) return false;
          e3++, i2 = this._input.peek(e3);
        }
        return false;
      }, _2.prototype.print_string = function(t4) {
        this._output.set_indent(this._indentLevel), this._output.non_breaking_space = true, this._output.add_token(t4);
      }, _2.prototype.preserveSingleSpace = function(t4) {
        t4 && (this._output.space_before_token = true);
      }, _2.prototype.indent = function() {
        this._indentLevel++;
      }, _2.prototype.outdent = function() {
        0 < this._indentLevel && this._indentLevel--;
      }, _2.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t4, e3, i2, n3 = this._source_text, _3 = this._options.eol, s = ("auto" === _3 && (_3 = "\\n", n3 && m.test(n3 || "") && (_3 = n3.match(m)[0])), (n3 = n3.replace(b, "\\n")).match(/^[\\t ]*/)[0]), r = (this._output = new w(this._options, s), this._input = new y(n3), this._indentLevel = 0, this._nestedLevel = 0, this._ch = null, 0), h = false, o = false, p = false, a = false, u = false, c = this._ch, l = false; t4 = "" !== this._input.read(x), e3 = c, this._ch = this._input.next(), "\\\\" === this._ch && this._input.hasNext() && (this._ch += this._input.next()), c = this._ch, this._ch; ) if ("/" === this._ch && "*" === this._input.peek()) {
          this._output.add_new_line(), this._input.back();
          var d = this._input.read(O), f = v2.get_directives(d);
          f && "start" === f.ignore && (d += v2.readIgnored(this._input)), this.print_string(d), this.eatWhitespace(true), this._output.add_new_line();
        } else if ("/" === this._ch && "/" === this._input.peek()) this._output.space_before_token = true, this._input.back(), this.print_string(this._input.read(S)), this.eatWhitespace(true);
        else if ("\$" === this._ch) {
          this.preserveSingleSpace(t4), this.print_string(this._ch);
          f = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='"]/g);
          f.match(/[ :]\$/) && (f = this.eatString(": ").replace(/\\s+\$/, ""), this.print_string(f), this._output.space_before_token = true), 0 === r && -1 !== f.indexOf(":") && (o = true, this.indent());
        } else if ("@" === this._ch) this.preserveSingleSpace(t4), "{" === this._input.peek() ? this.print_string(this._ch + this.eatString("}")) : (this.print_string(this._ch), (d = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='"]/g)).match(/[ :]\$/) && (d = this.eatString(": ").replace(/\\s+\$/, ""), this.print_string(d), this._output.space_before_token = true), 0 === r && -1 !== d.indexOf(":") ? (o = true, this.indent()) : d in this.NESTED_AT_RULE ? (this._nestedLevel += 1, d in this.CONDITIONAL_GROUP_RULE && (p = true)) : 0 !== r || o || (a = true));
        else if ("#" === this._ch && "{" === this._input.peek()) this.preserveSingleSpace(t4), this.print_string(this._ch + this.eatString("}"));
        else if ("{" === this._ch) o && (o = false, this.outdent()), a = false, h = p ? (p = false, this._indentLevel >= this._nestedLevel) : this._indentLevel >= this._nestedLevel - 1, this._options.newline_between_rules && h && this._output.previous_line && "{" !== this._output.previous_line.item(-1) && this._output.ensure_empty_line_above("/", ","), this._output.space_before_token = true, "expand" === this._options.brace_style ? (this._output.add_new_line(), this.print_string(this._ch), this.indent(), this._output.set_indent(this._indentLevel)) : ("(" === e3 ? this._output.space_before_token = false : "," !== e3 && this.indent(), this.print_string(this._ch)), this.eatWhitespace(true), this._output.add_new_line();
        else if ("}" === this._ch) this.outdent(), this._output.add_new_line(), "{" === e3 && this._output.trim(true), o && (this.outdent(), o = false), this.print_string(this._ch), h = false, this._nestedLevel && this._nestedLevel--, this.eatWhitespace(true), this._output.add_new_line(), this._options.newline_between_rules && !this._output.just_added_blankline() && "}" !== this._input.peek() && this._output.add_new_line(true), ")" === this._input.peek() && (this._output.trim(true), "expand" === this._options.brace_style && this._output.add_new_line(true));
        else if (":" === this._ch) {
          for (var g = 0; g < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; g++) if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[g])) {
            l = true;
            break;
          }
          !h && !p || this._input.lookBack("&") || this.foundNestedPseudoClass() || this._input.lookBack("(") || a || 0 !== r ? (this._input.lookBack(" ") && (this._output.space_before_token = true), ":" === this._input.peek() ? (this._ch = this._input.next(), this.print_string("::")) : this.print_string(":")) : (this.print_string(":"), o || (this._output.space_before_token = o = true, this.eatWhitespace(true), this.indent()));
        } else '"' === this._ch || "'" === this._ch ? (this.preserveSingleSpace('"' === e3 || "'" === e3 || t4), this.print_string(this._ch + this.eatString(this._ch)), this.eatWhitespace(true)) : ";" === this._ch ? (l = false, 0 === r ? (o && (this.outdent(), o = false), a = false, this.print_string(this._ch), this.eatWhitespace(true), "/" !== this._input.peek() && this._output.add_new_line()) : (this.print_string(this._ch), this.eatWhitespace(true), this._output.space_before_token = true)) : "(" === this._ch ? this._input.lookBack("url") ? (this.print_string(this._ch), this.eatWhitespace(), r++, this.indent(), this._ch = this._input.next(), ")" === this._ch || '"' === this._ch || "'" === this._ch ? this._input.back() : this._ch && (this.print_string(this._ch + this.eatString(")")), r && (r--, this.outdent()))) : (i2 = false, this._input.lookBack("with") && (i2 = true), this.preserveSingleSpace(t4 || i2), this.print_string(this._ch), o && "\$" === e3 && this._options.selector_separator_newline ? (this._output.add_new_line(), u = true) : (this.eatWhitespace(), r++, this.indent())) : ")" === this._ch ? (r && (r--, this.outdent()), u && ";" === this._input.peek() && this._options.selector_separator_newline && (u = false, this.outdent(), this._output.add_new_line()), this.print_string(this._ch)) : "," === this._ch ? (this.print_string(this._ch), this.eatWhitespace(true), !this._options.selector_separator_newline || o && !u || 0 !== r || a ? this._output.space_before_token = true : this._output.add_new_line()) : ">" !== this._ch && "+" !== this._ch && "~" !== this._ch || o || 0 !== r ? "]" === this._ch ? this.print_string(this._ch) : "[" === this._ch ? (this.preserveSingleSpace(t4), this.print_string(this._ch)) : "=" === this._ch ? (this.eatWhitespace(), this.print_string("="), k.test(this._ch) && (this._ch = "")) : "!" !== this._ch || this._input.lookBack("\\\\") ? (this.preserveSingleSpace('"' === e3 || "'" === e3 || t4), this.print_string(this._ch), !this._output.just_added_newline() && "\\n" === this._input.peek() && l && this._output.add_new_line()) : (this._output.space_before_token = true, this.print_string(this._ch)) : this._options.space_around_combinator ? (this._output.space_before_token = true, this.print_string(this._ch), this._output.space_before_token = true) : (this.print_string(this._ch), this.eatWhitespace(), this._ch && k.test(this._ch) && (this._ch = ""));
        return this._output.get_code(_3);
      }, t3.exports.Beautifier = _2;
    }, function(t3, e2, i) {
      var n2 = i(6).Options;
      function _2(t4) {
        n2.call(this, t4, "css"), this.selector_separator_newline = this._get_boolean("selector_separator_newline", true), this.newline_between_rules = this._get_boolean("newline_between_rules", true);
        var t4 = this._get_boolean("space_around_selector_separator"), e3 = (this.space_around_combinator = this._get_boolean("space_around_combinator") || t4, this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]));
        this.brace_style = "collapse";
        for (var i2 = 0; i2 < e3.length; i2++) "expand" !== e3[i2] ? this.brace_style = "collapse" : this.brace_style = e3[i2];
      }
      _2.prototype = new n2(), t3.exports.Options = _2;
    }], _ = {};
    var t2 = function t3(e2) {
      var i = _[e2];
      if (void 0 !== i) return i.exports;
      i = _[e2] = { exports: {} };
      return n[e2](i, i.exports, t3), i.exports;
    }(15);
    e = t2;
  }();
  var e, t = e;
  "function" == typeof define && define.amd ? define([], function() {
    return { css_beautify: t };
  }) : "undefined" != typeof exports ? exports.css_beautify = t : "undefined" != typeof window ? window.css_beautify = t : "undefined" != typeof global && (global.css_beautify = t);
}();
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineSimpleMode = function(name, states) {
    CodeMirror2.defineMode(name, function(config) {
      return CodeMirror2.simpleMode(config, states);
    });
  };
  CodeMirror2.simpleMode = function(config, states) {
    ensureState(states, "start");
    var states_ = {}, meta2 = states.meta || {}, hasIndentation = false;
    for (var state in states) if (state != meta2 && states.hasOwnProperty(state)) {
      var list = states_[state] = [], orig = states[state];
      for (var i = 0; i < orig.length; i++) {
        var data = orig[i];
        list.push(new Rule(data, states));
        if (data.indent || data.dedent) hasIndentation = true;
      }
    }
    var mode = {
      startState: function() {
        return {
          state: "start",
          pending: null,
          local: null,
          localState: null,
          indent: hasIndentation ? [] : null
        };
      },
      copyState: function(state2) {
        var s = {
          state: state2.state,
          pending: state2.pending,
          local: state2.local,
          localState: null,
          indent: state2.indent && state2.indent.slice(0)
        };
        if (state2.localState)
          s.localState = CodeMirror2.copyState(state2.local.mode, state2.localState);
        if (state2.stack)
          s.stack = state2.stack.slice(0);
        for (var pers = state2.persistentStates; pers; pers = pers.next)
          s.persistentStates = {
            mode: pers.mode,
            spec: pers.spec,
            state: pers.state == state2.localState ? s.localState : CodeMirror2.copyState(pers.mode, pers.state),
            next: s.persistentStates
          };
        return s;
      },
      token: tokenFunction(states_, config),
      innerMode: function(state2) {
        return state2.local && { mode: state2.local.mode, state: state2.localState };
      },
      indent: indentFunction(states_, meta2)
    };
    if (meta2) {
      for (var prop in meta2) if (meta2.hasOwnProperty(prop))
        mode[prop] = meta2[prop];
    }
    return mode;
  };
  function ensureState(states, name) {
    if (!states.hasOwnProperty(name))
      throw new Error("Undefined state " + name + " in simple mode");
  }
  function toRegex(val, caret) {
    if (!val) return /(?:)/;
    var flags = "";
    if (val instanceof RegExp) {
      if (val.ignoreCase) flags = "i";
      if (val.unicode) flags += "u";
      val = val.source;
    } else {
      val = String(val);
    }
    return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
  }
  function asToken(val) {
    if (!val) return null;
    if (val.apply) return val;
    if (typeof val == "string") return val.replace(/\\./g, " ");
    var result = [];
    for (var i = 0; i < val.length; i++)
      result.push(val[i] && val[i].replace(/\\./g, " "));
    return result;
  }
  function Rule(data, states) {
    if (data.next || data.push) ensureState(states, data.next || data.push);
    this.regex = toRegex(data.regex);
    this.token = asToken(data.token);
    this.data = data;
  }
  function tokenFunction(states, config) {
    return function(stream, state) {
      if (state.pending) {
        var pend = state.pending.shift();
        if (state.pending.length == 0) state.pending = null;
        stream.pos += pend.text.length;
        return pend.token;
      }
      if (state.local) {
        if (state.local.end && stream.match(state.local.end)) {
          var tok = state.local.endToken || null;
          state.local = state.localState = null;
          return tok;
        } else {
          var tok = state.local.mode.token(stream, state.localState), m;
          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
            stream.pos = stream.start + m.index;
          return tok;
        }
      }
      var curState = states[state.state];
      for (var i = 0; i < curState.length; i++) {
        var rule = curState[i];
        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
        if (matches) {
          if (rule.data.next) {
            state.state = rule.data.next;
          } else if (rule.data.push) {
            (state.stack || (state.stack = [])).push(state.state);
            state.state = rule.data.push;
          } else if (rule.data.pop && state.stack && state.stack.length) {
            state.state = state.stack.pop();
          }
          if (rule.data.mode)
            enterLocalMode(config, state, rule.data.mode, rule.token);
          if (rule.data.indent)
            state.indent.push(stream.indentation() + config.indentUnit);
          if (rule.data.dedent)
            state.indent.pop();
          var token = rule.token;
          if (token && token.apply) token = token(matches);
          if (matches.length > 2 && rule.token && typeof rule.token != "string") {
            for (var j = 2; j < matches.length; j++)
              if (matches[j])
                (state.pending || (state.pending = [])).push({ text: matches[j], token: rule.token[j - 1] });
            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
            return token[0];
          } else if (token && token.join) {
            return token[0];
          } else {
            return token;
          }
        }
      }
      stream.next();
      return null;
    };
  }
  function cmp(a, b) {
    if (a === b) return true;
    if (!a || typeof a != "object" || !b || typeof b != "object") return false;
    var props = 0;
    for (var prop in a) if (a.hasOwnProperty(prop)) {
      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
      props++;
    }
    for (var prop in b) if (b.hasOwnProperty(prop)) props--;
    return props == 0;
  }
  function enterLocalMode(config, state, spec, token) {
    var pers;
    if (spec.persistent) {
      for (var p = state.persistentStates; p && !pers; p = p.next)
        if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
    }
    var mode = pers ? pers.mode : spec.mode || CodeMirror2.getMode(config, spec.spec);
    var lState = pers ? pers.state : CodeMirror2.startState(mode);
    if (spec.persistent && !pers)
      state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
    state.localState = lState;
    state.local = {
      mode,
      end: spec.end && toRegex(spec.end),
      endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
      endToken: token && token.join ? token[token.length - 1] : token
    };
  }
  function indexOf(val, arr) {
    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;
  }
  function indentFunction(states, meta2) {
    return function(state, textAfter, line) {
      if (state.local && state.local.mode.indent)
        return state.local.mode.indent(state.localState, textAfter, line);
      if (state.indent == null || state.local || meta2.dontIndentStates && indexOf(state.state, meta2.dontIndentStates) > -1)
        return CodeMirror2.Pass;
      var pos = state.indent.length - 1, rules = states[state.state];
      scan: for (; ; ) {
        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i];
          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
            var m = rule.regex.exec(textAfter);
            if (m && m[0]) {
              pos--;
              if (rule.next || rule.push) rules = states[rule.next || rule.push];
              textAfter = textAfter.slice(m[0].length);
              continue scan;
            }
          }
        }
        break;
      }
      return pos < 0 ? 0 : state.indent[pos];
    };
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  const escapeLetters = ["س", "ر", "ج"];
  const easternHexLetters = ["ا", "ب", "ج", "د", "ه", "و"];
  const escapeLettersPatterns = escapeLetters.map((c) => tatweelRegex(c)).join("");
  const easternHexLetter = \`[\${easternHexLetters.map((c) => tatweelRegex(c)).join("")}]\`;
  const westernHexLetter = \`[a-fA-F]\`;
  const escapeChar = \`[\${escapeLettersPatterns}›»]\`;
  const unicodePrefix = tatweelRegex("م");
  const easternUnicode = \`(?:\${unicodePrefix}\${openCurly}(?:\${easternDigit}|\${easternHexLetter}){1,6}\${closeCurly})\`;
  const westernUnicode = \`(?:\${unicodePrefix}\${openCurly}(?:\${westernDigit}|\${westernHexLetter}){1,6}\${closeCurly})\`;
  const unicode = \`(?:\${easternUnicode}|\${westernUnicode})\`;
  const noCloseQuoteOrSlash = \`[^›\${slash}]\`;
  const wordsToRegex = (WORDS) => RegExp(anyWord(WORDS), "u");
  const anyWord = (WORDS) => {
    let res = [];
    Object.values(WORDS).forEach((v2) => res.push(tatweelRegex(v2.ar)));
    return \`(?:\${res.join("|")})\`;
  };
  const startMultilineComment = () => RegExp(\`\${openCurly}-\`, "u");
  const multilineComment = () => RegExp(\`.*\`, "u");
  const closeMultilineComment = () => RegExp(\`.*?-\${closeCurly}\`, "u");
  const comment = () => RegExp(\`--.*\`, "u");
  const escape = \`\${slash}(?:\${escapeChar}|\${unicode})\`;
  const char = () => RegExp(\`‹(?:\${noCloseQuoteOrSlash}|\${escape})›\`, "u");
  const startMultilineString = () => RegExp(\`b?«««\`, "u");
  const multilineString = () => RegExp(\`(?:[^»]|»(?!»»))*\`, "u");
  const endMultilineString = () => RegExp(\`»»»\`, "u");
  const startString = () => RegExp(\`b?«\`, "u");
  const string = () => RegExp(\`(?:[^\${slash}»]|\${slash}(?:.|\$))*\`, "u");
  const endString = () => RegExp(\`»\`, "u");
  const number = () => RegExp(\`(?:\${easternFloat})|(?:\${westernFloat})\`, "u");
  const variableRegex = () => RegExp(\`(?!\${anyWord(RESERVED)}(?:\${notIdPart}|\\\\s|\$))\${id}\`, "u");
  const keywordRegex = () => wordsToRegex(KEYWORDS);
  const atomRegex = () => wordsToRegex(ATOMS);
  const builtinRegex = () => wordsToRegex(BUILTINS);
  CodeMirror2.defineSimpleMode("seen-ar", {
    start: [
      { regex: startMultilineComment(), token: "comment", next: "multiline_comment" },
      { regex: comment(), token: "comment" },
      { regex: startMultilineString(), token: "string", next: "multiline_string" },
      { regex: startString(), token: "string", next: "string" },
      { regex: char(), token: "string-2" },
      { regex: number(), token: "number" },
      ...commonStartRules,
      { regex: variableRegex(), token: "variable" },
      { regex: keywordRegex(), token: "keyword" },
      { regex: atomRegex(), token: "atom" },
      { regex: builtinRegex(), token: "builtin" }
    ],
    multiline_comment: [
      { regex: closeMultilineComment(), token: "comment", next: "start" },
      { regex: multilineComment(), token: "comment" }
    ],
    multiline_string: [
      { regex: endMultilineString(), token: "string", next: "start" },
      { regex: multilineString(), token: "string" }
    ],
    string: [
      { regex: endString(), token: "string", next: "start" },
      { regex: string(), token: "string" }
    ],
    meta
  });
  CodeMirror2.defineMIME("text/x-seen-ar-src", "seen-ar");
  CodeMirror2.defineMIME("text/seen-ar", "seen-ar");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  const escapeChar = \`[nrt'"]\`;
  const unicode = \`u\${openCurly}[\\\\da-fA-F]{1,6}\${closeCurly}\`;
  const noQuoteOrBslash = \`[^'\${backslash}]\`;
  function wordsToRegex(WORDS) {
    let res = [];
    Object.values(WORDS).forEach((v2) => res.push(v2.en));
    return RegExp(\`\\\\b(?:\${res.join("|")})\\\\b\`);
  }
  const startMultilineComment = () => RegExp(\`\${openCurly}\${dash}\`);
  const multilineComment = () => RegExp(\`.*\`);
  const closeMultilineComment = () => RegExp(\`.*?\${dash}\${closeCurly}\`);
  const comment = () => RegExp(\`\${dash}\${dash}.*\`);
  const escape = \`\${backslash}(?:\${escapeChar}|\${unicode})\`;
  const char = () => RegExp(\`'(?:\${noQuoteOrBslash}|\${escape})'\`);
  const startMultilineString = () => RegExp(\`b?"""\`);
  const multilineString = () => RegExp(\`(?:[^"]|"(?!""))*\`);
  const endMultilineString = () => RegExp(\`"""\`);
  const startString = () => RegExp(\`b?'\`);
  const string = () => RegExp(\`(?:\${noQuoteOrBslash}|\${backslash}(?:.|\$))*\`);
  const endString = () => RegExp(\`'\`);
  const number = () => RegExp(\`(?:\${westernFloat})\`);
  const variableRegex = () => RegExp(\`\${id}\`, "u");
  const keywordRegex = () => wordsToRegex(KEYWORDS);
  const atomRegex = () => wordsToRegex(ATOMS);
  const builtinRegex = () => wordsToRegex(BUILTINS);
  CodeMirror2.defineSimpleMode("seen-en", {
    start: [
      { regex: startMultilineComment(), token: "comment", next: "multiline_comment" },
      { regex: comment(), token: "comment" },
      { regex: startMultilineString(), token: "string", next: "multiline_string" },
      { regex: startString(), token: "string", next: "string" },
      { regex: char(), token: "string-2" },
      { regex: number(), token: "number" },
      ...commonStartRules,
      { regex: keywordRegex(), token: "keyword" },
      { regex: atomRegex(), token: "atom" },
      { regex: builtinRegex(), token: "builtin" },
      { regex: variableRegex(), token: "variable" }
    ],
    multiline_comment: [
      { regex: closeMultilineComment(), token: "comment", next: "start" },
      { regex: multilineComment(), token: "comment" }
    ],
    multiline_string: [
      { regex: endMultilineString(), token: "string", next: "start" },
      { regex: multilineString(), token: "string" }
    ],
    string: [
      { regex: endString(), token: "string", next: "start" },
      { regex: string(), token: "string" }
    ],
    meta
  });
  CodeMirror2.defineMIME("text/x-seen-en-src", "seen-en");
  CodeMirror2.defineMIME("text/seen-en", "seen-en");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineMode("javascript", function(config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var trackScope = parserConfig.trackScope !== false;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\\w\$\\xa1-\\uffff]/;
    var keywords = function() {
      function kw(type3) {
        return { type: type3, style: "keyword" };
      }
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
      var operator = kw("operator"), atom = { type: "atom", style: "atom" };
      return {
        "if": kw("if"),
        "while": A,
        "with": A,
        "else": B,
        "do": B,
        "try": B,
        "finally": B,
        "return": D,
        "break": D,
        "continue": D,
        "new": kw("new"),
        "delete": C,
        "void": C,
        "throw": C,
        "debugger": kw("debugger"),
        "var": kw("var"),
        "const": kw("var"),
        "let": kw("var"),
        "function": kw("function"),
        "catch": kw("catch"),
        "for": kw("for"),
        "switch": kw("switch"),
        "case": kw("case"),
        "default": kw("default"),
        "in": operator,
        "typeof": operator,
        "instanceof": operator,
        "true": atom,
        "false": atom,
        "null": atom,
        "undefined": atom,
        "NaN": atom,
        "Infinity": atom,
        "this": kw("this"),
        "class": kw("class"),
        "super": kw("atom"),
        "yield": C,
        "export": kw("export"),
        "import": kw("import"),
        "extends": C,
        "await": C
      };
    }();
    var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;
          else if (inSet && next == "]") inSet = false;
        }
        escaped = !escaped && next == "\\\\";
      }
    }
    var type2, content;
    function ret(tp, style, cont2) {
      type2 = tp;
      content = cont2;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\\d/.test(ch)) {
        stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "\`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#" && stream.peek() == "!") {
        stream.skipToEnd();
        return ret("meta", "meta");
      } else if (ch == "#" && stream.eatWhile(wordRE)) {
        return ret("variable", "property");
      } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\\S/.test(stream.string.slice(0, stream.start))) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=");
          } else if (/[<>*+\\-|&?]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">") stream.eat(ch);
          }
        }
        if (ch == "?" && stream.eat(".")) return ret(".");
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();
        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }
          if (word == "async" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))
            return ret("async", "keyword", word);
        }
        return ret("variable", "variable", word);
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\\\";
        }
        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = ch == "*";
      }
      return ret("comment", "comment");
    }
    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "\`" || next == "\$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\\\";
      }
      return ret("quasi", "string-2", stream.current());
    }
    var brackets = "([{}])";
    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;
      if (isTS) {
        var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*\$/.exec(stream.string.slice(stream.start, arrow));
        if (m) arrow = m.index;
      }
      var depth = 0, sawSomething = false;
      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;
            break;
          }
          if (--depth == 0) {
            if (ch == "(") sawSomething = true;
            break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\\/\`]/.test(ch)) {
          for (; ; --pos) {
            if (pos == 0) return;
            var next = stream.string.charAt(pos - 1);
            if (next == ch && stream.string.charAt(pos - 2) != "\\\\") {
              pos--;
              break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth) state.fatArrowAt = pos;
    }
    var atomicTypes = {
      "atom": true,
      "number": true,
      "variable": true,
      "string": true,
      "regexp": true,
      "this": true,
      "import": true,
      "jsonld-keyword": true
    };
    function JSLexical(indented, column, type3, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type3;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }
    function inScope(state, varname) {
      if (!trackScope) return false;
      for (var v2 = state.localVars; v2; v2 = v2.next)
        if (v2.name == varname) return true;
      for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
        for (var v2 = cx2.vars; v2; v2 = v2.next)
          if (v2.name == varname) return true;
      }
    }
    function parseJS(state, style, type3, content2, stream) {
      var cc = state.cc;
      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;
      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type3, content2)) {
          while (cc.length && cc[cc.length - 1].lex)
            cc.pop()();
          if (cx.marked) return cx.marked;
          if (type3 == "variable" && inScope(state, content2)) return "variable-2";
          return style;
        }
      }
    }
    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name, list) {
      for (var v2 = list; v2; v2 = v2.next) if (v2.name == name) return true;
      return false;
    }
    function register(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (!trackScope) return;
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          var newContext = registerVarScoped(varname, state.context);
          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      }
      if (parserConfig.globalVars && !inList(varname, state.globalVars))
        state.globalVars = new Var(varname, state.globalVars);
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner) return null;
        if (inner == context.prev) return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }
    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    }
    function Context(prev, vars, block2) {
      this.prev = prev;
      this.vars = vars;
      this.block = block2;
    }
    function Var(name, next) {
      this.name = name;
      this.next = next;
    }
    var defaultVars = new Var("this", new Var("arguments", null));
    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }
    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }
    pushcontext.lex = pushblockcontext.lex = true;
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    popcontext.lex = true;
    function pushlex(type3, info) {
      var result = function() {
        var state = cx.state, indent2 = state.indented;
        if (state.lexical.type == "stat") indent2 = state.lexical.indented;
        else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
          indent2 = outer.indented;
        state.lexical = new JSLexical(indent2, cx.stream.column(), type3, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;
    function expect(wanted) {
      function exp(type3) {
        if (type3 == wanted) return cont();
        else if (wanted == ";" || type3 == "}" || type3 == ")" || type3 == "]") return pass();
        else return cont(exp);
      }
      return exp;
    }
    function statement(type3, value) {
      if (type3 == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type3 == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type3 == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type3 == "keyword d") return cx.stream.match(/^\\s*\$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type3 == "debugger") return cont(expect(";"));
      if (type3 == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type3 == ";") return cont();
      if (type3 == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type3 == "function") return cont(functiondef);
      if (type3 == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
      if (type3 == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type3 == "class" ? type3 : value), className, poplex);
      }
      if (type3 == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\\s*\\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum") return cont(enumdef);
          else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
          else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type3 == "switch") return cont(
        pushlex("form"),
        parenExpr,
        expect("{"),
        pushlex("}", "switch"),
        pushblockcontext,
        block,
        poplex,
        poplex,
        popcontext
      );
      if (type3 == "case") return cont(expression, expect(":"));
      if (type3 == "default") return cont(expect(":"));
      if (type3 == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type3 == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type3 == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type3 == "async") return cont(statement);
      if (value == "@") return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type3) {
      if (type3 == "(") return cont(funarg, expect(")"));
    }
    function expression(type3, value) {
      return expressionInner(type3, value, false);
    }
    function expressionNoComma(type3, value) {
      return expressionInner(type3, value, true);
    }
    function parenExpr(type3) {
      if (type3 != "(") return pass();
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
    }
    function expressionInner(type3, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
        else if (type3 == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }
      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type3)) return cont(maybeop);
      if (type3 == "function") return cont(functiondef, maybeop);
      if (type3 == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }
      if (type3 == "keyword c" || type3 == "async") return cont(noComma ? expressionNoComma : expression);
      if (type3 == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type3 == "operator" || type3 == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type3 == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type3 == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type3 == "quasi") return pass(quasi, maybeop);
      if (type3 == "new") return cont(maybeTarget(noComma));
      return cont();
    }
    function maybeexpression(type3) {
      if (type3.match(/[;\\}\\)\\],]/)) return pass();
      return pass(expression);
    }
    function maybeoperatorComma(type3, value) {
      if (type3 == ",") return cont(maybeexpression);
      return maybeoperatorNoComma(type3, value, false);
    }
    function maybeoperatorNoComma(type3, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type3 == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type3 == "operator") {
        if (/\\+\\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type3 == "quasi") {
        return pass(quasi, me);
      }
      if (type3 == ";") return;
      if (type3 == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type3 == ".") return cont(property, me);
      if (type3 == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }
      if (type3 == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }
    function quasi(type3, value) {
      if (type3 != "quasi") return pass();
      if (value.slice(value.length - 2) != "\${") return cont(quasi);
      return cont(maybeexpression, continueQuasi);
    }
    function continueQuasi(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function(type3) {
        if (type3 == ".") return cont(noComma ? targetNoComma : target);
        else if (type3 == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
        else return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }
    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }
    function maybelabel(type3) {
      if (type3 == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type3) {
      if (type3 == "variable") {
        cx.marked = "property";
        return cont();
      }
    }
    function objprop(type3, value) {
      if (type3 == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m;
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))
          cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type3 == "number" || type3 == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type3 == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type3 == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == ":") {
        return pass(afterprop);
      }
    }
    function getterSetter(type3) {
      if (type3 != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type3) {
      if (type3 == ":") return cont(expressionNoComma);
      if (type3 == "(") return pass(functiondef);
    }
    function commasep(what, end, sep) {
      function proceed(type3, value) {
        if (sep ? sep.indexOf(type3) > -1 : type3 == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function(type4, value2) {
            if (type4 == end || value2 == end) return pass();
            return pass(what);
          }, proceed);
        }
        if (type3 == end || value == end) return cont();
        if (sep && sep.indexOf(";") > -1) return pass(what);
        return cont(expect(end));
      }
      return function(type3, value) {
        if (type3 == end || value == end) return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++)
        cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type3) {
      if (type3 == "}") return cont();
      return pass(statement, block);
    }
    function maybetype(type3, value) {
      if (isTS) {
        if (type3 == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }
    function maybetypeOrIn(type3, value) {
      if (isTS && (type3 == ":" || value == "in")) return cont(typeexpr);
    }
    function mayberettype(type3) {
      if (isTS && type3 == ":") {
        if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr);
        else return cont(typeexpr);
      }
    }
    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }
    function typeexpr(type3, value) {
      if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
        cx.marked = "keyword";
        return cont(value == "typeof" ? expressionNoComma : typeexpr);
      }
      if (type3 == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }
      if (value == "|" || value == "&") return cont(typeexpr);
      if (type3 == "string" || type3 == "number" || type3 == "atom") return cont(afterType);
      if (type3 == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type3 == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
      if (type3 == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type3 == "<") return cont(commasep(typeexpr, ">"), typeexpr);
      if (type3 == "quasi") {
        return pass(quasiType, afterType);
      }
    }
    function maybeReturnType(type3) {
      if (type3 == "=>") return cont(typeexpr);
    }
    function typeprops(type3) {
      if (type3.match(/[\\}\\)\\]]/)) return cont();
      if (type3 == "," || type3 == ";") return cont(typeprops);
      return pass(typeprop, typeprops);
    }
    function typeprop(type3, value) {
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?" || type3 == "number" || type3 == "string") {
        return cont(typeprop);
      } else if (type3 == ":") {
        return cont(typeexpr);
      } else if (type3 == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type3 == "(") {
        return pass(functiondecl, typeprop);
      } else if (!type3.match(/[;\\}\\)\\],]/)) {
        return cont();
      }
    }
    function quasiType(type3, value) {
      if (type3 != "quasi") return pass();
      if (value.slice(value.length - 2) != "\${") return cont(quasiType);
      return cont(typeexpr, continueQuasiType);
    }
    function continueQuasiType(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasiType);
      }
    }
    function typearg(type3, value) {
      if (type3 == "variable" && cx.stream.match(/^\\s*[?:]/, false) || value == "?") return cont(typearg);
      if (type3 == ":") return cont(typeexpr);
      if (type3 == "spread") return cont(typearg);
      return pass(typeexpr);
    }
    function afterType(type3, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type3 == "." || value == "&") return cont(typeexpr);
      if (type3 == "[") return cont(typeexpr, expect("]"), afterType);
      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }
      if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
    }
    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }
    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr);
    }
    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type3, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(pattern);
      }
      if (type3 == "variable") {
        register(value);
        return cont();
      }
      if (type3 == "spread") return cont(pattern);
      if (type3 == "[") return contCommasep(eltpattern, "]");
      if (type3 == "{") return contCommasep(proppattern, "}");
    }
    function proppattern(type3, value) {
      if (type3 == "variable" && !cx.stream.match(/^\\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type3 == "variable") cx.marked = "property";
      if (type3 == "spread") return cont(pattern);
      if (type3 == "}") return pass();
      if (type3 == "[") return cont(expression, expect("]"), expect(":"), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type3) {
      if (type3 == ",") return cont(vardef);
    }
    function maybeelse(type3, value) {
      if (type3 == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type3, value) {
      if (value == "await") return cont(forspec);
      if (type3 == "(") return cont(pushlex(")"), forspec1, poplex);
    }
    function forspec1(type3) {
      if (type3 == "var") return cont(vardef, forspec2);
      if (type3 == "variable") return cont(forspec2);
      return pass(forspec2);
    }
    function forspec2(type3, value) {
      if (type3 == ")") return cont();
      if (type3 == ";") return cont(forspec2);
      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression, forspec2);
      }
      return pass(expression, forspec2);
    }
    function functiondef(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondef);
      }
      if (type3 == "variable") {
        register(value);
        return cont(functiondef);
      }
      if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }
    function functiondecl(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondecl);
      }
      if (type3 == "variable") {
        register(value);
        return cont(functiondecl);
      }
      if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }
    function typename(type3, value) {
      if (type3 == "keyword" || type3 == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }
    function funarg(type3, value) {
      if (value == "@") cont(expression, funarg);
      if (type3 == "spread") return cont(funarg);
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(funarg);
      }
      if (isTS && type3 == "this") return cont(maybetype, maybeAssign);
      return pass(pattern, maybetype, maybeAssign);
    }
    function classExpression(type3, value) {
      if (type3 == "variable") return className(type3, value);
      return classNameAfter(type3, value);
    }
    function className(type3, value) {
      if (type3 == "variable") {
        register(value);
        return cont(classNameAfter);
      }
    }
    function classNameAfter(type3, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
      if (value == "extends" || value == "implements" || isTS && type3 == ",") {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type3 == "{") return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type3, value) {
      if (type3 == "async" || type3 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\\s+#?[\\w\$\\xa1-\\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(classfield, classBody);
      }
      if (type3 == "number" || type3 == "string") return cont(classfield, classBody);
      if (type3 == "[")
        return cont(expression, maybetype, expect("]"), classfield, classBody);
      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type3 == "(") return pass(functiondecl, classBody);
      if (type3 == ";" || type3 == ",") return cont(classBody);
      if (type3 == "}") return cont();
      if (value == "@") return cont(expression, classBody);
    }
    function classfield(type3, value) {
      if (value == "!") return cont(classfield);
      if (value == "?") return cont(classfield);
      if (type3 == ":") return cont(typeexpr, maybeAssign);
      if (value == "=") return cont(expressionNoComma);
      var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }
    function afterExport(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }
      if (value == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }
      if (type3 == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type3, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }
      if (type3 == "variable") return pass(expressionNoComma, exportField);
    }
    function afterImport(type3) {
      if (type3 == "string") return cont();
      if (type3 == "(") return pass(expression);
      if (type3 == ".") return pass(maybeoperatorComma);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type3, value) {
      if (type3 == "{") return contCommasep(importSpec, "}");
      if (type3 == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type3) {
      if (type3 == ",") return cont(importSpec, maybeMoreImports);
    }
    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }
    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }
    function arrayLiteral(type3) {
      if (type3 == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }
    function enummember() {
      return pass(pattern, maybeAssign);
    }
    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }
    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)\$/.test(state.lastType) || state.lastType == "quasi" && /\\{\\s*\$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    }
    return {
      startState: function(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type2 == "comment") return style;
        state.lastType = type2 == "operator" && (content == "++" || content == "--") ? "incdec" : type2;
        return parseJS(state, style, type2, content, stream);
      },
      indent: function(state, textAfter) {
        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror2.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
        if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;
          else if (c != maybeelse && c != popcontext) break;
        }
        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))
          lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type3 = lexical.type, closing = firstChar == type3;
        if (type3 == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
        else if (type3 == "form" && firstChar == "{") return lexical.indented;
        else if (type3 == "form") return lexical.indented + indentUnit;
        else if (type3 == "stat")
          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
        else if (lexical.align) return lexical.column + (closing ? 0 : 1);
        else return lexical.indented + (closing ? 0 : indentUnit);
      },
      electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})\$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\\"\\"\`\`",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode,
      jsonMode,
      expressionAllowed,
      skipExpression: function(state) {
        parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
      }
    };
  });
  CodeMirror2.registerHelper("wordChars", "javascript", /[\\w\$]/);
  CodeMirror2.defineMIME("text/javascript", "javascript");
  CodeMirror2.defineMIME("text/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/javascript", "javascript");
  CodeMirror2.defineMIME("application/x-javascript", "javascript");
  CodeMirror2.defineMIME("application/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
  CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineSimpleMode("rust", {
    start: [
      // string and byte string
      { regex: /b?"/, token: "string", next: "string" },
      // raw string and raw byte string
      { regex: /b?r"/, token: "string", next: "string_raw" },
      { regex: /b?r#+"/, token: "string", next: "string_raw_hash" },
      // character
      { regex: /'(?:[^'\\\\]|\\\\(?:[nrt0'"]|x[\\da-fA-F]{2}|u\\{[\\da-fA-F]{6}\\}))'/, token: "string-2" },
      // byte
      { regex: /b'(?:[^']|\\\\(?:['\\\\nrt0]|x[\\da-fA-F]{2}))'/, token: "string-2" },
      {
        regex: /(?:(?:[0-9][0-9_]*)(?:(?:[Ee][+-]?[0-9_]+)|\\.[0-9_]+(?:[Ee][+-]?[0-9_]+)?)(?:f32|f64)?)|(?:0(?:b[01_]+|(?:o[0-7_]+)|(?:x[0-9a-fA-F_]+))|(?:[0-9][0-9_]*))(?:u8|u16|u32|u64|i8|i16|i32|i64|isize|usize)?/,
        token: "number"
      },
      { regex: /(let(?:\\s+mut)?|fn|enum|mod|struct|type|union)(\\s+)([a-zA-Z_][a-zA-Z0-9_]*)/, token: ["keyword", null, "def"] },
      { regex: /(?:abstract|alignof|as|async|await|box|break|continue|const|crate|do|dyn|else|enum|extern|fn|for|final|if|impl|in|loop|macro|match|mod|move|offsetof|override|priv|proc|pub|pure|ref|return|self|sizeof|static|struct|super|trait|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/, token: "keyword" },
      { regex: /\\b(?:Self|isize|usize|char|bool|u8|u16|u32|u64|f16|f32|f64|i8|i16|i32|i64|str|Option)\\b/, token: "atom" },
      { regex: /\\b(?:true|false|Some|None|Ok|Err)\\b/, token: "builtin" },
      {
        regex: /\\b(fn)(\\s+)([a-zA-Z_][a-zA-Z0-9_]*)/,
        token: ["keyword", null, "def"]
      },
      { regex: /#!?\\[.*\\]/, token: "meta" },
      { regex: /\\/\\/.*/, token: "comment" },
      { regex: /\\/\\*/, token: "comment", next: "comment" },
      { regex: /[-+\\/*=<>!]+/, token: "operator" },
      { regex: /[a-zA-Z_]\\w*!/, token: "variable-3" },
      { regex: /[a-zA-Z_]\\w*/, token: "variable" },
      { regex: /[\\{\\[\\(]/, indent: true },
      { regex: /[\\}\\]\\)]/, dedent: true }
    ],
    string: [
      { regex: /"/, token: "string", next: "start" },
      { regex: /(?:[^\\\\"]|\\\\(?:.|\$))*/, token: "string" }
    ],
    string_raw: [
      { regex: /"/, token: "string", next: "start" },
      { regex: /[^"]*/, token: "string" }
    ],
    string_raw_hash: [
      { regex: /"#+/, token: "string", next: "start" },
      { regex: /(?:[^"]|"(?!#))*/, token: "string" }
    ],
    comment: [
      { regex: /.*?\\*\\//, token: "comment", next: "start" },
      { regex: /.*/, token: "comment" }
    ],
    meta: {
      dontIndentStates: ["comment"],
      electricInput: /^\\s*\\}\$/,
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//",
      fold: "brace"
    }
  });
  CodeMirror2.defineMIME("text/x-rustsrc", "rust");
  CodeMirror2.defineMIME("text/rust", "rust");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function Bar(cls, orientation, scroll) {
    this.orientation = orientation;
    this.scroll = scroll;
    this.screen = this.total = this.size = 1;
    this.pos = 0;
    this.node = document.createElement("div");
    this.node.className = cls + "-" + orientation;
    this.inner = this.node.appendChild(document.createElement("div"));
    var self2 = this;
    CodeMirror2.on(this.inner, "mousedown", function(e) {
      if (e.which != 1) return;
      CodeMirror2.e_preventDefault(e);
      var axis = self2.orientation == "horizontal" ? "pageX" : "pageY";
      var start = e[axis], startpos = self2.pos;
      function done() {
        CodeMirror2.off(document, "mousemove", move);
        CodeMirror2.off(document, "mouseup", done);
      }
      function move(e2) {
        if (e2.which != 1) return done();
        self2.moveTo(startpos + (e2[axis] - start) * (self2.total / self2.size));
      }
      CodeMirror2.on(document, "mousemove", move);
      CodeMirror2.on(document, "mouseup", done);
    });
    CodeMirror2.on(this.node, "click", function(e) {
      CodeMirror2.e_preventDefault(e);
      var innerBox = self2.inner.getBoundingClientRect(), where;
      if (self2.orientation == "horizontal")
        where = e.clientX < innerBox.left ? -1 : e.clientX > innerBox.right ? 1 : 0;
      else
        where = e.clientY < innerBox.top ? -1 : e.clientY > innerBox.bottom ? 1 : 0;
      self2.moveTo(self2.pos + where * self2.screen);
    });
    function onWheel(e) {
      var moved = CodeMirror2.wheelEventPixels(e)[self2.orientation == "horizontal" ? "x" : "y"];
      var oldPos = self2.pos;
      self2.moveTo(self2.pos + moved);
      if (self2.pos != oldPos) CodeMirror2.e_preventDefault(e);
    }
    CodeMirror2.on(this.node, "mousewheel", onWheel);
    CodeMirror2.on(this.node, "DOMMouseScroll", onWheel);
  }
  Bar.prototype.setPos = function(pos, force) {
    if (pos < 0) pos = 0;
    if (pos > this.total - this.screen) pos = this.total - this.screen;
    if (!force && pos == this.pos) return false;
    this.pos = pos;
    this.inner.style[this.orientation == "horizontal" ? "left" : "top"] = pos * (this.size / this.total) + "px";
    return true;
  };
  Bar.prototype.moveTo = function(pos) {
    if (this.setPos(pos)) this.scroll(pos, this.orientation);
  };
  var minButtonSize = 10;
  Bar.prototype.update = function(scrollSize, clientSize, barSize) {
    var sizeChanged = this.screen != clientSize || this.total != scrollSize || this.size != barSize;
    if (sizeChanged) {
      this.screen = clientSize;
      this.total = scrollSize;
      this.size = barSize;
    }
    var buttonSize = this.screen * (this.size / this.total);
    if (buttonSize < minButtonSize) {
      this.size -= minButtonSize - buttonSize;
      buttonSize = minButtonSize;
    }
    this.inner.style[this.orientation == "horizontal" ? "width" : "height"] = buttonSize + "px";
    this.setPos(this.pos, sizeChanged);
  };
  function SimpleScrollbars(cls, place, scroll) {
    this.addClass = cls;
    this.horiz = new Bar(cls, "horizontal", scroll);
    place(this.horiz.node);
    this.vert = new Bar(cls, "vertical", scroll);
    place(this.vert.node);
    this.width = null;
  }
  SimpleScrollbars.prototype.update = function(measure) {
    if (this.width == null) {
      var style = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle;
      if (style) this.width = parseInt(style.height);
    }
    var width = this.width || 0;
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    this.vert.node.style.display = needsV ? "block" : "none";
    this.horiz.node.style.display = needsH ? "block" : "none";
    if (needsV) {
      this.vert.update(
        measure.scrollHeight,
        measure.clientHeight,
        measure.viewHeight - (needsH ? width : 0)
      );
      this.vert.node.style.bottom = needsH ? width + "px" : "0";
    }
    if (needsH) {
      this.horiz.update(
        measure.scrollWidth,
        measure.clientWidth,
        measure.viewWidth - (needsV ? width : 0) - measure.barLeft
      );
      this.horiz.node.style.right = needsV ? width + "px" : "0";
      this.horiz.node.style.left = measure.barLeft + "px";
    }
    return { right: needsV ? width : 0, bottom: needsH ? width : 0 };
  };
  SimpleScrollbars.prototype.setScrollTop = function(pos) {
    this.vert.setPos(pos);
  };
  SimpleScrollbars.prototype.setScrollLeft = function(pos) {
    this.horiz.setPos(pos);
  };
  SimpleScrollbars.prototype.clear = function() {
    var parent = this.horiz.node.parentNode;
    parent.removeChild(this.horiz.node);
    parent.removeChild(this.vert.node);
  };
  CodeMirror2.scrollbarModel.simple = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-simplescroll", place, scroll);
  };
  CodeMirror2.scrollbarModel.overlay = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-overlayscroll", place, scroll);
  };
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";
  CodeMirror2.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old == CodeMirror2.Init ? false : old;
    if (val == prev) return;
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });
  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }
  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }
  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
        continue;
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i2 = 0; i2 < active.length; i2++) {
        cm.addLineClass(active[i2], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i2], "background", BACK_CLASS);
        cm.addLineClass(active[i2], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }
  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos = CodeMirror2.Pos;
  var matching = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<",
    "‹": "›>",
    "›": "‹<",
    "«": "»>",
    "»": "«<"
    // TODO NOTE: added for arabic support
  };
  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\\]]/;
  }
  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null)
      afterCursor = /(^| )cm-fat-cursor(\$| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config);
    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
    if (found == null) return null;
    return {
      from: Pos(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  }
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 1e4;
    var maxScanLines = config && config.maxScanLines || 1e3;
    var stack = [];
    var re = bracketRegex(config);
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
          var match = matching[ch];
          if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);
          else if (!stack.length) return { pos: Pos(lineNo, pos), ch };
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }
  function matchBrackets(cm, autoclear, config) {
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config && config.highlightNonMatching;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));
      }
    }
    if (marks.length) {
      if (ie_lt8 && cm.state.focused) cm.focus();
      var clear2 = function() {
        cm.operation(function() {
          for (var i2 = 0; i2 < marks.length; i2++) marks[i2].clear();
        });
      };
      if (autoclear) setTimeout(clear2, 800);
      else return clear2;
    }
  }
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }
  function clearHighlighted(cm) {
    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
      cm.state.matchBrackets.currentlyHighlighted();
      cm.state.matchBrackets.currentlyHighlighted = null;
    }
  }
  CodeMirror2.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      cm.off("focus", doMatchBrackets);
      cm.off("blur", clearHighlighted);
      clearHighlighted(cm);
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
      cm.on("focus", doMatchBrackets);
      cm.on("blur", clearHighlighted);
    }
  });
  CodeMirror2.defineExtension("matchBrackets", function() {
    matchBrackets(this, true);
  });
  CodeMirror2.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? { strict: true } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }
    return findMatchingBracket(this, pos, config);
  });
  CodeMirror2.defineExtension("scanForBracket", function(pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var defaults = {
    pairs: \`()[]{}''‹›""«»\`,
    //TODO NOTE: MODIFIED to add ‹›  «»
    closeBefore: \`)]}'›"»:;>\`,
    //TODO NOTE: MODIFIED to add › »
    triples: "",
    explode: "[]{}"
  };
  var Pos = CodeMirror2.Pos;
  CodeMirror2.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"));
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });
  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }
  var keyMap = { Backspace: handleBackspace, Enter: handleEnter };
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i), key = "'" + ch + "'";
      if (!keyMap[key]) keyMap[key] = handler(ch);
    }
  }
  ensureBound(defaults.pairs + "\`");
  function handler(ch) {
    return function(cm) {
      return handleChar(cm, ch);
    };
  }
  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }
  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror2.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror2.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }
  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror2.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror2.Pass;
    }
    cm.operation(function() {
      var linesep = cm.lineSeparator() || "\\n";
      cm.replaceSelection(linesep + linesep, null);
      moveSel(cm, -1);
      ranges = cm.listSelections();
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var line = ranges[i2].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }
  function moveSel(cm, dir) {
    var newRanges = [], ranges = cm.listSelections(), primary = 0;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (range.head == cm.getCursor()) primary = i;
      var pos = range.head.ch || dir > 0 ? { line: range.head.line, ch: range.head.ch + dir } : { line: range.head.line - 1 };
      newRanges.push({ anchor: pos, head: pos });
    }
    cm.setSelections(newRanges, primary);
  }
  function contractSelection(sel) {
    var inverted = CodeMirror2.cmpPos(sel.anchor, sel.head) > 0;
    return {
      anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
      head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
    };
  }
  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror2.Pass;
    var closeBefore = getOption(conf, "closeBefore");
    var triples = getOption(conf, "triples");
    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;
    var type2;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], cur = range.head, curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur))
          curType = "both";
        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
          curType = "skipThree";
        else
          curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror2.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
        if (!CodeMirror2.isWordChar(next) && prev != ch && !CodeMirror2.isWordChar(prev)) curType = "both";
        else return CodeMirror2.Pass;
      } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror2.Pass;
      }
      if (!type2) type2 = curType;
      else if (type2 != curType) return CodeMirror2.Pass;
    }
    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function() {
      if (type2 == "skip") {
        moveSel(cm, 1);
      } else if (type2 == "skipThree") {
        moveSel(cm, 3);
      } else if (type2 == "surround") {
        var sels = cm.getSelections();
        for (var i2 = 0; i2 < sels.length; i2++)
          sels[i2] = left + sels[i2] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i2 = 0; i2 < sels.length; i2++)
          sels[i2] = contractSelection(sels[i2]);
        cm.setSelections(sels);
      } else if (type2 == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        moveSel(cm, -1);
      } else if (type2 == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        moveSel(cm, 1);
      }
    });
  }
  function charsAround(cm, pos) {
    var str = cm.getRange(
      Pos(pos.line, pos.ch - 1),
      Pos(pos.line, pos.ch + 1)
    );
    return str.length == 2 ? str : null;
  }
  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
    return /\\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)));
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function doFold(cm, pos, options, force) {
    if (options && options.call) {
      var finder = options;
      options = null;
    } else {
      var finder = getOption(cm, options, "rangeFinder");
    }
    if (typeof pos == "number") pos = CodeMirror2.Pos(pos, 0);
    var minSize = getOption(cm, options, "minFoldSize");
    function getRange(allowFolded) {
      var range2 = finder(cm, pos);
      if (!range2 || range2.to.line - range2.from.line < minSize) return null;
      if (force === "fold") return range2;
      var marks = cm.findMarksAt(range2.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold) {
          if (!allowFolded) return null;
          range2.cleared = true;
          marks[i].clear();
        }
      }
      return range2;
    }
    var range = getRange(true);
    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror2.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;
    var myWidget = makeWidget(cm, options, range);
    CodeMirror2.on(myWidget, "mousedown", function(e) {
      myRange.clear();
      CodeMirror2.e_preventDefault(e);
    });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: getOption(cm, options, "clearOnEnter"),
      __isFold: true
    });
    myRange.on("clear", function(from, to) {
      CodeMirror2.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror2.signal(cm, "fold", cm, range.from, range.to);
  }
  function makeWidget(cm, options, range) {
    var widget = getOption(cm, options, "widget");
    if (typeof widget == "function") {
      widget = widget(range.from, range.to);
    }
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    } else if (widget) {
      widget = widget.cloneNode(true);
    }
    return widget;
  }
  CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
    return function(cm, pos) {
      doFold(cm, pos, { rangeFinder, widget });
    };
  };
  CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
    doFold(this, pos, options, force);
  });
  CodeMirror2.defineExtension("isFolded", function(pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold) return true;
  });
  CodeMirror2.commands.toggleFold = function(cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror2.commands.fold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror2.commands.unfold = function(cm) {
    cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
  };
  CodeMirror2.commands.foldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
    });
  };
  CodeMirror2.commands.unfoldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
    });
  };
  CodeMirror2.registerHelper("fold", "combine", function() {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function(cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });
  CodeMirror2.registerHelper("fold", "auto", function(cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });
  var defaultOptions = {
    rangeFinder: CodeMirror2.fold.auto,
    widget: "↔",
    minFoldSize: 0,
    scanUp: false,
    clearOnEnter: true
  };
  CodeMirror2.defineOption("foldOptions", null);
  function getOption(cm, options, name) {
    if (options && options[name] !== void 0)
      return options[name];
    var editorOptions = cm.options.foldOptions;
    if (editorOptions && editorOptions[name] !== void 0)
      return editorOptions[name];
    return defaultOptions[name];
  }
  CodeMirror2.defineExtension("foldOption", function(options, name) {
    return getOption(this, options, name);
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"), require("./foldcode"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "./foldcode"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("changes", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", onChange);
      cm.off("optionChange", optionChange);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("changes", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", onChange);
      cm.on("optionChange", optionChange);
    }
  });
  var Pos = CodeMirror2.Pos;
  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }
  function parseOptions(opts2) {
    if (opts2 === true) opts2 = {};
    if (opts2.gutter == null) opts2.gutter = "CodeMirror-foldgutter";
    if (opts2.indicatorOpen == null) opts2.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts2.indicatorFolded == null) opts2.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts2;
  }
  function isFolded(cm, line) {
    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
    for (var i = 0; i < marks.length; ++i) {
      if (marks[i].__isFold) {
        var fromPos = marks[i].find(-1);
        if (fromPos && fromPos.line === line)
          return marks[i];
      }
    }
  }
  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec + " CodeMirror-guttermarker-subtle";
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }
  function updateFoldInfo(cm, from, to) {
    var opts2 = cm.state.foldGutter.options, cur = from - 1;
    var minSize = cm.foldOption(opts2, "minFoldSize");
    var func = cm.foldOption(opts2, "rangeFinder");
    var clsFolded = typeof opts2.indicatorFolded == "string" && classTest(opts2.indicatorFolded);
    var clsOpen = typeof opts2.indicatorOpen == "string" && classTest(opts2.indicatorOpen);
    cm.eachLine(from, to, function(line) {
      ++cur;
      var mark = null;
      var old = line.gutterMarkers;
      if (old) old = old[opts2.gutter];
      if (isFolded(cm, cur)) {
        if (clsFolded && old && clsFolded.test(old.className)) return;
        mark = marker(opts2.indicatorFolded);
      } else {
        var pos = Pos(cur, 0);
        var range = func && func(cm, pos);
        if (range && range.to.line - range.from.line >= minSize) {
          if (clsOpen && old && clsOpen.test(old.className)) return;
          mark = marker(opts2.indicatorOpen);
        }
      }
      if (!mark && !old) return;
      cm.setGutterMarker(line, opts2.gutter, mark);
    });
  }
  function classTest(cls) {
    return new RegExp("(^|\\\\s)" + cls + "(?:\$|\\\\s)\\\\s*");
  }
  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function() {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from;
    state.to = vp.to;
  }
  function onGutterClick(cm, line, gutter) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    if (gutter != opts2.gutter) return;
    var folded = isFolded(cm, line);
    if (folded) folded.clear();
    else cm.foldCode(Pos(line, 0), opts2);
  }
  function optionChange(cm, option) {
    if (option == "mode") onChange(cm);
  }
  function onChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      updateInViewport(cm);
    }, opts2.foldOnChangeTimeSpan || 600);
  }
  function onViewportChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function() {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts2.updateViewportTimeSpan || 400);
  }
  function onFold(cm, from) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
  CodeMirror2.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = { hint: getHints };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };
  CodeMirror2.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return;
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }
    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;
    CodeMirror2.signal(this, "startCompletion", this);
    completion.update(true);
  });
  CodeMirror2.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close();
  });
  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
    if (this.options.updateOnCursorActivity) {
      var self2 = this;
      cm.on("cursorActivity", this.activityFunc = function() {
        self2.cursorActivity();
      });
    }
  }
  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1e3 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      if (this.options.updateOnCursorActivity) {
        this.cm.off("cursorActivity", this.activityFunc);
      }
      if (this.widget && this.data) CodeMirror2.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror2.signal(this.cm, "endCompletion", this.cm);
    },
    active: function() {
      return this.cm.state.completionActive == this;
    },
    pick: function(data, i) {
      var completion = data.list[i], self2 = this;
      this.cm.operation(function() {
        if (completion.hint)
          completion.hint(self2.cm, data, completion);
        else
          self2.cm.replaceRange(
            getText(completion),
            completion.from || data.from,
            completion.to || data.to,
            "complete"
          );
        CodeMirror2.signal(data, "pick", completion);
        self2.cm.scrollIntoView();
      });
      if (this.options.closeOnPick) {
        this.close();
      }
    },
    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }
      var identStart = this.startPos;
      if (this.data) {
        identStart = this.data.from;
      }
      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self2 = this;
        this.debounce = requestAnimationFrame(function() {
          self2.update();
        });
        if (this.widget) this.widget.disable();
      }
    },
    update: function(first) {
      if (this.tick == null) return;
      var self2 = this, myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self2.tick == myTick) self2.finishUpdate(data, first);
      });
    },
    finishUpdate: function(data, first) {
      if (this.data) CodeMirror2.signal(this.data, "update");
      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget) this.widget.close();
      this.data = data;
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror2.signal(data, "shown");
        }
      }
    }
  };
  function parseOptions(cm, pos, options) {
    var editor2 = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor2) {
      for (var prop in editor2)
        if (editor2[prop] !== void 0) out[prop] = editor2[prop];
    }
    if (options) {
      for (var prop in options)
        if (options[prop] !== void 0) out[prop] = options[prop];
    }
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
    return out;
  }
  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }
  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {
        handle.moveFocus(-1);
      },
      Down: function() {
        handle.moveFocus(1);
      },
      PageUp: function() {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function() {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function() {
        handle.setFocus(0);
      },
      End: function() {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var mac = /Mac/.test(navigator.platform);
    if (mac) {
      baseMap["Ctrl-P"] = function() {
        handle.moveFocus(-1);
      };
      baseMap["Ctrl-N"] = function() {
        handle.moveFocus(1);
      };
    }
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key2, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) {
          return val(cm, handle);
        };
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key2] = bound;
    }
    if (custom) {
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    }
    var extra = completion.options.extraKeys;
    if (extra) {
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    }
    return ourMap;
  }
  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }
  function Widget(completion, data) {
    this.id = "cm-complete-" + Math.floor(Math.random(1e6));
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
    var hints = this.hints = ownerDocument.createElement("ul");
    hints.setAttribute("role", "listbox");
    hints.setAttribute("aria-expanded", "true");
    hints.id = this.id;
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (i == this.selectedHint) elt.setAttribute("aria-selected", "true");
      elt.id = this.id + "-" + i;
      elt.setAttribute("role", "option");
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }
    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
      offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
    }
    hints.style.left = left - offsetLeft + "px";
    hints.style.top = top - offsetTop + "px";
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    cm.getInputField().setAttribute("aria-autocomplete", "list");
    cm.getInputField().setAttribute("aria-owns", this.id);
    cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;
    var startScroll;
    setTimeout(function() {
      startScroll = cm.getScrollInfo();
    });
    var overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2;
      if (winH - box.top < spaceAbove) {
        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + "px";
        hints.style.top = (top = pos.top - height) + offsetTop + "px";
        below = false;
      } else {
        hints.style.height = winH - box.top - 2 + "px";
      }
    }
    var overlapX = box.right - winW;
    if (scrolls) overlapX += cm.display.nativeBarWidth;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px";
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function(n) {
        widget.changeActive(n);
      },
      menuSize: function() {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function() {
        completion.close();
      },
      pick: function() {
        widget.pick();
      },
      data
    }));
    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() {
        closingOnBlur = setTimeout(function() {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function() {
        clearTimeout(closingOnBlur);
      });
    }
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor2 = cm.getWrapperElement().getBoundingClientRect();
      if (!startScroll) startScroll = cm.getScrollInfo();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor2.top || point >= editor2.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left + startScroll.left - curScroll.left + "px";
    });
    CodeMirror2.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror2.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });
    CodeMirror2.on(hints, "mousedown", function() {
      setTimeout(function() {
        cm.focus();
      }, 20);
    });
    var selectedHintRange = this.getSelectedHintRange();
    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
      this.scrollToActive();
    }
    CodeMirror2.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }
  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var input = this.completion.cm.getInputField();
      input.removeAttribute("aria-activedescendant");
      input.removeAttribute("aria-owns");
      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },
    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function() {
        widget.picked = true;
      } };
      this.completion.cm.addKeyMap(this.keyMap);
    },
    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) {
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node.removeAttribute("aria-selected");
      }
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      node.setAttribute("aria-selected", "true");
      this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);
      this.scrollToActive();
      CodeMirror2.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },
    scrollToActive: function() {
      var selectedHintRange = this.getSelectedHintRange();
      var node1 = this.hints.childNodes[selectedHintRange.from];
      var node2 = this.hints.childNodes[selectedHintRange.to];
      var firstNode = this.hints.firstChild;
      if (node1.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
    },
    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },
    getSelectedHintRange: function() {
      var margin = this.completion.options.scrollMargin || 0;
      return {
        from: Math.max(0, this.selectedHint - margin),
        to: Math.min(this.data.list.length - 1, this.selectedHint + margin)
      };
    }
  };
  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers;
    var result = [];
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i]);
    return result;
  }
  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options);
    } else {
      var result = hint(cm, options);
      if (result && result.then) result.then(callback);
      else callback(result);
    }
  }
  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words;
    if (helpers.length) {
      var resolved = function(cm2, callback, options) {
        var app = applicableHelpers(cm2, helpers);
        function run2(i) {
          if (i == app.length) return callback(null);
          fetchHints(app[i], cm2, options, function(result) {
            if (result && result.list.length > 0) callback(result);
            else run2(i + 1);
          });
        }
        run2(0);
      };
      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm2) {
        return CodeMirror2.hint.fromList(cm2, { words });
      };
    } else if (CodeMirror2.hint.anyword) {
      return function(cm2, options) {
        return CodeMirror2.hint.anyword(cm2, options);
      };
    } else {
      return function() {
      };
    }
  }
  CodeMirror2.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });
  CodeMirror2.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var term, from = CodeMirror2.Pos(cur.line, token.start), to = cur;
    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }
    if (found.length) return { list: found, from, to };
  });
  CodeMirror2.commands.autocomplete = CodeMirror2.showHint;
  var defaultOptions = {
    hint: CodeMirror2.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\\s()\\[\\]{};:>,]/,
    closeOnPick: true,
    closeOnUnfocus: true,
    updateOnCursorActivity: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null,
    paddingForScrollbar: true,
    moveOnOverlap: true
  };
  CodeMirror2.defineOption("hintOptions", null);
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function bracketFolding(pairs) {
    return function(cm, start) {
      var line = start.line, lineText = cm.getLine(line);
      function findOpening(pair) {
        var tokenType;
        for (var at = start.ch, pass = 0; ; ) {
          var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);
          if (found2 == -1) {
            if (pass == 1) break;
            pass = 1;
            at = lineText.length;
            continue;
          }
          if (pass == 1 && found2 < start.ch) break;
          tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found2 + 1));
          if (!/^(comment|string)/.test(tokenType)) return { ch: found2 + 1, tokenType, pair };
          at = found2 - 1;
        }
      }
      function findRange(found2) {
        var count = 1, lastLine = cm.lastLine(), end, startCh = found2.ch, endCh;
        outer: for (var i2 = line; i2 <= lastLine; ++i2) {
          var text = cm.getLine(i2), pos = i2 == line ? startCh : 0;
          for (; ; ) {
            var nextOpen = text.indexOf(found2.pair[0], pos), nextClose = text.indexOf(found2.pair[1], pos);
            if (nextOpen < 0) nextOpen = text.length;
            if (nextClose < 0) nextClose = text.length;
            pos = Math.min(nextOpen, nextClose);
            if (pos == text.length) break;
            if (cm.getTokenTypeAt(CodeMirror2.Pos(i2, pos + 1)) == found2.tokenType) {
              if (pos == nextOpen) ++count;
              else if (!--count) {
                end = i2;
                endCh = pos;
                break outer;
              }
            }
            ++pos;
          }
        }
        if (end == null || line == end) return null;
        return {
          from: CodeMirror2.Pos(line, startCh),
          to: CodeMirror2.Pos(end, endCh)
        };
      }
      var found = [];
      for (var i = 0; i < pairs.length; i++) {
        var open = findOpening(pairs[i]);
        if (open) found.push(open);
      }
      found.sort(function(a, b) {
        return a.ch - b.ch;
      });
      for (var i = 0; i < found.length; i++) {
        var range = findRange(found[i]);
        if (range) return range;
      }
      return null;
    };
  }
  CodeMirror2.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));
  CodeMirror2.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));
  CodeMirror2.registerHelper("fold", "import", function(cm, start) {
    function hasImport(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
      if (!/\\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
      if (start2.type != "keyword" || start2.string != "import") return null;
      for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
        var text = cm.getLine(i), semi = text.indexOf(";");
        if (semi != -1) return { startCh: start2.end, end: CodeMirror2.Pos(i, semi) };
      }
    }
    var startLine = start.line, has = hasImport(startLine), prev;
    if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
      return null;
    for (var end = has.end; ; ) {
      var next = hasImport(end.line + 1);
      if (next == null) break;
      end = next.end;
    }
    return { from: cm.clipPos(CodeMirror2.Pos(startLine, has.startCh + 1)), to: end };
  });
  CodeMirror2.registerHelper("fold", "include", function(cm, start) {
    function hasInclude(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
      if (!/\\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
      if (start2.type == "meta" && start2.string.slice(0, 8) == "#include") return start2.start + 8;
    }
    var startLine = start.line, has = hasInclude(startLine);
    if (has == null || hasInclude(startLine - 1) != null) return null;
    for (var end = startLine; ; ) {
      var next = hasInclude(end + 1);
      if (next == null) break;
      ++end;
    }
    return {
      from: CodeMirror2.Pos(startLine, has + 1),
      to: cm.clipPos(CodeMirror2.Pos(end))
    };
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function lineIndent(cm, lineNo) {
    var text = cm.getLine(lineNo);
    var spaceTo = text.search(/\\S/);
    if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror2.Pos(lineNo, spaceTo + 1))))
      return -1;
    return CodeMirror2.countColumn(text, null, cm.getOption("tabSize"));
  }
  CodeMirror2.registerHelper("fold", "indent", function(cm, start) {
    var myIndent = lineIndent(cm, start.line);
    if (myIndent < 0) return;
    var lastLineInFold = null;
    for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
      var indent2 = lineIndent(cm, i);
      if (indent2 == -1) ;
      else if (indent2 > myIndent) {
        lastLineInFold = i;
      } else {
        break;
      }
    }
    if (lastLineInFold) return {
      from: CodeMirror2.Pos(start.line, cm.getLine(start.line).length),
      to: CodeMirror2.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
    };
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.registerGlobalHelper("fold", "comment", function(mode) {
    return mode.blockCommentStart && mode.blockCommentEnd;
  }, function(cm, start) {
    var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
    if (!startToken || !endToken) return;
    var line = start.line, lineText = cm.getLine(line);
    var startCh;
    for (var at = start.ch, pass = 0; ; ) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
      if (found == -1) {
        if (pass == 1) return;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) return;
      if (/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found + 1))) && (found == 0 || lineText.slice(found - endToken.length, found) == endToken || !/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found))))) {
        startCh = found + startToken.length;
        break;
      }
      at = found - 1;
    }
    var depth = 1, lastLine = cm.lastLine(), end, endCh;
    outer: for (var i = line; i <= lastLine; ++i) {
      var text = cm.getLine(i), pos = i == line ? startCh : 0;
      for (; ; ) {
        var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
        if (nextOpen < 0) nextOpen = text.length;
        if (nextClose < 0) nextClose = text.length;
        pos = Math.min(nextOpen, nextClose);
        if (pos == text.length) break;
        if (pos == nextOpen) ++depth;
        else if (!--depth) {
          end = i;
          endCh = pos;
          break outer;
        }
        ++pos;
      }
    }
    if (end == null || line == end && endCh == startCh) return;
    return {
      from: CodeMirror2.Pos(line, startCh),
      to: CodeMirror2.Pos(end, endCh)
    };
  });
});
const THEME_LABELS = {
  theme_ttcn: { ar: "فاتح ١", en: "TTCN" },
  theme_default: { ar: "فاتح ٢", en: "CodeMirror Default" },
  theme_solarized_light: { ar: "فاتح ٣", en: "Solarized (Light)" },
  theme_eclipse: { ar: "فاتح ٤", en: "Eclipse" },
  theme_midnight: { ar: "غامق ١", en: "Midnight" },
  theme_panda_syntax: { ar: "غامق ٢", en: "Panda Syntax" },
  theme_tomorrow_night_eighties: { ar: "غامق ٣", en: "Tommorrow Night Eighties" },
  theme_night: { ar: "غامق ٤", en: "Night" },
  theme_colorforth: { ar: "غامق ٥", en: "colorForth" },
  theme_monokai: { ar: "غامق ٦", en: "Monokai" },
  theme_the_matrix: { ar: "غامق ٧", en: "The Matrix" },
  theme_ayu_dark: { ar: "غامق ٨", en: "Ayu Dark" },
  theme_moxer: { ar: "غامق ٩", en: "Moxer" },
  theme_mbo: { ar: "غامق ١٠", en: "MBO" }
};
const INDEX_LABELS = {
  new_file: { ar: "ملف جديد", en: "New File" },
  new_proj: { ar: "مشروع جديد", en: "New Project" },
  open: { ar: "فتح", en: "Open" },
  open_file: { ar: "فتح ملف", en: "Open File" },
  open_proj: { ar: "فتح مشروع", en: "Open Project" },
  new: { ar: "جديد", en: "New" },
  save: { ar: "حفظ", en: "Save" },
  compile: { ar: "ترجمة", en: "Compile" },
  build: { ar: "بناء", en: "Build" },
  terminate: { ar: "إنهاء", en: "Terminate" },
  output_label: { ar: "المخرجات", en: "Output" },
  lang_label: { ar: "لغة المحرر", en: "Editor Langauge" },
  lang_ar: { ar: "العربية - Arabic", en: "Arabic - العربية" },
  lang_en: { ar: "الانجليزية - English", en: "English - الانجليزية" },
  س: { ar: "س", en: "س" },
  ...THEME_LABELS
};
const TOOLTIP_LABELS = {
  theme: { ar: "المظهر", en: "Theme" },
  run: { ar: "تشغيل", en: "Run" },
  srccode: { ar: "رِماز", en: "Code" },
  clear: { ar: "مسح", en: "Clear" }
};
function setLabels(LABELS, langId) {
  for (let [k, v2] of Object.entries(LABELS)) {
    let el = document.querySelector(\`#\${k}\`);
    if (el) {
      el.textContent = v2[langId];
    }
  }
}
function setTooltipLabels(LABELS, langId) {
  for (let [k, v2] of Object.entries(LABELS)) {
    let el = document.querySelector(\`#\${k}\`);
    if (el) {
      el.title = v2[langId];
    }
  }
}
class Err {
  msg;
  start_loc;
  end_loc;
  constructor(msg, start_loc, end_loc) {
    this.msg = msg;
    this.start_loc = start_loc;
    this.end_loc = end_loc;
  }
}
const SUPPORTED_GEN = [
  "js",
  "node",
  "react-native",
  "html",
  "css"
];
const AR_KEYWORD = {
  "باسم": "as",
  "صحيح": "true",
  "غير_صحيح": "false",
  "عندما": "when",
  "كرر": "for",
  "احضر": "use",
  "عرف": "let",
  "ثابت": "const",
  "دل": "fn",
  "نوع": "type",
  "تركيبة": "struct",
  "تعداد": "enum",
  "مستعار": "alias",
  "سمة": "trait",
  "اعد": "return",
  "نفذ": "do",
  "لا_شيء": "void"
};
const EN_KEYWORD = {
  "as": "باسم",
  "true": "صحيح",
  "false": "غير_صحيح",
  "when": "عندما",
  "for": "كرر",
  "use": "احضر",
  "let": "عرف",
  "const": "ثابت",
  "fn": "دل",
  "type": "نوع",
  "struct": "تركيبة",
  "enum": "تعداد",
  "alias": "مستعار",
  "trait": "سمة",
  "return": "اعد",
  "do": "نفذ",
  "void": "لا_شيء"
};
const MASHRIQ_DIGIT = ["٠", "١", "٢", "٣", "٤", "٥", "٦", "٧", "٨", "٩"];
const MAGHRIB_DIGIT\$2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
const TATWEEL = "ـ";
const ANY_LETTER = regexp("\\\\p{L}");
const ANY_NUM = regexp("\\\\p{N}");
function is_none(x) {
  return x == null;
}
function is_list\$2(x) {
  return x instanceof Array;
}
function contains\$2(list, el) {
  return list.includes(el);
}
function replace(array, i, v2) {
  array[i] = v2;
}
function is_empty(list) {
  return Array.isArray(list) && list.length === 0;
}
function to_str\$2(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function regexp(expr) {
  return new RegExp(expr, "u");
}
function pprint\$1(obj, indent2) {
  if (obj == null) {
    console.log("undefined");
  } else {
    {
      console.log(JSON.stringify(obj));
    }
  }
}
function panic\$2(v2) {
  throw new Error(v2);
}
function clone(obj) {
  return { ...obj };
}
function to_lowercase(str) {
  return str.toLowerCase();
}
class Loc {
  line;
  column;
  constructor(line, column) {
    this.line = line;
    this.column = column;
    return this;
  }
}
class Token {
  v;
  loc;
  constructor(v2, loc) {
    this.v = v2;
    this.loc = loc;
    return this;
  }
}
class Lexer {
  lang;
  code;
  start_loc;
  end_loc;
  tokens;
  errs;
  current_index;
  current;
  lookbehind;
  ignore_cmts_ws;
  init(lang2, code, ignore_cmts_ws) {
    this.lang = lang2;
    this.code = code;
    this.start_loc = new Loc(1, 1);
    this.end_loc = new Loc(1, 1);
    this.tokens = [];
    this.errs = [];
    this.current_index = -1;
    this.current = null;
    this.lookbehind = null;
    this.ignore_cmts_ws = ignore_cmts_ws;
  }
  run() {
    if (this.lang === "ar") {
      this.ar();
    } else if (this.lang === "en") {
      this.en();
    }
    this.start_loc = clone(this.end_loc);
    this.add_token("\$eof");
  }
  add_token(v2) {
    const tk = new Token(v2, clone(this.start_loc));
    this.tokens.push(tk);
  }
  next() {
    this.lookbehind = this.current;
    this.current_index += 1;
    const c = this.code[this.current_index];
    this.current = c;
    if (c === "\\n") {
      this.end_loc.line += 1;
      this.end_loc.column = 1;
    } else {
      this.end_loc.column += 1;
    }
    return this.current;
  }
  lookahead() {
    return this.code[this.current_index + 1];
  }
  skip(count) {
    while (count > 0) {
      this.next();
      count -= 1;
    }
  }
  insert_err(msg) {
    const err = new Err(msg, clone(this.start_loc), clone(this.end_loc));
    this.errs.push(err);
  }
  last_token() {
    return this.tokens[this.tokens.length - 1];
  }
  skip_invalid_num_or_id() {
    while (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
      this.skip(1);
    }
  }
  expect_tatweel() {
    return this.lookahead() === TATWEEL;
  }
  expect_nl_behind() {
    return this.lookbehind === "\\n";
  }
  expect_none_behind() {
    return is_none(this.lookbehind);
  }
  expect_none_ahead() {
    return is_none(this.lookahead());
  }
  expect_ws_behind() {
    return this.lookbehind === "\\n" || this.lookbehind === " " || this.lookbehind === "\\r" || this.lookbehind === "	";
  }
  expect_space_ahead() {
    return this.lookahead() === " " || this.lookahead() === "	";
  }
  expect_ws_ahead() {
    return this.lookahead() === "\\n" || this.lookahead() === " " || this.lookahead() === "\\r" || this.lookahead() === "	";
  }
  expect_nl_ahead() {
    return this.lookahead() === "\\n";
  }
  expect_separator_behind() {
    return this.lookbehind === "," || this.lookbehind === ";" || this.lookbehind === ";;" || this.lookbehind === ":" || this.lookbehind === "(" || this.lookbehind === "[" || this.lookbehind === "{" || this.lookbehind === "<";
  }
  expect_separator_ahead() {
    return this.lookahead() === "," || this.lookahead() === ";" || this.lookahead() === ";;" || this.lookahead() === ":" || this.lookahead() === ")" || this.lookahead() === "]" || this.lookahead() === "}" || this.lookahead() === ">";
  }
  expect_open_bracket() {
    return this.lookahead() === "[";
  }
  expect_open_paren() {
    return this.lookahead() === "(";
  }
  expect_letter() {
    if (this.lookahead()) {
      return this.lookahead().match(ANY_LETTER);
    }
  }
  expect_num() {
    return this.lookahead().match(ANY_NUM);
  }
  expect_underscore() {
    return this.lookahead() === "_";
  }
  expect_eof() {
    return is_none(this.lookahead());
  }
  expect_eol() {
    return this.lookahead() === "\\n" || this.lookahead() === "\\r" || this.expect_eof();
  }
  multi_comment() {
    if ("-" === this.lookahead()) {
      let v2 = "";
      const levels = [];
      while (!this.expect_eof()) {
        if ("{" === this.current && "-" === this.lookahead()) {
          v2 += this.next() + this.next();
          levels.push(clone(this.end_loc));
        } else if ("-" === this.current && "}" === this.lookahead()) {
          if (levels.length > 1) {
            v2 += this.next() + this.next();
            levels.pop();
          } else {
            v2 += this.next();
            levels.pop();
            break;
          }
        } else {
          v2 += this.next();
        }
      }
      const loc = levels.pop();
      if (loc) {
        this.start_loc = clone(loc);
        this.insert_err("unclosed comment");
      }
      if (!this.ignore_cmts_ws) {
        this.add_token(["--", v2]);
      }
      return true;
    }
  }
  ar_escape_char() {
    let sym = this.current;
    if ("٪" === sym) {
      let c = this.next();
      switch (c) {
        case "(":
          c = this.next();
          switch (c) {
            case "س":
              c = "\\n";
              break;
            case "ر":
              c = "\\r";
              break;
            case "ج":
              c = "	";
              break;
            case "‹":
              c = "‹";
              break;
            case "›":
              c = "›";
              break;
            case "«":
              c = "«";
              break;
            case "»":
              c = "»";
              break;
          }
          if (this.next() !== ")") {
            this.insert_err("invalid_escape_character: " + c);
          }
          break;
        case "٪":
          c = "٪";
          break;
        case "{":
          c = "\${";
          break;
        default: {
          this.insert_err("invalid escape character: " + c);
        }
      }
      return c;
    } else {
      return this.current;
    }
  }
  en_escape_char() {
    const sym = this.current;
    if ("%" === sym) {
      let c = this.next();
      switch (c) {
        case "n":
          c = "\\n";
          break;
        case "r":
          c = "\\r";
          break;
        case "t":
          c = "	";
          break;
        case "'":
          c = "'";
          break;
        case '"':
          c = '"';
          break;
        case "%":
          c = "%";
          break;
        case "{":
          c = "\${";
          break;
        default:
          {
            this.insert_err("invalid escape character: " + c);
          }
          break;
      }
      return c;
    } else {
      return this.current;
    }
  }
  enclosed_val(sym) {
    let v2 = "";
    while (!this.expect_eof()) {
      this.next();
      if (sym === this.current) {
        break;
      }
      if (this.expect_eol()) {
        this.insert_err("unclosed literal, expecting: " + sym);
        break;
      }
      if (this.lang === "ar") {
        v2 += this.ar_escape_char();
      } else {
        v2 += this.en_escape_char();
      }
    }
    return v2;
  }
  ar_str() {
    if ("«" === this.lookahead()) {
      this.ar_multi_str();
    } else {
      this.add_token(["str", this.enclosed_val("»")]);
    }
  }
  en_str() {
    if ('"' === this.lookahead()) {
      this.en_multi_str();
    } else {
      this.add_token(["str", this.enclosed_val("'")]);
    }
  }
  multi_str(sym) {
    let c = "";
    let v2 = "";
    while (!this.expect_eof()) {
      this.next();
      if (this.expect_eof()) {
        this.insert_err("unclosed multiline String literal, expecting " + sym);
        break;
      }
      if (sym === this.current && sym === this.lookahead()) {
        this.skip(1);
        if (this.lookahead() === sym) {
          this.skip(1);
          this.add_token(["str", v2]);
          break;
        } else {
          c += sym + sym;
        }
      } else {
        if (this.lang === "ar") {
          v2 += this.ar_escape_char();
        } else {
          v2 += this.en_escape_char();
        }
        v2 += c;
      }
    }
  }
  ar_multi_str(sym) {
    this.skip(1);
    if ("«" === this.lookahead()) {
      this.skip(1);
      this.multi_str("»");
    } else {
      this.add_token(["str", ""]);
    }
  }
  en_multi_str(sym) {
    this.skip(1);
    if ('"' === this.lookahead()) {
      this.skip(1);
      this.multi_str('"');
    } else {
      this.add_token(["str", ""]);
    }
  }
  equal() {
    const sym = [];
    while ("=" === this.lookahead()) {
      sym.push(this.next());
    }
    if (sym.length === 0) {
      this.add_token("=");
    } else if (sym.length === 1) {
      this.add_token("==");
    } else if (sym.length > 1) {
      if (!this.ignore_cmts_ws) {
        this.add_token(["===", sym.length + 1]);
      }
    } else {
      return false;
    }
    return true;
  }
  thick_arrow() {
    if (">" === this.lookahead()) {
      this.next();
      this.add_token("=>");
      return true;
    }
  }
  add_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("+=");
      return true;
    }
  }
  concat() {
    if ("+" === this.lookahead()) {
      this.next();
      this.add_token("++");
      return true;
    }
  }
  add() {
    this.add_token("+");
    return true;
  }
  sub_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("-=");
      return true;
    }
  }
  thin_arrow() {
    if (">" === this.lookahead()) {
      this.next();
      this.add_token("->");
      return true;
    }
  }
  dash() {
    const sym = [];
    while ("-" === this.lookahead()) {
      sym.push(this.next());
    }
    if (sym.length === 0) {
      this.add_token("-");
    } else if (sym.length > 1) {
      if (!this.ignore_cmts_ws) {
        this.add_token(["---", sym.length + 1]);
      }
    } else {
      return false;
    }
    return true;
  }
  tilde() {
    if ("~" === this.lookahead()) {
      this.next();
      this.add_token("~");
      return true;
    }
  }
  mul_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("*=");
      return true;
    }
  }
  mul() {
    this.add_token("*");
    return true;
  }
  asterisk() {
    let sym = "*";
    while ("*" === this.lookahead()) {
      sym += this.next();
    }
    if (sym.length === 1) {
      this.mul();
    } else {
      return false;
    }
    return true;
  }
  ar_div_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("\\\\=");
      return true;
    }
  }
  div_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("/=");
      return true;
    }
  }
  comment() {
    if ("-" === this.lookahead()) {
      let v2 = "";
      while (!this.expect_eof()) {
        if (this.expect_eol()) {
          break;
        } else {
          v2 += this.next();
        }
      }
      if (!this.ignore_cmts_ws) {
        this.add_token(["--", v2]);
      }
      return true;
    }
  }
  ar_div() {
    this.add_token("\\\\");
    return true;
  }
  div() {
    this.add_token("/");
    return true;
  }
  ne() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("!=");
      return true;
    }
  }
  exclamation() {
    this.add_token("!");
    return true;
  }
  ge() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token(">=");
      return true;
    }
  }
  gt() {
    this.add_token(">");
    return true;
  }
  le() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("<=");
      return true;
    }
  }
  lt() {
    this.add_token("<");
    return true;
  }
  and() {
    if (this.lookahead() === "&") {
      this.skip(1);
      this.add_token("&&");
      return true;
    } else {
      this.add_token("&");
      return true;
    }
  }
  or_listpipe() {
    if (this.lookahead() === "|") {
      this.skip(1);
      if (this.lookahead() === ">") {
        this.skip(1);
        this.add_token("||>");
        return true;
      }
      this.add_token("||");
      return true;
    }
  }
  pipe() {
    if (this.lookahead() === ">") {
      this.skip(1);
      this.add_token("|>");
      return true;
    }
  }
  bar() {
    this.add_token("|");
    return true;
  }
  mashriq_float() {
    if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
      v = this.current + this.mashriq_fract();
      this.add_token(["float", v]);
    } else {
      this.insert_err("ill-formed floating point number");
    }
  }
  maghrib_float() {
    if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
      v = this.current + this.maghrib_fract();
      this.add_token(["float", v]);
      return true;
    }
  }
  dots() {
    if ("." === this.lookahead()) {
      this.skip(1);
      if ("." === this.lookahead()) {
        this.skip(1);
        this.add_token("...");
      } else {
        this.add_token("..");
      }
      return true;
    }
  }
  dot() {
    this.add_token(".");
    return true;
  }
  trailing() {
    if (this.lookahead() === ">") {
      this.skip(1);
      this.add_token(":>");
      return true;
    }
  }
  decl() {
    if (this.lookahead() === "=") {
      this.skip(1);
      this.add_token(":=");
      return true;
    }
  }
  dcolon() {
    if (this.lookahead() === ":") {
      this.skip(1);
      if (this.lookahead() === "=") {
        this.skip(1);
        this.add_token("::=");
      } else {
        this.add_token("::");
      }
      return true;
    }
  }
  colon() {
    this.add_token(":");
    return true;
  }
  ar_semicolon() {
    this.add_token(";");
    return true;
  }
  en_semicolon() {
    this.add_token(";");
    return true;
  }
  mashriq_num() {
    let v2 = this.current;
    while (true) {
      if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        v2 += this.next();
      } else if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        this.insert_err("you can either use Mashriq digits (٠ - ٩) or Maghrib digits (0 - 9) but not a mix: " + this.current);
        this.skip_invalid_num_or_id();
      } else if ("," === this.lookahead()) {
        v2 += this.next();
        v2 += this.maghrib_fract();
      } else {
        break;
      }
      if (this.expect_eof()) {
        break;
      }
    }
    if (this.is_float) {
      this.add_token(["float", v2]);
    } else {
      this.add_token(["int", v2]);
    }
  }
  maghrib_num() {
    let v2 = this.current;
    let is_float = false;
    while (true) {
      if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        v2 += this.next();
      } else if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        this.insert_err("you can either use Eastern Arabic digits (٠ - ٩) or Western (0 - 9) but not a mix: " + this.current);
        this.skip_invalid_num_or_id();
      } else if ("." === this.lookahead()) {
        v2 += this.next();
        is_float = true;
        v2 += this.maghrib_fract();
      } else {
        break;
      }
      if (this.expect_eof()) {
        break;
      }
    }
    if (is_float) {
      this.add_token(["float", v2]);
    } else {
      this.add_token(["int", v2]);
    }
  }
  ar_id() {
    let v2 = this.current;
    while (!this.expect_eof()) {
      if (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
        if (this.expect_tatweel()) {
          this.skip(1);
        } else {
          v2 += this.next();
        }
      } else {
        break;
      }
    }
    if (AR_KEYWORD[v2]) {
      this.add_token(["key", AR_KEYWORD[v2]]);
    } else {
      this.add_token(["id", v2]);
    }
  }
  en_id() {
    let v2 = this.current;
    while (!this.expect_eof()) {
      if (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
        v2 += this.next();
      } else {
        break;
      }
    }
    if (EN_KEYWORD[v2]) {
      this.add_token(["key", v2]);
    } else {
      this.add_token(["id", v2]);
    }
  }
  mashriq_fract() {
    let v2 = "";
    while (!this.expect_eof()) {
      if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        v2 += this.next();
      } else {
        break;
      }
    }
    return v2;
  }
  maghrib_float() {
    if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
      const v2 = this.current + this.maghrib_fract();
      this.add_token(["float", v2]);
      return true;
    }
  }
  maghrib_fract() {
    let v2 = "";
    while (!this.expect_eof()) {
      if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        v2 += this.next();
      } else {
        break;
      }
    }
    return v2;
  }
  new_line() {
    let count = 1;
    while (true) {
      if (this.lookahead() === "\\n") {
        this.skip(1);
        count += 1;
      } else {
        if (this.last_token() && this.last_token().v !== "\\n") {
          this.add_token(["\\n", count]);
        }
        break;
      }
    }
  }
  ar() {
    while (!this.expect_eof()) {
      this.start_loc = clone(this.end_loc);
      const c = this.next();
      switch (c) {
        case "؟":
          this.add_token("?");
          break;
        case "٪":
          this.add_token("%");
          break;
        case ",":
          this.mashriq_float();
          break;
        case ".":
          this.maghrib_float() || this.tdot() || this.dots() || this.dot();
          break;
        case "،":
          this.add_token(",");
          break;
        case "×":
          this.mul_asgmt() || this.mul();
          break;
        case "*":
          this.mul_asgmt() || this.asterisk();
          break;
        case "÷":
        case "/":
          this.div_asgmt() || this.div();
          break;
        case "\\\\":
          this.ar_div_asgmt() || this.ar_div();
          break;
        case "؛":
          this.ar_semicolon();
          break;
        case "«":
          this.ar_str();
          break;
        default: {
          if (contains\$2(MASHRIQ_DIGIT, c)) {
            this.mashriq_num();
          } else if (contains\$2(MAGHRIB_DIGIT\$2, c)) {
            this.maghrib_num();
          } else {
            if (c === "_" || c.match(ANY_LETTER)) {
              this.ar_id();
            } else {
              this.common(c);
            }
          }
        }
      }
    }
  }
  en() {
    while (!this.expect_eof()) {
      this.start_loc = clone(this.end_loc);
      const c = this.next();
      switch (c) {
        case "?":
          this.add_token("?");
          break;
        case "%":
          this.add_token("%");
          break;
        case ".":
          this.maghrib_float() || this.ddot() || this.dot();
          break;
        case ",":
          this.add_token(",");
          break;
        case "*":
          this.mul_asgmt() || this.asterisk();
          break;
        case "/":
          this.div_asgmt() || this.div();
          break;
        case ";":
          this.en_semicolon();
          break;
        case "'":
          this.en_str();
          break;
        default: {
          if (contains\$2(MAGHRIB_DIGIT\$2, c)) {
            this.maghrib_num();
          } else if (contains\$2(MASHRIQ_DIGIT, c)) {
            this.insert_err("only English Numerals are allowed in English source files: " + this.current);
            this.skip_invalid_num_or_id();
          } else {
            if (c === "_" || c.match(ANY_LETTER)) {
              this.en_id();
            } else {
              this.common(c);
            }
          }
        }
      }
    }
  }
  common(c) {
    switch (c) {
      case "\\n":
        this.new_line();
        break;
      case "\\r":
      case "	":
      case " ":
        {
          if (!this.ignore_cmts_ws) {
            this.add_token(c);
          }
        }
        break;
      case "&":
        this.and();
        break;
      case "|":
        this.pipe() || this.or_listpipe() || this.bar();
        break;
      case "+":
        this.add_asgmt() || this.concat() || this.add();
        break;
      case "-":
        this.comment() || this.sub_asgmt() || this.thin_arrow() || this.dash();
        break;
      case "~":
        this.tilde();
        break;
      case "^":
        this.add_token("^");
        break;
      case "=":
        this.thick_arrow() || this.equal();
        break;
      case "!":
        this.ne() || this.exclamation();
        break;
      case ">":
        this.ge() || this.gt();
        break;
      case "<":
        this.le() || this.lt();
        break;
      case ":":
        this.trailing() || this.decl() || this.dcolon() || this.colon();
        break;
      case "\`":
        this.transl();
        break;
      case "@":
        this.add_token("@");
        break;
      case "\$":
        this.add_token("\$");
        break;
      case "[":
        this.add_token("[");
        break;
      case "]":
        this.add_token("]");
        break;
      case "(":
        this.add_token("(");
        break;
      case ")":
        this.add_token(")");
        break;
      case "{":
        this.multi_comment() || this.add_token("{");
        break;
      case "}":
        this.add_token("}");
        break;
      default:
        this.insert_err("unrecognized character: " + this.current);
    }
  }
}
class Symtab {
  /*tmp*/
  fns;
  /*tmp*/
  structs;
  /*tmp*/
  receivers;
  root;
  stack;
  current;
  constructor() {
    this.fns = [];
    this.structs = [];
    this.enums = [];
    this.receivers = {};
    this.root = new Table(null);
    this.stack = [];
    this.stack.push(this.root);
    this.current = this.root;
  }
  /*tmp*/
  insert_fn(fn) {
    this.fns.push(fn);
  }
  /*tmp*/
  insert_struct(struct) {
    this.structs.push(struct);
  }
  /*tmp*/
  insert_enum(_enum) {
    this.enums.push(_enum);
  }
  /*tmp*/
  insert_receiver(id2, fns) {
    if (!this.receivers[id2]) {
      this.receivers[id2] = _fns;
    } else {
      this.receivers[id2] = [...this.receivers[id2], ..._fns];
    }
  }
  begin_scope() {
    const table = new Table(this.current);
    const entry = new Entry("", "table", { table });
    this.current.insert(entry);
    this.stack.push(table);
    this.current = this.stack[this.stack.length - 1];
    return entry;
  }
  end_scope() {
    this.current = this.stack.pop();
    return this.current;
  }
  insert_fn(id2, arity, rtype) {
    const entry = new Entry(id2, "fn", { arity, rtype });
    this.current.insert(entry);
    return entry;
  }
  insert_type(id2, fields) {
    const entry = new Entry(id2, "t", { fields });
    this.current.insert(entry);
    return entry;
  }
  insert_const(id2, t) {
    const entry = new Entry(id2, "const", { t });
    this.current.insert(entry);
    return entry;
  }
  insert_var(id2, t) {
    const entry = new Entry(id2, "var", { t });
    this.current.insert(entry);
    return entry;
  }
  insert_ref(id2) {
    const entry = new Entry(id2, "ref", {});
    this.current.insert(entry);
    return entry;
  }
}
class Table {
  parent;
  entries;
  inner_scope;
  constructor(parent) {
    this.parent = parent;
    this.entries = [];
    this.inner_scope = [];
  }
  insert(entry) {
    this.entries.push(entry);
  }
}
class Entry {
  id;
  t;
  attrs;
  constructor(id2, t, attrs) {
    this.id = id2;
    this.t = t;
    this.attrs = attrs;
  }
}
class Node {
  id;
  t;
  v;
  constructor(id2, t, v2) {
    this.id = id2, this.t = t, this.v = v2;
  }
}
class Type {
  t;
  o;
  constructor(t, o) {
    this.t = t;
    this.o = o;
  }
}
class Struct {
  name;
  fields;
  constructor(name, fields) {
    this.name = name;
    this.fields = fields;
  }
}
class Enum {
  name;
  variants;
  constructor(name, variants) {
    this.name = name;
    this.variants = variants;
  }
}
class TypeTempl {
  t;
  ts;
  o;
  constructor(t, ts, o) {
    this.t = t;
    this.ts = ts;
    this.o = o;
  }
}
class EnumPat {
  name;
  variant;
  constructor(name, variant) {
    this.name = name;
    this.variant = variant;
  }
}
class Uni {
  opr;
  op;
  constructor(opr, op) {
    this.opr = opr;
    this.op = op;
  }
}
class Bin {
  lopr;
  op;
  ropr;
  constructor(lopr, op, ropr) {
    this.lopr = lopr;
    this.op = op;
    this.ropr = ropr;
  }
}
class Method {
  t;
  fn;
  constructor(t, fn) {
    this.t = t;
    this.fn = fn;
  }
}
class Trait {
  id;
  fns;
  sigs;
  constructor(id2, fns, sigs) {
    this.id = id2;
    this.fns = fns;
    this.sigs = sigs;
  }
}
class Fn {
  name;
  params;
  ret_types;
  body;
  constructor(name, params2, ret_types, body) {
    this.name = name;
    this.params = params2;
    this.ret_types = ret_types;
    this.body = body;
  }
}
class FnSig {
  name;
  params;
  ret_types;
  constructor(name, params2, ret_types) {
    this.name = name;
    this.params = params2;
    this.ret_types = ret_types;
  }
}
class FnParam {
  _pat;
  t;
  constructor(_pat2, t) {
    this._pat = _pat2;
    this.t = t;
  }
}
class TrailingClosure {
  label;
  fn;
  constructor(label, fn) {
    this.label = label;
    this.fn = fn;
  }
}
class FnCall {
  id;
  args;
  trailing;
  constructor(id2, args, trailing) {
    this.id = id2;
    this.args = args;
    this.trailing = trailing;
  }
}
class Field {
  id;
  t;
  implicit;
  constructor(id2, t, implicit) {
    this.id = id2;
    this.t = t;
    this.implicit = implicit;
  }
}
class FieldAsgmt {
  id;
  expr;
  constructor(id2, expr) {
    this.id = id2;
    this.expr = expr;
  }
}
class AnonymousMethod {
  id;
  expr;
  constructor(stmts) {
    this.stmts = stmts;
  }
}
class StructLEl {
  k;
  v;
  constructor(k, v2) {
    this.k = k;
    this.v = v2;
  }
}
class Asgmt {
  lhs;
  t;
  rhs;
  constructor(lhs, t, rhs) {
    this.lhs = lhs;
    this.t = t;
    this.rhs = rhs;
  }
}
class ForInf {
  body;
  constructor(body) {
    this.body = body;
  }
}
class ForCond {
  expr;
  body;
  constructor(expr, body) {
    this.expr = expr;
    this.body = body;
  }
}
class ForIn {
  pat;
  expr;
  body;
  constructor(pat, expr, body) {
    this.pat = pat;
    this.expr = expr;
    this.body = body;
  }
}
class When {
  expr;
  arms;
  constructor(expr, arms) {
    this.expr = expr;
    this.arms = arms;
  }
}
class WhenArm {
  pats;
  expr;
  constructor(pats, expr) {
    this.pats = pats;
    this.expr = expr;
  }
}
const BIN_OP = ["+", "-", "*", "/", "[", "~=", "=>", "++", "::", ":=", "=", "+=", "-=", "*=", "/=", "|=", "&=", "==", "!=", ">", ">=", "<", "<=", "|", "||", "|>", "||>", ":>", "&", "&&", ".", ".."];
const PREFIX_UNI_OP = ["...", ".", "!", "not", "-", "+"];
const POSTFIX_UNI_OP = ["?", "!", "%"];
const BIN_R_ASSOC = ["=", ":", ":=", "~=", "+=", "-=", "*=", "/=", "÷=", "&=", "&&=", "|=", "||="];
class Parser {
  tokens;
  current_index;
  skipped_new_line;
  current;
  ast;
  symtab;
  attrs;
  errs;
  init(tokens) {
    this.tokens = tokens;
    this.current_index = -1;
    this.skipped_new_line = false;
    this.current = null;
    this.ast = [];
    this.symtab = new Symtab();
    this.attrs = [];
    this.errs = [];
  }
  run() {
    this.next();
    while (!this.is_eof()) {
      if (!this.maybe_use()) {
        break;
      }
    }
    while (!this.is_eof()) {
      let parsed = this.maybe_global_const();
      if (!parsed) {
        this.maybe_attrs();
        this.maybe_modifier();
        parsed = this.maybe_global_fn() || this.maybe_struct() || this.maybe_enum() || this.maybe_trait() || this.maybe_impl();
      }
      if (!parsed) {
        panic\$2("invalid syntax: " + to_str\$2(this.current));
      }
    }
  }
  next(nl) {
    this.current_index += 1;
    const tk = this.tokens[this.current_index];
    this.current = tk;
    if (tk.v[0] === "\\n") {
      this.skipped_new_line = true;
      this.next(true);
    } else {
      if (!nl) {
        this.skipped_new_line = false;
      }
    }
    return this.current;
  }
  backtrack() {
    this.current_index -= 1;
    const tk = this.tokens[this.current_index];
    this.current = tk;
    if (tk.v[0] === "\\n") {
      this.backtrack();
    }
  }
  skip() {
    return this.next();
  }
  lookahead() {
    return this.lookahead_n(1);
  }
  lookahead_n(n) {
    let j = this.current_index;
    while (n > 0) {
      j += 1;
      while (true) {
        const tk = this.tokens[j];
        let nl;
        if (tk) {
          nl = tk.v[0] === "\\n";
        }
        if (nl) {
          j += 1;
        } else {
          break;
        }
      }
      n -= 1;
    }
    return this.tokens[j];
  }
  lookahead_ws() {
    const i = this.current_index + 1;
    return this.tokens[i];
  }
  is_eof() {
    return this.current.v === "\$eof";
  }
  is_newline() {
    return this.skipped_new_line;
  }
  is_asterisk() {
    return this.current.v === "*";
  }
  is_at() {
    return this.current.v === "@";
  }
  is_asgmt() {
    return this.current.v === "=";
  }
  is_hash() {
    return this.current.v === "--";
  }
  is_percent() {
    return this.current.v === "%";
  }
  is_dpercent() {
    return this.current.v === "%%";
  }
  is_behind_none() {
    return is_none(this.lookbehind);
  }
  is_behind_nl() {
    return this.lookbehind === "\\n";
  }
  is_dot() {
    return this.current.v === ".";
  }
  is_double_dot() {
    return this.current.v === "..";
  }
  is_tripple_dot() {
    return this.current.v === "...";
  }
  is_colon() {
    return this.current.v === ":";
  }
  is_dplus() {
    return this.current.v === "++";
  }
  is_dcolon() {
    return this.current.v === "::";
  }
  is_caret() {
    return this.current.v === "^";
  }
  is_semicolon() {
    return this.current.v === ";";
  }
  is_comma() {
    return this.current.v === ",";
  }
  is_backtick() {
    return this.current.v === "\`";
  }
  is_tbacktick() {
    return this.current.v[0] === "\`\`\`";
  }
  is_underscore() {
    return this.is_id() && this.current.v[1] === "_";
  }
  is_plus() {
    return this.current.v === "+";
  }
  is_minus() {
    return this.current.v === "-";
  }
  is_exclamation() {
    return this.current.v === "!";
  }
  is_question() {
    return this.current.v === "?";
  }
  is_bar() {
    return this.current.v === "|";
  }
  is_thin_arrow() {
    return this.current.v === "->";
  }
  is_thick_arrow() {
    return this.current.v === "=>";
  }
  is_tilde() {
    return this.current.v === "~";
  }
  is_void() {
    return this.is_keyword("void");
  }
  is_or() {
    return this.is_keyword("or");
  }
  is_and() {
    return this.is_keyword("and");
  }
  is_not() {
    return this.is_keyword("not");
  }
  is_use() {
    return this.is_keyword("use");
  }
  is_let() {
    return this.is_keyword("let");
  }
  is_if_let() {
    return this.is_keyword("if_let");
  }
  is_const() {
    return this.is_keyword("const");
  }
  is_var() {
    return this.is_keyword("var");
  }
  is_then() {
    return this.is_keyword("then");
  }
  is_do() {
    return this.is_keyword("do");
  }
  is_end() {
    return this.is_keyword("end");
  }
  is_fn() {
    return this.is_keyword("fn");
  }
  is_alias() {
    return this.is_keyword("alias");
  }
  is_typedef() {
    return this.is_keyword("type");
  }
  is_struct() {
    return this.is_keyword("struct");
  }
  is_enum() {
    return this.is_keyword("enum");
  }
  is_trait() {
    return this.is_keyword("trait");
  }
  is_open_paren() {
    return this.current.v === "(";
  }
  is_close_paren() {
    return this.current.v === ")";
  }
  is_open_curly() {
    return this.current.v === "{";
  }
  is_close_curly() {
    return this.current.v === "}";
  }
  is_open_bracket() {
    return this.current.v === "[";
  }
  is_close_bracket() {
    return this.current.v === "]";
  }
  is_open_angle() {
    return this.current.v === "<";
  }
  is_close_angle() {
    return this.current.v === ">";
  }
  is_double_close_angle() {
    return this.current.v === ">>";
  }
  is_if() {
    return this.is_keyword("if");
  }
  is_else() {
    return this.is_keyword("else");
  }
  is_ret() {
    return this.is_keyword("return");
  }
  is_break() {
    return this.is_keyword("break");
  }
  is_when() {
    return this.is_keyword("when");
  }
  is_for() {
    return this.is_keyword("for");
  }
  is_in() {
    return this.is_keyword("in");
  }
  is_while() {
    return this.is_keyword("while");
  }
  is_bool() {
    return this.is_keyword("true") || this.is_keyword("false");
  }
  is_char() {
    return this.current.v[0] === "char";
  }
  is_str() {
    return this.current.v[0] === "str";
  }
  is_int() {
    return this.current.v[0] === "int";
  }
  is_float() {
    return this.current.v[0] === "float";
  }
  is_modifier() {
    const plus_or_minus = this.expect_plus() || this.expect_minus() && this.lookahead_n(2).v === ")";
    return this.is_open_paren() && plus_or_minus;
  }
  is_this() {
    return this.is_keyword("this");
  }
  is_keyword(id2) {
    return this.current.v[0] === "key" && this.current.v[1] === id2;
  }
  is_id() {
    return this.current.v[0] === "id";
  }
  is_id_pat() {
    return this.current.v[0] === "id";
  }
  is_bool_pat() {
    return this.current.v[0] === "bool";
  }
  is_char_pat() {
    return this.current.v[0] === "char";
  }
  is_str_pat() {
    return this.current.v[0] === "str";
  }
  is_int_pat() {
    return this.current.v[0] === "int";
  }
  is_float_pat() {
    return this.current.v[0] === "float";
  }
  is_tuple_pat() {
    return this.is_open_paren();
  }
  is_list_pat() {
    return this.is_open_bracket();
  }
  is_structl_pat() {
    return this.is_open_curly();
  }
  is_enum_pat() {
    return this.is_dot();
  }
  is_pat() {
    return this.is_bool_pat() || this.is_char_pat() || this.is_str_pat() || this.is_int_pat() || this.is_float_pat() || this.is_list_pat() || this.is_tuple_pat() || this.is_structl_pat() || this.is_enum_pat() || this.is_id_pat() || this.is_underscore();
  }
  is_assoc_fn() {
    if (!is_list\$2(this.current.v)) {
      return;
    }
    return this.is_fn() && this.lookahead().v === "^";
  }
  is_method() {
    if (!is_list\$2(this.current.v)) {
      return;
    }
    return this.is_fn() && this.lookahead().v !== "^";
  }
  expect_colon() {
    return this.lookahead().v === ":";
  }
  expect_comma() {
    return this.lookahead().v === ",";
  }
  expect_plus() {
    return this.lookahead().v === "+";
  }
  expect_minus() {
    return this.lookahead().v === "-";
  }
  expect_id() {
    const tk = this.lookahead().v;
    return tk[0] === "id";
  }
  expect_str() {
    const tk = this.lookahead().v;
    return tk[0] === "str";
  }
  expect_eof() {
    return this.lookahead().v === "\$eof";
  }
  expect_close_paren() {
    return this.lookahead().v === ")";
  }
  expect_close_bracket() {
    return this.lookahead().v === "]";
  }
  expect_open_curly() {
    return this.lookahead().v === "{";
  }
  expect_close_curly() {
    return this.lookahead().v === "}";
  }
  expect_astrisk() {
    return this.lookahead().v === "*";
  }
  expect_asgmt() {
    return this.lookahead().v === "=";
  }
  maybe_asgmt() {
    if (this.is_asgmt()) {
      this.next();
      return true;
    }
  }
  maybe_comma() {
    if (this.is_comma()) {
      this.next();
      return true;
    }
  }
  optional_comma() {
    if (this.is_newline() || this.is_close_curly() || this.is_close_paren() || this.is_close_bracket() || this.is_close_angle() || this.is_thin_arrow() || this.is_thick_arrow()) {
      return this.maybe_comma();
    } else {
      return this.req_comma();
    }
  }
  maybe_colon() {
    if (this.is_colon()) {
      this.next();
      return true;
    }
  }
  maybe_open_curly() {
    if (this.is_open_curly()) {
      this.next();
      return true;
    }
  }
  maybe_id() {
    if (this.is_id()) {
      const id2 = this.current;
      this.next();
      return id2;
    }
  }
  maybe_asterisk() {
    if (this.is_asterisk()) {
      this.current;
      this.next();
      return this.asterisk;
    }
  }
  maybe_open_paren() {
    if (is_open_paren()) {
      this.next();
      return true;
    }
  }
  maybe_modifier() {
    if (!this.is_modifier()) {
      return;
    }
    this.next();
    const n = new Node("modif", "", this.current);
    this.next();
    this.req_close_paren();
    this.ast.push(n);
    return true;
  }
  maybe_attrs() {
    while (this.is_hash()) {
      this.skip();
      const id2 = this.maybe_id();
      if (!this.id) {
        panic\$2("expecting an id: " + to_str\$2(this.current));
      }
      this.attrs.push(id2);
      if (this.lookahead().v !== ",") {
        return null;
      } else {
        this.skip();
      }
    }
    if (this.attrs.length > 0) {
      return true;
    }
  }
  maybe_pat() {
    if (this.is_pat()) {
      return this.prim_pat();
    }
  }
  req_in() {
    if (this.is_in()) {
      this.next();
      return true;
    } else {
      panic\$2('expecting "in" : ' + to_str\$2(this.current));
    }
  }
  req_asgmt() {
    if (!this.maybe_asgmt()) {
      panic\$2("expecting '=' : " + to_str\$2(this.current));
    }
    return true;
  }
  req_comma() {
    if (this.is_comma()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ',' after : " + to_str\$2(this.current));
    }
  }
  req_backtick() {
    if (this.is_backtick()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '\`' after : " + to_str\$2(this.current));
    }
  }
  req_tbacktick() {
    if (this.is_tbacktick()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '\`\`\`' after : " + to_str\$2(this.current));
    }
  }
  req_terminator() {
    return this.is_newline() || this.is_eof();
  }
  req_open_paren() {
    if (this.is_open_paren()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '(' : " + to_str\$2(this.current));
    }
  }
  req_close_paren() {
    if (this.is_close_paren()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ')' : " + to_str\$2(this.current));
    }
  }
  req_open_curly() {
    if (this.is_open_curly()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '{' : " + to_str\$2(this.current));
    }
  }
  req_close_curly() {
    if (this.is_close_curly()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '}' : " + to_str\$2(this.current));
    }
  }
  req_close_angle() {
    if (this.is_close_angle()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '>' : " + to_str\$2(this.current));
    }
  }
  req_colon() {
    if (this.is_colon()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting a colon ':' " + to_str\$2(this.current));
    }
  }
  req_dcolon() {
    if (this.is_dcolon()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting a double colon '::' " + to_str\$2(this.current));
    }
  }
  req_open_bracket() {
    if (this.is_open_bracket()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '[' : " + to_str\$2(this.current));
    }
  }
  req_close_bracket() {
    if (this.is_close_bracket()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ']' : " + to_str\$2(this.current));
    }
  }
  req_thin_arrow() {
    if (this.is_thin_arrow()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '->' : " + to_str\$2(this.current));
    }
  }
  req_thick_arrow() {
    if (this.is_thick_arrow()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '=>' : " + to_str\$2(this.current));
    }
  }
  req_then() {
    if (this.is_then()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting 'then' : " + to_str\$2(this.current));
    }
  }
  req_pat() {
    const _pat2 = this.maybe_pat();
    if (_pat2) {
      return _pat2;
    } else {
      panic\$2("expecting a pattern: " + to_str\$2(this.current));
    }
  }
  prim_pat() {
    if (this.is_underscore()) {
      const n = new Node("_", "pat", "");
      this.next();
      return n;
    } else if (this.is_bool_pat()) {
      return this.bool_pat();
    } else if (this.is_char_pat()) {
      return this.char_pat();
    } else if (this.is_str_pat()) {
      return this.str_pat();
    } else if (this.is_int_pat()) {
      return this.int_pat();
    } else if (this.is_float_pat()) {
      return this.float_pat();
    } else if (this.is_list_pat()) {
      return this.list_pat();
    } else if (this.is_tuple_pat()) {
      return this.tuple_pat();
    } else if (this.is_structl_pat()) {
      return this.structl_pat();
    } else if (this.is_enum_pat()) {
      return this.enum_pat();
    } else if (this.is_id_pat()) {
      return this.id_pat();
    }
  }
  bool_pat() {
    const n = new Node("bool", "pat", this.current);
    this.next();
    return n;
  }
  char_pat() {
    const n = new Node("char", "pat", this.current);
    this.next();
    return n;
  }
  str_pat() {
    const n = new Node("str", "pat", this.current);
    this.next();
    return n;
  }
  int_pat() {
    const n = new Node("int", "pat", this.current);
    this.next();
    return n;
  }
  float_pat() {
    const n = new Node("float", "pat", this.current);
    this.next();
    return n;
  }
  list_pat() {
    if (!this.is_open_bracket()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        if (!this.req_comma()) {
          return;
        }
      }
      const _pat2 = this.maybe_pat();
      if (_pat2) {
        return items.push(_pat2);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_bracket();
    const n = new Node("[", "pat", items);
    return n;
  }
  tuple_pat() {
    if (!this.is_open_paren()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.maybe_pat();
      if (_pat2) {
        return items.push(_pat2);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_paren();
    const n = new Node("(", "pat", items);
    return n;
  }
  structl_pat() {
    if (!this.is_open_curly()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        this.maybe_comma() || this.req_terminator();
      }
      const id2 = this.maybe_id();
      if (!id2) {
        break;
      }
      let v2;
      if (this.is_colon()) {
        this.next();
        v2 = this.req_pat();
      }
      const el = new StructLEl(id2, v2);
      items.push(el);
    }
    this.maybe_comma();
    this.req_close_curly();
    const n = new Node("{", "pat", items);
    return n;
  }
  enum_pat() {
    panic\$2("enum patterns are not supported yet");
    const id2 = this.current;
    this.next();
    const p = new EnumPat(id2, _pat);
    if (_pat) {
      const n = new Node("enum_pat", "pat", p);
      return n;
    }
  }
  id_pat() {
    const id2 = this.current;
    this.next();
    const n = new Node("id", "pat", id2);
    return n;
  }
  req_body() {
    this.req_open_curly();
    const stmts = this.stmts();
    this.req_close_curly();
    const n = new Node("body", "body", stmts);
    return n;
  }
  req_body_ret() {
    const body = this.req_body();
    this.implicit_return(body.v);
    return body;
  }
  maybe_stmt() {
    if (this.is_eof() || this.is_modifier()) {
      return;
    }
    return this.maybe_break() || this.maybe_const() || this.maybe_let() || this.maybe_expr() || this.maybe_semicolon() || this.maybe_for();
  }
  req_stmts() {
    const token = this.current;
    const stmts = this.stmts();
    if (is_empty(stmts)) {
      panic\$2("expecting a statement : " + to_str\$2(token));
    } else {
      return stmts;
    }
  }
  stmts() {
    let _stmts = [];
    let stmt;
    while (true) {
      stmt = this.maybe_stmt();
      if (stmt) {
        _stmts.push(stmt);
      }
      if (!stmt) {
        break;
      }
    }
    return _stmts;
  }
  maybe_ret() {
    if (!this.is_ret()) {
      return;
    }
    this.next();
    const expr = this.maybe_expr();
    const n = new Node("return", "expr", expr);
    return n;
  }
  maybe_break() {
    if (!this.is_break()) {
      return;
    }
    this.next();
    const n = new Node("break", "stmt", null);
    return n;
  }
  maybe_global_const() {
    let c = this.maybe_const();
    if (c) {
      this.ast.push(c);
      return true;
    }
    return false;
  }
  maybe_global_fn() {
    let fn = this.maybe_fn();
    if (fn) {
      this.ast.push(fn);
      return true;
    }
    return false;
  }
  maybe_trait() {
    if (!this.is_trait()) {
      return;
    }
    this.next();
    let id2 = this.req_id();
    let sigs = [];
    let fns = [];
    while (!this.is_eof() || !this.is_close_curly()) {
      const fn_or_sig = this.maybe_fn_or_sig();
      if (fn_or_sig.id === "fn_sig") {
        sig.push(fn_or_sig);
      } else if (fn_or_sig.id === "fn") {
        fns.push(fn_or_sig);
      } else {
        panic\$2("expecting function or signature.");
      }
    }
    this.req_close_curly();
    const trait = new Trait(id2, fns, sigs);
    const n = new Node("trait", "def", trait);
    this.ast.push(n);
  }
  maybe_impl() {
    if (!this.is_at()) {
      return;
    }
    this.next();
    let t = this.req_type();
    return this.is_id() ? this.req_trait_impl(t) : this.req_methods(t);
  }
  req_methods(t) {
    if (this.maybe_open_curly()) {
      while (!this.is_eof() || !this.is_close_curly()) {
        const fn = this.maybe_fn();
        const method = new Method(t, fn);
        const n = new Node("method", "def", method);
        this.ast.push(n);
      }
      this.req_close_curly();
    } else {
      const method = new Method(t, this.req_fn());
      this.ast.push(new Node("method", "def", method));
    }
    return true;
  }
  req_trait_impl(t) {
    if (this.maybe_open_curly()) {
      let methods = [];
      while (!this.is_eof() || !this.is_close_curly()) {
        const fn = this.maybe_fn();
        const method = new Method(type, fn);
        methods.push(method);
      }
      const n = new Node("method", "def", methods);
      this.ast.push(n);
      this.req_close_curly();
    } else {
      const method = new Method(t, this.req_fn());
      this.ast.push(new Node("trait_impl", "def", method));
    }
    return true;
  }
  maybe_const() {
    if (!this.is_const()) {
      return;
    }
    this.next();
    const _pat2 = this.req_pat();
    const t = this.maybe_tannotation();
    this.req_asgmt();
    const rhs = this.req_expr();
    const asgmt = new Asgmt(_pat2, t, rhs);
    const n = new Node("const", "stmt", asgmt);
    return n;
  }
  maybe_let() {
    if (!this.is_let()) {
      return;
    }
    this.next();
    const _pat2 = this.req_pat();
    const t = this.maybe_tannotation();
    let eq = this.maybe_asgmt();
    let rhs;
    if (eq) {
      rhs = this.req_expr();
    }
    const asgmt = new Asgmt(_pat2, t, rhs);
    const n = new Node("var", "stmt", asgmt);
    return n;
  }
  req_expr() {
    const token = this.current;
    const expr = this.maybe_expr();
    if (expr) {
      return expr;
    } else {
      panic\$2("expecting expression : " + to_str\$2(token));
    }
  }
  maybe_do_block_ret() {
    const block = this.maybe_do_block();
    if (block) {
      this.implicit_return(block.v);
      return block;
    }
  }
  req_do_block_ret() {
    const block = this.req_do_block();
    this.implicit_return(block.v);
    return block;
  }
  maybe_do_block() {
    if (!this.is_do()) {
      return;
    }
    this.next();
    const stmts = [];
    this.req_open_curly();
    while (true) {
      if (this.is_eof() || this.is_close_curly()) {
        break;
      }
      const stmt = this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        break;
      }
    }
    this.req_close_curly();
    const n = new Node("do_block", "expr", stmts);
    return n;
  }
  req_do_block() {
    const token = this.current;
    const expr = this.maybe_do_block();
    if (expr) {
      return expr;
    } else {
      panic\$2("expecting 'do' block : " + to_str\$2(token));
    }
  }
  maybe_block() {
    if (!this.is_open_curly()) {
      return;
    }
    this.next();
    const stmts = [];
    while (true) {
      if (this.is_eof() || this.is_end()) {
        break;
      }
      const stmt = this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        break;
      }
    }
    this.implicit_return(stmts);
    this.req_end();
    const n = new Node("block", "expr", stmts);
    return n;
  }
  maybe_semicolon() {
    if (!this.is_semicolon()) {
      return;
    }
    const tk = this.next();
    const n = new Node(";", "expr", tk);
    return n;
  }
  is_bin_op() {
    if (this.current.v === "(" || this.current.v === "{" || this.current.v === "[") {
      if (!this.is_newline()) {
        return true;
      }
    } else {
      return contains\$2(BIN_OP, this.current.v);
    }
  }
  is_postfix_uni_op() {
    return contains\$2(POSTFIX_UNI_OP, this.current.v);
  }
  req_list_index() {
    const expr = this.req_expr();
    if (expr) {
      if (this.req_close_bracket()) {
        return expr;
      }
    } else {
      panic\$2("expecting  an index [...]: " + to_str\$2(this.current));
    }
  }
  req_access(lopr) {
    let n = this.req_expr();
    return n;
  }
  req_call_args() {
    const args = [];
    while (true) {
      if (this.is_eof() || this.is_close_paren()) {
        break;
      }
      if (args.length > 0) {
        if (this.is_newline()) {
          this.maybe_comma();
        } else {
          this.req_comma();
        }
      }
      let expr = this.maybe_expr();
      if (expr) {
        args.push(expr);
      }
    }
    this.req_close_paren();
    const n = new Node("args", "expr", args);
    return n;
  }
  maybe_lopr_prefix_postfix(expr, postfix_op) {
    const opr = expr.v.opr;
    const op = expr.v.op;
    if (expr.id === "prefix") {
      if (this.prec_uni(postfix_op) >= this.prec_uni(op)) {
        const postfix = new Uni(opr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        const prefix = new Uni(postfix_n, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        this.next();
        return prefix_n;
      } else {
        const postfix = new Uni(expr, postfix_op);
        const n = new Node("postfix", "expr", postfix);
        this.next();
        return n;
      }
    }
  }
  maybe_lopr_bin_postfix(expr, postfix_op) {
    if (expr.id === "bin") {
      const op = expr.v.op;
      const ropr = expr.v.ropr;
      const lopr = expr.v.lopr;
      if (this.prec_uni(postfix_op) >= this.prec_bin(op)) {
        const postfix = new Uni(ropr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        const bin = new Bin(lopr, op, postfix_n);
        const bin_n = new Node("bin", "expr", bin);
        this.next();
        return bin_n;
      } else {
        const postfix = new Uni(expr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        this.next();
        return postfix_n;
      }
    }
  }
  maybe_lopr_prefix_bin(expr, bin_op) {
    const op = expr.v.op;
    let opr = expr.v.opr;
    if (expr.id === "prefix") {
      if (this.prec_uni(op) >= this.prec_bin(bin_op)) {
        opr = this.req_op(opr);
        const prefix = new Uni(opr, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        return prefix_n;
      } else {
        const ropr = this.req_ropr(expr);
        const bin = new Bin(opr, bin_op, ropr);
        const bin_n = new Node("bin", "expr", bin);
        const prefix = new Uni(bin_n, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        return prefix_n;
      }
    }
  }
  get_lopr(lopr, op) {
    let opr = this.maybe_lopr_prefix_postfix(lopr, op);
    if (!opr) {
      opr = this.maybe_lopr_bin_postfix(lopr, op);
      if (!opr) {
        const postfix = new Uni(lopr, op);
        opr = new Node("postfix", "expr", postfix);
        this.next();
      }
    }
    return opr;
  }
  req_ropr(lopr) {
    let ropr;
    const token = this.current;
    if (this.is_open_bracket()) {
      this.next();
      ropr = this.req_list_index();
    } else if (this.is_dot()) {
      this.next();
      ropr = this.req_access(lopr);
    } else if (this.is_open_paren()) {
      this.next();
      ropr = this.req_call_args();
    } else if (this.is_thick_arrow()) {
      this.next();
      ropr = this.req_anonymous_method();
    } else {
      this.next();
      ropr = this.maybe_expr();
    }
    if (!ropr) {
      panic\$2("expecting right operand: " + to_str\$2(token));
    }
    return ropr;
  }
  prec_uni(v2) {
    switch (v2.v) {
      case "...":
        return 70;
      case "%":
        return 60;
      case ".":
        return 50;
      case "!":
      case "?":
        return 16;
      case "+":
      case "-":
      case "_!":
      case "not":
        return 15;
      case "⏎":
        return 0;
      default:
        panic\$2("unexpected unary operator: " + to_str\$2(v2));
    }
  }
  prec_bin(v2) {
    switch (v2.v) {
      case "[":
        return 20;
      case "(":
      case "{":
        return 19;
      case ".":
        return 18;
      case "*":
      case "×":
      case "/":
      case "÷":
        return 13;
      case "+":
      case "-":
      case "::":
      case "++":
        return 12;
      case "<":
      case "<=":
      case ">":
      case ">=":
        return 11;
      case "==":
      case "!=":
        return 10;
      case "<<":
      case ">>":
        return 8;
      case "&":
        return 7;
      case "**":
      case "⊕":
        return 6;
      case "|":
        return 5;
      case "&&":
        return 4;
      case "||":
        return 3;
      case "|>":
      case "||>":
      case ":>":
      case "=>":
        return 2;
      case "=":
      case "~=":
      case "+=":
      case "-=":
      case "*=":
      case "×=":
      case "/=":
      case "÷=":
      case "&=":
      case "|=":
      case "^=":
      case ">>=":
      case "<<=":
      case ":=":
        return 1;
      default:
        panic\$2("unexpected binary operator: " + to_str\$2(v2));
    }
  }
  is_bin_rassoc(v2) {
    return contains\$2(BIN_R_ASSOC, v2);
  }
  maybe_op(lopr) {
    const op = this.current;
    if (this.is_postfix_uni_op()) {
      return this.get_lopr(lopr, op);
    } else if (this.is_bin_op()) {
      const opr = this.maybe_lopr_prefix_bin(lopr, op);
      if (opr) {
        return opr;
      }
      let ropr = this.req_ropr(lopr);
      if (ropr) {
        if (ropr.id === "bin") {
          ropr = this.while_op(ropr, this.prec_bin(ropr.v.op) > this.prec_bin(op) || this.prec_bin(ropr.v.op) === this.prec_bin(op) && this.is_bin_rassoc(ropr.v.op));
        } else if (ropr.id === "prefix") {
          ropr = this.while_op(ropr, this.prec_bin(op) > this.prec_uni(ropr.v.op) || this.is_bin_rassoc(op));
        } else {
          ropr = this.while_op(ropr, false);
        }
      }
      const bin = new Bin(lopr, op, ropr);
      const n = new Node("bin", "expr", bin);
      return n;
    }
  }
  req_op(lopr) {
    const op = this.maybe_op(lopr);
    if (op) {
      return op;
    }
    panic\$2("expect an operation: " + to_str\$2(this.lookahead()));
  }
  while_op(lopr, cond) {
    let expr = clone(lopr);
    if (this.is_eof()) {
      return expr;
    }
    while (this.is_bin_op() || this.is_postfix_uni_op()) {
      if (cond === false) {
        break;
      }
      expr = this.req_op(expr);
    }
    return expr;
  }
  maybe_expr() {
    let expr = this.maybe_prim();
    if (expr) {
      expr = this.while_op(expr);
      return expr;
    }
  }
  req_id() {
    const id2 = this.maybe_id();
    if (id2) {
      return id2;
    } else {
      panic\$2("expecting an ID: " + to_str\$2(this.current));
    }
  }
  maybe_void() {
    if (this.is_void()) {
      this.next();
      const n = new Node("void", "expr");
      return n;
    }
  }
  req_anonymous_fn() {
    const fn = this.maybe_anonymous_fn();
    if (fn) {
      return fn;
    } else {
      panic\$2("expecting an anonymous function : " + to_str\$2(this.current));
    }
  }
  maybe_anonymous_fn() {
    if (!this.is_tilde()) {
      return;
    }
    this.next();
    const params2 = [];
    let open_paren = this.maybe_open_paren();
    this.maybe_comma();
    while (true) {
      if (this.is_close_paren() || this.is_eof()) {
        break;
      }
      if (params2.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.req_pat();
      const t = this.maybe_tannotation();
      const param = new FnParam(_pat2, t);
      const n2 = new Node("param", "pat", param);
      if (_pat2.id !== "id") {
        panic\$2("only parameters with id patterns are currently supported");
      }
      params2.push(n2);
    }
    this.maybe_comma();
    if (open_paren) {
      this.req_close_paren();
    }
    const ret_types = this.maybe_fn_ret_types();
    const body = this.req_body_ret();
    const _afn = new Fn("", params2, ret_types, body);
    const n = new Node("afn", "expr", _afn);
    return n;
  }
  maybe_tuple_group() {
    if (this.is_open_paren()) {
      const loc = this.current.loc;
      this.next();
      if (this.is_id() && this.expect_colon()) {
        return this.req_named_tuple();
      } else {
        let expr = null;
        expr = this.maybe_expr();
        if (expr) {
          let arg = expr;
          if (this.is_comma()) {
            const tuple = [arg];
            while (true) {
              const comma_close_paren = this.is_comma() && this.expect_close_paren();
              if (this.is_eof() || this.is_close_paren() || comma_close_paren) {
                break;
              }
              this.req_comma();
              arg = this.maybe_expr();
              if (arg) {
                tuple.push(arg);
              } else {
                panic\$2("expected an argument: " + loc);
              }
            }
            this.maybe_comma();
            this.req_close_paren();
            const n = new Node("tuple", "expr", tuple);
            return n;
          } else {
            this.req_close_paren();
            expr.grouped = true;
            return expr;
          }
        }
      }
    }
  }
  req_named_tuple() {
    let named_tuple = [];
    while (!(this.is_eof() || this.is_close_paren())) {
      let name = this.req_id();
      this.req_colon();
      let expr = this.req_expr();
      named_tuple.push([name, expr]);
      this.optional_comma();
    }
    this.req_close_paren();
    return new Node("named_tuple", "expr", named_tuple);
  }
  is_prefix_uni_op() {
    return contains\$2(PREFIX_UNI_OP, this.current.v);
  }
  maybe_prefix_uni_op() {
    if (this.is_prefix_uni_op()) {
      const op = this.current;
      this.next();
      const prefix = new Uni(this.req_prim(), op);
      const n = new Node("prefix", "expr", prefix);
      return n;
    }
  }
  maybe_literal() {
    let expr = this.maybe_primitivel();
    if (!expr) {
      expr = this.maybe_list();
    }
    if (!expr) {
      expr = this.maybe_tuple();
    }
    return expr;
  }
  maybe_primitivel() {
    let expr = this.maybe_bool();
    if (!expr) {
      expr = this.maybe_char();
    }
    if (!expr) {
      expr = this.maybe_str();
    }
    if (!expr) {
      expr = this.maybe_int();
    }
    if (!expr) {
      expr = this.maybe_float();
    }
    return expr;
  }
  maybe_bool() {
    if (this.is_bool()) {
      const n = new Node("bool", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_char() {
    if (this.is_char()) {
      const n = new Node("char", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_str() {
    if (this.is_str()) {
      const n = new Node("str", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_int() {
    if (this.is_int()) {
      const num = this.current;
      this.next();
      let suffix;
      if (this.is_id() && !this.is_newline()) {
        suffix = this.current;
        this.next();
      }
      const n = new Node("int", "expr", [num, suffix]);
      return n;
    }
  }
  maybe_float() {
    if (this.is_float()) {
      const num = this.current;
      this.next();
      let suffix;
      if (this.is_id() && !this.is_newline()) {
        suffix = this.current;
        this.next();
      }
      const n = new Node("float", "expr", [num, suffix]);
      return n;
    }
  }
  maybe_list() {
    if (this.is_open_bracket()) {
      const els = [];
      this.next();
      this.maybe_comma();
      while (true) {
        const comma_close_bracket = this.is_comma() && this.expect_close_bracket();
        if (this.is_eof() || this.is_close_bracket() || comma_close_bracket) {
          break;
        }
        if (els.length > 0) {
          if (this.is_newline()) {
            this.maybe_comma();
          } else {
            this.req_comma();
          }
        }
        els.push(this.req_expr());
      }
      this.maybe_comma();
      this.req_close_bracket();
      const n = new Node("[", "expr", els);
      return n;
    }
  }
  maybe_tuple() {
    if (this.is_open_paren()) {
      const els = [];
      this.skip();
      this.maybe_comma();
      let named_tuple = false;
      if (this.is_id && this.expect_colon()) {
        named_tuple = true;
      }
      while (true) {
        if (els.length > 0) {
          this.req_comma();
        }
        let name;
        if (named_tuple) {
          name = this.req_id();
          this.req_colon();
        }
        let expr = this.req_expr();
        if (named_tuple) {
          els.push([name, expr]);
        } else {
          els.push([expr]);
        }
        if (this.is_close_paren()) {
          break;
        }
      }
      this.maybe_comma();
      this.req_close_paren();
      if (named_tuple) {
        return new Node("(:", "expr", els);
      } else {
        return new Node("(", "expr", els);
      }
    }
  }
  maybe_call(id2) {
    const maybe_args = () => {
      const args2 = [];
      if (!this.is_open_paren()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_paren())) {
        let arg_name;
        if (this.is_id() && this.expect_colon()) {
          arg_name = this.current;
          this.next();
          this.next();
        }
        let arg;
        if (arg_name) {
          arg = new Node("named_arg", "expr", [arg_name, this.req_expr()]);
        } else {
          arg = this.maybe_expr();
        }
        if (!arg) {
          break;
        }
        args2.push(arg);
        this.optional_comma();
      }
      this.req_close_paren();
      return args2;
    };
    const args = maybe_args();
    if (!args && (!this.is_tilde() || !this.is_colon())) {
      return;
    }
    if (!args) {
      args = [];
    }
    let trailing = [];
    while (true) {
      let closure = this.maybe_trailing_closure();
      if (closure) {
        trailing.push(closure);
      } else {
        break;
      }
    }
    const fn_call = new FnCall(id2, args, trailing);
    const n = new Node("call", "expr", fn_call);
    return n;
  }
  req_ref() {
    const id2 = this.current;
    this.next();
    const n = new Node("ref", "expr", id2);
    return n;
  }
  maybe_call_or_ref() {
    if (this.is_id()) {
      const ref = this.req_ref();
      return this.maybe_call(ref) || ref;
    }
  }
  maybe_when_arm() {
    const pats = [];
    while (!this.is_thin_arrow()) {
      pats.push(this.req_pat());
      if (this.is_bar()) {
        this.next();
      } else {
        break;
      }
    }
    this.req_thin_arrow();
    const expr = this.req_expr();
    const arm = new WhenArm(pats, expr);
    const n = new Node("arm", "", arm);
    return n;
  }
  maybe_when() {
    if (!this.is_when()) {
      return;
    }
    this.next();
    this.req_open_paren();
    const expr = this.maybe_expr();
    this.req_close_paren();
    this.req_open_curly();
    const arms = [];
    this.maybe_comma();
    while (true) {
      if (this.is_eof() || this.is_close_curly()) {
        break;
      }
      if (arms.length > 0) {
        this.optional_comma();
        if (this.is_eof() || this.is_close_curly()) {
          break;
        }
      }
      const arm = this.maybe_when_arm();
      if (arm) {
        arms.push(arm);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_curly();
    const _when = new When(expr, arms);
    const n = new Node("when", "expr", _when);
    return n;
  }
  maybe_for() {
    if (!this.is_for()) {
      return;
    }
    this.next();
    let stmt = this.maybe_for_inf();
    if (!stmt) {
      stmt = this.maybe_for_cond();
    }
    if (!stmt) {
      stmt = this.req_for_in();
    }
    return stmt;
  }
  maybe_for_inf() {
    if (!this.is_open_curly()) {
      return;
    }
    let body = this.req_body();
    let stmt = new ForInf(body);
    let n = new Node("for_inf", "stmt", stmt);
    return n;
  }
  maybe_for_cond() {
    const init2 = this.maybe_let();
    let expr;
    if (init2) {
      expr = this.req_expr();
    } else {
      expr = this.maybe_expr();
    }
    if (!expr) {
      return;
    }
    const body = this.req_body();
    let stmt = new ForCond(expr, body);
    let n = new Node("for_cond", "stmt", stmt);
    return n;
  }
  req_for_in() {
    const pat = this.req_pat();
    this.req_in();
    const expr = this.req_expr();
    let body = this.req_body();
    let stmt = new ForIn(pat, expr, body);
    let n = new Node("for_in", "stmt", stmt);
    return n;
  }
  req_anonymous_method() {
    const maybe_field_asgmt = () => {
      if (!this.is_id() || this.lookahead().v !== ":") {
        return;
      }
      let id2 = this.req_id();
      this.req_colon();
      let expr = this.req_expr();
      const bin = new FieldAsgmt(id2, expr);
      return bin;
    };
    if (this.is_open_curly()) {
      this.next();
    } else {
      panic\$2("expecting ',' after : " + to_str\$2(this.current));
    }
    let stmts = [];
    while (!this.is_eof() || !this.is_close_curly()) {
      let stmt = maybe_field_asgmt() || this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        panic\$2("expected a statement : " + to_str\$2(this.current));
      }
    }
    let amethod = new AnonymousMethod(stmts);
    this.req_close_curly();
    let n = new Node("amethod", "expr", amethod);
    return n;
  }
  maybe_trailing_closure() {
    if (!this.is_colon() || !this.is_tilde()) {
      return;
    }
    let label;
    if (this.is_colon()) {
      this.next();
      label = this.req_id();
    }
    let fn = this.req_anonymous_fn();
    return new TrailingClosure(label, fn);
  }
  maybe_prim() {
    let expr = this.maybe_void();
    if (!expr) {
      expr = this.maybe_tuple_group();
    }
    if (!expr) {
      expr = this.maybe_prefix_uni_op();
    }
    if (!expr) {
      expr = this.maybe_call_or_ref();
    }
    if (!expr) {
      expr = this.maybe_literal();
    }
    if (!expr) {
      expr = this.maybe_when();
    }
    if (!expr) {
      expr = this.maybe_do_block_ret();
    }
    if (!expr) {
      expr = this.maybe_ret();
    }
    if (!expr) {
      expr = this.maybe_semicolon();
    }
    return expr;
  }
  req_prim() {
    const prim = this.maybe_prim();
    if (!prim) {
      panic\$2("expecting an expression: " + to_str\$2(this.current));
    }
    return prim;
  }
  maybe_fn() {
    if (!this.is_fn()) {
      return;
    }
    const _fn = this.req_fn();
    if (_fn && contains\$2(["main", "بدء"], _fn.v.name.v[1])) {
      const n = new Node("main", "fn", _fn.v);
      return n;
    } else {
      const n = new Node("fn", "fn", _fn.v);
      return n;
    }
  }
  maybe_use() {
    if (!this.is_use()) {
      return;
    }
    this.next();
    const path = [];
    if (!this.is_id()) {
      return false;
    }
    while (this.is_id()) {
      path.push(this.current);
      this.next();
      if (this.is_dot()) {
        this.skip();
        if (!this.is_id()) {
          panic\$2("expecting an idnetifier after " + to_str\$2(this.current));
        }
      } else {
        break;
      }
    }
    const n = new Node("use", "stmt", path);
    this.ast.push(n);
    return true;
  }
  maybe_optional() {
    if (this.is_question()) {
      this.next();
      return true;
    }
  }
  maybe_simple_type() {
    if (this.is_id()) {
      let n;
      const t = this.req_id();
      if (this.is_open_angle()) {
        const ts = [];
        this.next();
        this.maybe_comma();
        while (true) {
          if (this.is_eof() || this.is_close_angle()) {
            break;
          }
          if (ts.length > 0) {
            this.req_comma();
          }
          ts.push(this.req_type());
        }
        this.maybe_comma();
        this.req_close_angle();
        const _type = new TypeTempl(t, ts, this.maybe_optional());
        n = new Node("<", "t", _type);
      } else {
        const _type = new Type(t, this.maybe_optional());
        n = new Node("t", "t", _type);
      }
      return n;
    }
  }
  maybe_list_type() {
    if (this.is_open_bracket()) {
      this.next();
      const t = this.req_type();
      this.req_close_bracket();
      const _type = new Type(t, this.maybe_optional());
      return new Node("[", "t", _type);
    }
  }
  maybe_type() {
    return this.maybe_simple_type() || this.maybe_list_type();
  }
  req_type() {
    let n = this.maybe_type();
    if (!n) {
      panic\$2("type required: " + to_str\$2(this.current));
    }
    return n;
  }
  maybe_tannotation() {
    if (!this.is_colon()) {
      return;
    }
    this.next();
    return this.maybe_type();
  }
  req_tannotation() {
    const tannotation = this.maybe_tannotation();
    if (!tannotation) {
      panic\$2("requires type annotation: " + to_str\$2(this.current));
    }
    return tannotation;
  }
  maybe_fn_params() {
    const params2 = [];
    if (!this.is_open_paren()) {
      return params2;
    }
    this.next();
    this.maybe_comma();
    while (true) {
      if (this.is_close_paren() || this.is_eof()) {
        break;
      }
      if (params2.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.req_pat();
      const t = this.maybe_tannotation();
      const param = new FnParam(_pat2, t);
      const n = new Node("param", "pat", param);
      if (_pat2.id !== "id") {
        panic\$2("only parameters with id patterns are currently supported");
      }
      params2.push(n);
    }
    this.maybe_comma();
    this.req_close_paren();
    return params2;
  }
  maybe_fn_ret_types() {
    const ret_types = [];
    if (this.is_thin_arrow()) {
      this.next();
      while (this.is_id()) {
        let id2 = this.next();
        if (this.is_exclamation()) {
          this.next();
          ret_types.push({
            id: id2,
            _t: "throw"
          });
        } else {
          ret_types.push({
            id: id2,
            _t: "ret_type"
          });
        }
        this.optional_comma();
      }
    }
    return ret_types;
  }
  req_fn() {
    let sig2 = this.maybe_fn_sig();
    if (sig2) {
      sig2 = sig2.v;
    } else {
      return;
    }
    const body = this.req_body_ret();
    const _fn = new Fn(sig2.name, sig2.params, sig2.ret_types, body);
    const n = new Node("fn", "def", _fn);
    return n;
  }
  maybe_fn_sig() {
    if (!this.is_fn()) {
      return;
    }
    this.next();
    const name = this.req_id();
    this.symtab.insert_fn(name.v[1]);
    const params2 = this.maybe_fn_params();
    const ret_types = this.maybe_fn_ret_types();
    const fn_sig = new FnSig(name, params2, ret_types);
    const n = new Node("fn_sig", "def", fn_sig);
    return n;
  }
  maybe_fn_or_sig() {
    let sig2 = this.maybe_fn_sig();
    if (sig2) {
      if (this.is_open_curly()) {
        const body = this.req_body_ret();
        const _fn = new Fn(sig2.name, sig2.params, sig2.ret_types, body);
        const n = new Node("fn", "def", _fn);
        return n;
      } else {
        return sig2;
      }
    }
  }
  maybe_struct() {
    const maybe_fields = () => {
      const fields2 = [];
      if (!this.is_open_curly()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_curly())) {
        let field_name;
        if (this.is_id()) {
          field_name = this.req_id();
        } else if (this.is_open_paren()) {
          this.next();
          field_name = this.req_id();
          this.req_close_paren();
        }
        this.req_colon();
        let n2;
        let field = new Field(field_name, this.req_type());
        if (field_name) {
          n2 = new Node("field", "def", field);
        }
        if (!n2) {
          const type2 = this.maybe_list_type();
          if (type2) {
            const id22 = { v: ["id", "sn__"], loc: { "line": 0, "column": 0 } };
            let field2 = new Field(id22, type2);
            n2 = new Node("field", "def", field2);
          }
          if (n2) {
            fields2.push(n2);
          }
          break;
        }
        fields2.push(n2);
        this.optional_comma();
      }
      this.req_close_curly();
      return fields2;
    };
    if (!this.is_struct()) {
      return;
    }
    this.next();
    const id2 = this.req_id();
    this.symtab.insert_struct(id2.v[1]);
    let fields = maybe_fields() || [];
    if (!fields) {
      return;
    }
    const _t = new Struct(id2, fields);
    const n = new Node("struct", "def", _t);
    this.ast.push(n);
    return true;
  }
  maybe_enum() {
    const maybe_inner_type = () => {
      if (!this.is_open_paren()) {
        return;
      }
      this.next();
      let _t2 = this.maybe_type();
      this.req_close_paren();
      return _t2;
    };
    const maybe_variants = () => {
      const variants2 = [];
      if (!this.is_open_curly()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_curly())) {
        let variant_name;
        if (this.is_id()) {
          variant_name = this.current;
          this.next();
        }
        let variant;
        if (variant_name) {
          variant = new Node("variant", "def", [variant_name, maybe_inner_type()]);
        }
        if (!variant) {
          break;
        }
        variants2.push(variant);
        this.optional_comma();
      }
      this.req_close_curly();
      return variants2;
    };
    if (!this.is_enum()) {
      return;
    }
    this.next();
    const id2 = this.req_id();
    this.symtab.insert_enum(id2.v[1]);
    let variants = maybe_variants() || [];
    if (!variants) {
      return;
    }
    const _t = new Enum(id2, variants);
    const n = new Node("enum", "def", _t);
    this.ast.push(n);
    return true;
  }
  implicit_return(_stmts) {
    if (!_stmts || _stmts.length <= 0) {
      return;
    }
    const last_index = _stmts.length - 1;
    const last = _stmts[last_index];
    if (contains\$2(["when", "while", "if", "for", "return", "let", "var", "const"], last.id) || last.id === "bin" && last.v.op.v === ":=") {
      return;
    }
    if (last.id === ";") {
      return;
    }
    if (last.id === "bin" && last.v.op.v === "=") {
      return;
    }
    if (last.id === "bin" && last.v.lopr.id === "ref" && contains\$2(["println", "اطبع_سطر"], last.v.lopr.v.v[1])) {
      return;
    }
    if (last.t === "expr") {
      const n = new Node("iret", "expr", last);
      return replace(_stmts, last_index, n);
    }
  }
}
class Semantic {
  ast;
  symtab;
  constructor(ast, symtab) {
    this.ast = ast;
    this.symtab = symtab;
  }
  run() {
    console.log(JSON.stringify(this.symtab.root));
  }
}
const HYPHENATED = [
  "min_width",
  "min_height",
  "background_color",
  "background_image",
  "background_position",
  "background_repeat",
  "background_size",
  "background_attachment",
  "_webkite_background_size",
  "aspect_ratio",
  "border_right",
  "border_left",
  "border_top",
  "border_bottom",
  "border_radius",
  "border_style",
  "margin_top",
  "margin_bottom",
  "margin_right",
  "margin_left",
  "align_items",
  "text_align",
  "justify_content",
  "justify_items",
  "text_justify",
  "object_fit",
  "font_size",
  "font_family",
  "box_sizing",
  "scrollbar_width",
  "user_select",
  "_ms_user_select",
  "_webkit_user_select",
  "_moz_user_select",
  "box_shadow",
  "_webkit_box_shadow",
  "_moz_box_shadow",
  "no_repeat",
  "border_box",
  "space_between",
  "flex_direction",
  "inter_word"
];
const BOOL_ATTRS = [
  "readonly"
];
const ELEMENTS_WITH_DIR = [
  "Html",
  "Body",
  "Div",
  "Span",
  "P",
  "Textarea",
  "Field"
];
const MAGHRIB_DIGIT\$1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
function is_maghrib_num\$1(n) {
  return contains\$1(MAGHRIB_DIGIT\$1, n[0]);
}
function to_maghrib_num\$1(n) {
  if (!is_maghrib_num\$1(n)) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "٠":
          v2 += "0";
          break;
        case "١":
          v2 += "1";
          break;
        case "٢":
          v2 += "2";
          break;
        case "٣":
          v2 += "3";
          break;
        case "٤":
          v2 += "4";
          break;
        case "٥":
          v2 += "5";
          break;
        case "٦":
          v2 += "6";
          break;
        case "٧":
          v2 += "7";
          break;
        case "٨":
          v2 += "8";
          break;
        case "٩":
          v2 += "9";
          break;
        case ",":
          v2 += ".";
          break;
        default:
          panic\$1();
      }
      i += 1;
    }
    return v2;
  } else {
    return n;
  }
}
function is_list\$1(x) {
  return x instanceof Array;
}
function contains\$1(list, el) {
  return list.includes(el);
}
function to_str\$1(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function panic\$1(v2) {
  throw new Error(v2);
}
class HtmlWriter {
  jsGen;
  constructor(jsGen) {
    jsGen.init();
    this.jsGen = jsGen;
    return this;
  }
  write_html(el, page) {
    switch (el.id) {
      case "call":
        let tag = el.v[0].v.v[1];
        let attrs = el.v[1] || [];
        let children = el.v[2] || [];
        if (tag === "Br") {
          return page += "<br>";
        }
        switch (tag) {
          case "Select":
            page = this.write_css(attrs, page) + "} ";
            break;
          case "FontFace":
            page = this.write_css_fontface(attrs, page);
            break;
          case "Keyframes":
            page = this.write_css_keyframes(attrs, children, page);
            break;
          default:
            page += \`<\${tag}\`;
            attrs.forEach((attr, i) => {
              if (i === 0 && attr.id === "str") {
                page += \` id='\${attr.v.v[1]}'\`;
              } else if (attr.id === "named_arg") {
                const attr_name = attr.v[0].v[1];
                if (BOOL_ATTRS.includes(attr_name)) {
                  page += \` \${attr_name} \`;
                } else {
                  page += \` \${attr_name}= \`;
                  if (attr.v[1].id === "str") {
                    page += \`'\${attr.v[1].v.v[1]}'\`;
                  } else if (attr.v[1].id === "int" || attr.v[1].id === "float") {
                    const num = attr.v[1].v[0].v[1];
                    const suffix = attr.v[1].v[1].v[1] || "";
                    page += \`\${num}\${suffix}\`;
                  } else if (attr.v[1].id === "bool") {
                    page += \`\${attr_name}\`;
                  } else {
                    panic\$1("not supported: " + to_str\$1(attr));
                  }
                }
              } else {
                panic\$1("not supported: " + to_str\$1(attr));
              }
            });
            page += ">";
            children.forEach((c) => {
              page = this.write_html(c, page);
            });
            page += \`</\${tag}>\`;
        }
        break;
      case "str":
        page += el.v.v[1];
        break;
      default:
        panic\$1("unknown html element: " + to_str\$1(el));
    }
    return page;
  }
  write_css(attrs, page) {
    attrs.forEach((attr) => {
      const k = maybe_hyphenated(attr.v[0].v[1]);
      const v2 = attr.v[1];
      if (k === "element") {
        page = this.write_css_selector(v2, page);
        page += " {";
      } else {
        page += \`\${k} : \`;
        page = this.write_css_attr_value(v2, page);
        page += \`; \`;
      }
    });
    return page;
  }
  write_css_selector(v2, page) {
    if (is_list\$1(v2.v)) {
      page += " ";
      v2.v.forEach((x, i) => {
        page += \`\${x.v.v[1]} \`;
        if (i < v2.v.length - 1) {
          page += ",";
        }
      });
    } else {
      page += \` \${v2.v.v[1]}\`;
    }
    return page;
  }
  write_css_attr_value(v2, page) {
    switch (v2.id) {
      case "int":
      case "float":
        const num = v2.v[0].v[1];
        const suffix = v2.v[1] && v2.v[1].v[1] || "";
        page += num + suffix;
        break;
      case "prefix":
        page += v2.v.op.v;
        page = this.write_css_attr_value(v2.v.opr, page);
        break;
      case "postfix":
        page = this.write_css_attr_value(v2.v.opr, page);
        page += v2.v.op.v;
        break;
      case "str":
        page += v2.v.v[1];
        break;
      case "ref":
        page += maybe_hyphenated(v2.v.v[1]);
        break;
      case "tuple":
        v2.v.forEach((el) => {
          page = this.write_css_attr_value(el, page + " ");
        });
        break;
      case "call":
        const ref = v2.v[0].v.v[1];
        const args = v2.v[1];
        page += \` \${ref}(\`;
        args.forEach((arg) => {
          page = this.write_css_attr_value(arg, page);
        });
        page += \`)\`;
        break;
      case "bin":
        this.jsGen.write_expr(v2);
        const code = this.jsGen.get_code();
        page += "\${" + code + "}".trim();
        break;
      default:
        panic\$1(\`not supported: html generations:  \${to_str\$1(v2)}\`);
    }
    return page;
  }
  write_css_fontface(attrs, page) {
    page += \`@font-face { \`;
    page = write_ar_css(attrs, page);
    page += "}";
    return page;
  }
  write_css_keyframes(attrs, children, page) {
    page += \` @keyframes \${attrs[0].v.v[1]} { \`;
    children && children.forEach((c) => {
      const ref = c.v[0].v.v[1];
      const v2 = c.v[1];
      switch (ref) {
        case "at":
          const percentage = v2[0];
          const attrs2 = v2[1].v || [];
          page = this.write_css_attr_value(percentage, page);
          page += " {";
          attrs2.forEach((attr) => {
            if (attr.id === "named_tuple") {
              attr.v.forEach((el) => {
                const _k = maybe_hyphenated(el[0].v[1]);
                const _v = el[1];
                page += \` \${_k} : \`;
                page = this.write_css_attr_value(_v, page);
                page += \`; \`;
              });
            } else {
              const _k = maybe_hyphenated(attr[0].v[1]);
              const _v = attr[1];
              page += \` \${_k} : \`;
              page = this.write_css_attr_value(_v, page);
              page += \`; \`;
            }
          });
          page += "} ";
          break;
        default:
          panic\$1("unsupported element: " + to_str\$1(ref));
      }
    });
    page += "}";
    return page;
  }
}
const HTML_tag_en = {
  "صفحة_الشبكة": "Html",
  "راس": "Head",
  "نسق": "Style",
  "متن": "Body",
  "منطقة_النص": "Textarea",
  "عنوان_راسي٣": "H3",
  "قسم": "Div",
  "سطر": "Br"
};
const HTML_attr_en = (id2) => {
  switch (id2) {
    case "صنف":
      return "class";
    case "اعمدة":
      return "cols";
    case "صفوف":
      return "rows";
    case "للقراءة_فقط":
      return "readonly";
    default:
      return id2;
  }
};
const CSS_pseudo_en = {
  // FIXME: workaround
  "حوم": "hover"
};
const CSS_fn_en = (id2) => {
  switch (id2) {
    case "عند":
      return "at";
    case "ازاحة_س":
      return "translateX";
    case "عنوان":
      return "url";
    default:
      return id2;
  }
};
const CSS_suffix_en = (id2) => {
  switch (id2) {
    case "ع_ص":
      return "px";
    case "ع_ط":
      return "vh";
    case "م_ج":
      return "rem";
    case "ث":
      return "s";
    case "٪":
      return "%";
    default:
      return id2;
  }
};
const CSS_key_en = (id2) => {
  switch (id2) {
    case "عنصر":
      return "element";
    case "عرض":
      return "width";
    case "ادنى_عرض":
      return "min_width";
    case "ارتفاع":
      return "height";
    case "ادنى_ارتفاع":
      return "min_height";
    case "لون":
      return "color";
    case "اتجاه":
      return "direction";
    case "خلفية":
      return "background";
    case "لون_الخلفية":
      return "background_color";
    case "صورة_الخلفية":
      return "background_image";
    case "موقع_الخلفية":
      return "background_position";
    case "تكرار_الخلفية":
      return "background_repeat";
    case "ارفاق_الخلفية":
      return "background_attachment";
    case "ملائمة_العنصر":
      return "object_fit";
    case "حجم_الخلفية":
      return "background_size";
    case "_آبل_حجم_الخلفية":
      return "_webkite_background_size";
    case "فائض":
      return "overflow";
    case "عتامة":
      return "opacity";
    case "اظهار":
      return "display";
    case "هامش":
      return "margin";
    case "هامش_علوي":
      return "margin_top";
    case "هامش_سفلي":
      return "margin_bottom";
    case "هامش_ايمن":
      return "margin_right";
    case "هامش_ايسر":
      return "margin_left";
    case "بطانة":
      return "padding";
    case "تحجيم_الصندوق":
      return "box_sizing";
    case "ضبط_المحتوى":
      return "justify_content";
    case "ضبط_العناصر":
      return "justify_items";
    case "ضبط_النص":
      return "text_justify";
    case "محاذاة_العناصر":
      return "align_items";
    case "محاذاة_النص":
      return "text_align";
    case "حجم_الخط":
      return "font_size";
    case "فصيلة_الخط":
      return "font_family";
    case "فجوة":
      return "gap";
    case "حدود":
      return "border";
    case "قطر_الحدود":
      return "border_radius";
    case "نسق_الحدود":
      return "border_style";
    case "حدود_خارجية":
      return "outline";
    case "موضع":
      return "position";
    case "تحريك":
      return "animation";
    case "تحول":
      return "transform";
    case "اعادة_تحجيم":
      return "resize";
    case "مصدر":
      return "src";
    case "نسبة_س_ص":
      return "aspect_ratio";
    case "مرن_باتجاه":
      return "flex_direction";
    case "شريط_التمرير_عرض":
      return "scrollbar_width";
    case "قدرة_اختيار_النص":
      return "user_select";
    case "_مايكروسوفت_قدرة_اختيار_النص":
      return "_ms_user_select";
    case "_آبل_قدرة_اختيار_النص":
      return "_webkit_user_select";
    case "_موزيلا_قدرة_اختيار_النص":
      return "_moz_user_select";
    case "خيال_الصندوق":
      return "box_shadow";
    case "_آبل_خيال_الصندوق":
      return "_webkit_box_shadow";
    case "_موزيلا_خيال_الصندوق":
      return "_moz_box_shadow";
    default:
      return id2;
  }
};
const CSS_value_en = (id2) => {
  switch (id2) {
    case "تلقائي":
      return "auto";
    case "حدود_الصندوق":
      return "border_box";
    case "بلا_قيمة":
      return "none";
    case "مطلق":
      return "absolute";
    case "مرن":
      return "flex";
    case "مخفي":
      return "hidden";
    case "مركز":
      return "center";
    case "مسافة_بين":
      return "space_between";
    case "بداية":
      return "start";
    case "نهاية":
      return "end";
    case "بارز":
      return "ridge";
    case "لا_نهاية":
      return "infinite";
    case "لا_تكرار":
      return "no_repeat";
    case "احتواء":
      return "contain";
    case "قطع":
      return "clip";
    case "ضعف":
      return "double";
    case "ضبط":
      return "justify";
    case "بين_الكلمات":
      return "inter_word";
    case "مهم":
      return "important";
    case "غير_مهم":
      return "!important";
    case "مثبت":
      return "fixed";
    case "من_اليمين":
      return "rtl";
    case "عمودي":
      return "column";
    case "افقي":
      return "row";
    case "سماوي_فاتح":
      return "lightskyblue";
    case "ابيض":
      return "white";
    case "اصفر":
      return "yellow";
    case "اسود":
      return "black";
    case "برتقالي":
      return "orange";
    default:
      return id2;
  }
};
const CSS_str_en = (id2) => {
  switch (id2) {
    case "متن":
      return "Body";
    case "صفحة_الشبكة":
      return "Html";
    default:
      return id2;
  }
};
class ArHtmlWriter {
  jsGen;
  constructor(jsGen) {
    jsGen.init();
    this.jsGen = jsGen;
    return this;
  }
  write_ar_html(el, page) {
    switch (el.id) {
      case "call":
        const id2 = el.v[0].v.v[1];
        const tag = HTML_tag_en[id2] || id2;
        const attrs = el.v[1] || [];
        const children = el.v[2] || [];
        if (tag === "br") {
          return page += "<br>";
        }
        switch (tag) {
          case "اختر":
            page = this.write_ar_css(attrs, page) + "} ";
            break;
          case "عرف_خط":
            page = this.write_ar_css_fontface(attrs, page);
            break;
          case "اطارات_رئيسية":
            page = this.write_ar_css_keyframes(attrs, children, page);
            break;
          default:
            page += \`<\${tag}\`;
            if (ELEMENTS_WITH_DIR.includes(tag)) {
              page += \` dir='rtl'\`;
            }
            attrs.forEach((attr, i) => {
              if (i === 0 && attr.id === "str") {
                page += \` id='\${attr.v.v[1]}'\`;
              } else if (attr.id === "named_arg") {
                const attr_name = HTML_attr_en(attr.v[0].v[1]);
                if (BOOL_ATTRS.includes(attr_name)) {
                  page += \` \${attr_name} \`;
                } else {
                  page += \` \${attr_name}= \`;
                  if (attr.v[1].id === "str") {
                    page += \`'\${attr.v[1].v.v[1]}'\`;
                  } else if (attr.v[1].id === "int" || attr.v[1].id === "float") {
                    const num = to_maghrib_num\$1(attr.v[1].v[0].v[1]);
                    const suffix = attr.v[1].v[1] ? CSS_suffix_en(attr.v[1].v[1].v[1]) || "" : "";
                    page += \`\${num}\${suffix}\`;
                  } else if (attr.v[1].id === "bool") {
                    page += \`\${HTML_attr_en(attr_name)}\`;
                  } else {
                    panic\$1("not supported: " + to_str\$1(attr));
                  }
                }
              } else {
                panic\$1("not supported: " + to_str\$1(attr));
              }
            });
            page += ">";
            children.forEach((c) => {
              page = this.write_ar_html(c, page);
            });
            page += \`</\${tag}>\`;
        }
        break;
      case "str":
        page += el.v.v[1];
        break;
      default:
        panic\$1("unknown html element: " + to_str\$1(el));
    }
    return page;
  }
  write_ar_css(attrs, page) {
    attrs.forEach((attr) => {
      const k = maybe_hyphenated(CSS_key_en(attr.v[0].v[1]));
      const v2 = attr.v[1];
      if (k === "element") {
        page = this.write_ar_css_selector(v2, page);
        page += " {";
      } else {
        page += \`\${k} : \`;
        page = this.write_ar_css_attr_value(v2, page);
        page += \`; \`;
      }
    });
    return page;
  }
  write_ar_css_selector(v2, page) {
    const translate = (path) => {
      const get_regexp = (k) => RegExp(\`(?<![p{L}\\\\p{N}_])\${k}(?![\\\\p{L}\\\\p{N}_])\`, "ug");
      Object.keys(HTML_tag_en).forEach((k) => {
        path = path.replaceAll(get_regexp(k), HTML_tag_en[k]);
      });
      Object.keys(CSS_pseudo_en).forEach((k) => {
        path = path.replaceAll(get_regexp(k), CSS_pseudo_en[k]);
      });
      return path;
    };
    if (is_list\$1(v2.v)) {
      page += " ";
      v2.v.forEach((selector, i) => {
        let path = selector.v.v[1];
        page += translate(path);
        if (i < v2.v.length - 1) {
          page += ",";
        }
      });
    } else {
      const path = v2.v.v[1];
      page += translate(path);
    }
    return page;
  }
  write_ar_css_attr_value(v2, page) {
    switch (v2.id) {
      case "bool":
        panic\$1();
        break;
      case "int":
      case "float":
        const num = to_maghrib_num\$1(v2.v[0].v[1]);
        const suffix = CSS_suffix_en(v2.v[1] && v2.v[1].v[1]) || "";
        page += num + suffix;
        break;
      case "prefix":
        page += v2.v.op.v;
        page = this.write_ar_css_attr_value(v2.v.opr, page);
        break;
      case "postfix":
        page = this.write_ar_css_attr_value(v2.v.opr, page);
        page += v2.v.op.v;
        break;
      case "str":
        page += CSS_str_en(v2.v.v[1]);
        break;
      case "ref":
        page += maybe_hyphenated(CSS_value_en(v2.v.v[1]));
        break;
      case "tuple":
        v2.v.forEach((el) => {
          page = this.write_ar_css_attr_value(el, page + " ");
        });
        break;
      case "call":
        const ref = CSS_fn_en(v2.v[0].v.v[1]);
        const args = v2.v[1];
        page += \` \${ref}(\`;
        args.forEach((arg) => {
          page = this.write_ar_css_attr_value(arg, page);
        });
        page += \`)\`;
        break;
      case "bin":
        this.jsGen.write_expr(v2);
        const code = this.jsGen.get_code();
        page += "\${" + code + "}".trim();
        break;
      default:
        panic\$1(\`not supported: html generations:  \${to_str\$1(v2)}\`);
    }
    return page;
  }
  write_ar_css_fontface(attrs, page) {
    page += \`@font-face { \`;
    page = this.write_ar_css(attrs, page);
    page += "}";
    return page;
  }
  write_ar_css_keyframes(attrs, children, page) {
    page += \` @keyframes \${attrs[0].v.v[1]} { \`;
    children && children.forEach((c) => {
      const ref = c.v[0].v.v[1];
      const v2 = CSS_value_en(c.v[1]);
      switch (ref) {
        case "عند":
          const percentage = v2[0];
          const attrs2 = v2[1].v || [];
          page = this.write_ar_css_attr_value(percentage, page);
          page += " {";
          attrs2.forEach((attr) => {
            if (attr.id === "named_tuple") {
              attr.v.forEach((el) => {
                const _k = maybe_hyphenated(CSS_key_en(el[0].v[1]));
                const _v = CSS_value_en(el[1]);
                page += \` \${_k} : \`;
                page = this.write_ar_css_attr_value(_v, page);
                page += \`; \`;
              });
            } else {
              const _k = maybe_hyphenated(CSS_key_en(attr[0].v[1]));
              const _v = CSS_value_en(attr[1]);
              page += \` \${_k} : \`;
              page = this.write_ar_css_attr_value(_v, page);
              page += \`; \`;
            }
          });
          page += "} ";
          break;
        default:
          panic\$1("unsupported element: " + to_str\$1(ref));
      }
    });
    page += "}";
    return page;
  }
}
function maybe_hyphenated(id2) {
  if (HYPHENATED.includes(id2)) {
    return id2.replaceAll("_", "-");
  } else {
    return id2;
  }
}
const MAGHRIB_DIGIT = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
function is_maghrib_num(n) {
  return contains(MAGHRIB_DIGIT, n[0]);
}
function to_maghrib_num(n) {
  if (!is_maghrib_num(n)) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "٠":
          v2 += "0";
          break;
        case "١":
          v2 += "1";
          break;
        case "٢":
          v2 += "2";
          break;
        case "٣":
          v2 += "3";
          break;
        case "٤":
          v2 += "4";
          break;
        case "٥":
          v2 += "5";
          break;
        case "٦":
          v2 += "6";
          break;
        case "٧":
          v2 += "7";
          break;
        case "٨":
          v2 += "8";
          break;
        case "٩":
          v2 += "9";
          break;
        case ",":
          v2 += ".";
          break;
        default:
          panic\$3();
      }
      i += 1;
    }
    return v2;
  } else {
    return n;
  }
}
function is_list(x) {
  return x instanceof Array;
}
function contains(list, el) {
  return list.includes(el);
}
function to_str(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function panic\$3(v2) {
  throw new Error(v2);
}
function repeat(str, times) {
  return str.repeat(times);
}
const HELPERS = \`
//------------------------------------------------------------------------------
// js helper functions injected to workaround missing seen features that are yet to be added.
function is_none(x) { return x == null }        
function is_list(x) { return x instanceof Array }
function replace(array, i, v) {  array[i] = v }
function to_int(str) { return parseInt(str) }
function assign(x,y) { x = y }
function concat(x,y,id) { x[id] = x[id].concat(y[id]) }
function del(array, i) { delete array[i] }
function regexp(expr) { return RegExp(expr, 'ug') }
function match_regexp(v, expr) {return expr.exec(v) }
function print(v) { throw new Error('print() is not implemeted')}
function اطبع_سطر(v) { println(v) }
function println(v) {         
    if(v == null ) { console.log("undefined") } else { console.log(v) }
}
function panic(v) { throw new Error(v)}
function clone(obj) { return {...obj} }
function contains(list, el) { return list.includes(el) }
function is_empty(list) { return Array.isArray(list) && list.length === 0 }
function اطبع_تفاصيل(obj, indent) { pprint(obj, indent) }
function pprint(obj, indent) { 
    if( obj == null ) {
        console.log("undefined")
    } else {
        if(indent) {
            console.log(JSON.stringify(obj, null, indent)) 
        } else {
            console.log(JSON.stringify(obj)) 
        }       
    }
}
function to_str(obj, indent) { 
let objects = []
function eliminateCircular(k, v) {
    if (v && typeof v === 'object') {
        if (objects.includes(v)) { return "[CIRCULAR]" } else { objects.push(v) }
    }
    return v
}
if(indent) {
    return JSON.stringify(obj, eliminateCircular, indent)
} else {
    return JSON.stringify(obj, eliminateCircular)
}
}
function repeat(str, times) { return str.repeat(times) }
function c0_to_uppercase(str){ return str.charAt(0).toUpperCase() + str.slice(1) }
function to_lowercase(str) {return str.toLowerCase()}
function عرض_اولي(code, preview_id){ preview(code, preview_id) }
function preview(code, preview_id) { window.parent.document.querySelector(preview_id).srcdoc = code }
function هات_الافرع(س) {
    return س.children
}
function اختر(س,دالة) {
    return س.filter(دالة)
}
function هات(ق,فهرس) { return ق[فهرس]}
function عدد_العناصر(ق) { return ق.length}
async function read_url(url) {
    const response = await fetch(url);
    return response.text()
}

//------------------------------------------------------------------------------
\`;
const AR_ID = {
  "بدء": "main",
  "اطبع_سطر": "println",
  "تعبير_نمطي": "regex",
  "هنا": "this",
  "مشيّد": "constructor",
  "انهاء": "panic"
};
const SPACES = 4;
class JSGen {
  current;
  indent_level;
  stack;
  astructs;
  ast;
  symtab;
  html_gen;
  main_args;
  opts;
  runtime;
  current_instance;
  init(lang2, ast, symtab, html_gen, main_args, opts2) {
    this.current = "";
    this.indent_level = 0;
    this.stack = [];
    this.astructs = [];
    this.ast = ast;
    this.symtab = symtab;
    this.html_gen = html_gen;
    this.main_args = main_args;
    this.opts = opts2;
    this.current_instance = null;
  }
  init_with_HTML(lang2, html_gen, ast, symtab, main_args, opts2) {
    this.init(lang2, ast, symtab, html_gen, main_args, opts2);
    this.html_gen = html_gen;
  }
  init_with_runtime(lang2, runtime, ast, symtab, main_args, opts2) {
    this.init(lang2, ast, symtab, null, main_args, opts2);
    this.runtime = runtime;
  }
  run() {
    this.strict_mode();
    let main;
    let i = 0;
    while (i < this.ast.length) {
      const n = this.ast[i];
      if (n) {
        const v2 = n.v;
        switch (n.id) {
          case "use":
            this.write_use(v2);
            break;
          case "modif":
            this.write_modifier(v2);
            break;
          case "main":
            main = v2;
            break;
          case "const":
            this.write_const(v2);
            break;
          case "fn":
            this.write_fn(v2);
            break;
          case "struct":
            this.write_struct(v2);
            break;
          case "enum":
            this.write_enum(v2);
            break;
          case "trait":
            this.write_trait(v2);
            break;
          case "trait_impl":
            this.write_trait_impl(v2);
            break;
          case "method":
            this.write_method(v2);
            break;
          default:
            panic\$3("unsupported node: " + this.ast[i].id);
        }
      }
      i += 1;
    }
    this.write_helper_fns();
    if (main) {
      this.write_main(main);
    }
    const code = this.get_code();
    return code;
  }
  to_en_id(id2) {
    if (!id2.v && !is_list(id2.v)) {
      return;
    }
    if (AR_ID[id2.v[1]]) {
      id2.v[1] = AR_ID[id2.v[1]];
    }
  }
  push() {
    this.stack.push(this.current);
    this.current = "";
  }
  pop() {
    this.current = this.stack.pop() + this.current;
  }
  pop_prepend() {
    this.current = this.current + this.stack.pop();
  }
  prepend(code) {
    this.current = code + this.current;
  }
  append(code) {
    this.current += code;
  }
  appendi(code) {
    this.current += this.spaces();
    this.current += code;
  }
  spaces(level) {
    if (!level) {
      level = this.indent_level;
    }
    return repeat(" ", level * SPACES);
  }
  strict_mode() {
    this.append('"use strict";\\n\\n');
  }
  write_id_pat(id2) {
    const v2 = id2.v.v[1];
    this.append(v2 === "_" ? "default" : v2);
  }
  write_char_pat(c) {
    this.append("'" + c.v.v[1] + "'");
  }
  write_str_pat(str) {
    this.append('"' + str.v.v[1] + '"');
  }
  write_tuple_pat(tuple) {
    this.append("(");
    let i = 0;
    while (i < tuple.v.length) {
      this.write_pat(tuple.v[i]);
      if (i < tuple.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(")");
  }
  write_pat(p) {
    switch (p.id) {
      case "id":
        this.write_id_pat(p);
        break;
      case "bool":
        this.append(p.v.v[1]);
        break;
      case "int":
      case "float":
        this.append(to_maghrib_num(p.v.v[1][0]));
        break;
      case "char":
        this.write_char_pat(p);
        break;
      case "str":
        this.write_str_pat(p);
        break;
      case "tuple":
        this.write_tuple_pat(p);
        break;
      case "_":
        this.append("default");
        break;
      default:
        panic\$3("unsupported pattern " + to_str(p));
    }
  }
  write_modifier(n) {
    if (this.opts.ignore_export) {
      return;
    }
    if (n.v === "+") {
      this.appendi("export ");
    }
  }
  write_use(n) {
    return;
  }
  write_main(_fn) {
    this.push();
    this.appendi("(");
    this.write_fn(_fn, this.main_args);
    this.appendi(")()\\n");
    this.pop();
  }
  write_params(params2) {
    this.append("(");
    let i = 0;
    while (i < params2.length) {
      if (i > 0) {
        this.append(", ");
      }
      this.write_pat(params2[i].v._pat);
      i += 1;
    }
    this.append(")");
  }
  write_do_block(block) {
    this.append(\`(()=>\`);
    this.write_block(block);
    this.append(\`)() 
\`);
  }
  write_block(block) {
    this.append(" {\\n");
    this.push();
    this.indent_level += 1;
    let i = 0;
    const length = block.v.length;
    while (i < length) {
      const stmt = block.v[i];
      this.write_stmt(stmt);
      i += 1;
    }
    this.pop();
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_fn(_fn, main_args) {
    this.push();
    if (_fn.t === "fn") {
      this.appendi("static ");
    }
    this.to_en_id(_fn.name);
    if (_fn.is_async) {
      this.append("async ");
    }
    this.append("function " + _fn.name.v[1]);
    if (main_args) {
      this.append("()");
    } else {
      this.write_params(_fn.params);
    }
    this.write_body(_fn.body, _fn.name === "main", main_args);
    this.pop();
  }
  write_method(_fn, instance) {
    this.push();
    this.to_en_id(_fn.name);
    if (_fn.is_async) {
      this.append("async ");
    }
    this.append(_fn.name.v[1]);
    this.write_params(_fn.params);
    this.current_instance = instance;
    this.write_body(_fn.body, false);
    this.current_instance = null;
    this.pop();
  }
  write_fields(fields) {
    const ids = [];
    fields.forEach((field) => {
      const id2 = field.v[0].v[1];
      ids.push(id2);
    });
    ids.forEach((id2) => {
      this.appendi(this.spaces() + "" + id2 + "\\n");
    });
    this.write_init(ids);
  }
  write_init(ids) {
    this.append("\\n");
    this.appendi("constructor(");
    let i = 0;
    while (i < ids.length) {
      this.append(ids[i]);
      if (i < ids.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(") {\\n");
    this.indent_level += 1;
    i = 0;
    while (i < ids.length) {
      this.appendi("this." + ids[i] + " = " + ids[i] + "\\n");
      i += 1;
    }
    this.appendi("return this\\n");
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  // write_typedef(_typedef) {
  //     this.appendi("class " + _typedef.name.v[1] + " {\\n")
  //     this.indent_level += 1
  //     if(_typedef.fields) { this.write_fields(_typedef.fields) }
  //     let fns = this.symtab.receivers[_typedef.name.v[1]]
  //     fns && fns.forEach( (data) => {
  //         const fn = data[0]
  //         const instance = data[1]
  //         this.write_method(fn.v, instance) // FIXME: names are confusing , write_fn is handling fn.v, not fn 
  //     })
  //     this.append('child(x) { return this.children[x] }')
  //     this.append('children() { return this.children }')
  //     this.indent_level -= 1
  //     this.appendi("}\\n\\n")
  // }
  write_struct(_struct) {
    this.appendi("class " + _struct.name.v[1] + " {\\n");
    if (_struct.fields) {
      this.write_fields(_struct.fields);
    }
    let fns = this.symtab.receivers[_struct.name.v[1]];
    fns && fns.forEach((data) => {
      const fn = data[0];
      const instance = data[1];
      this.write_method(fn.v, instance);
    });
    this.append("sn__(x) { return this.sn__[x] }");
    this.append("sn__() { return this.sn__}");
    this.appendi("}\\n\\n");
  }
  write_enum(_enum) {
    panic\$3("enum is not implemented yet.");
  }
  write_trait(_trait) {
    panic\$3("trait is not implemented yet.");
  }
  write_trait_impl(_trait_impl) {
    panic\$3("trait implementation is not implemented yet.");
  }
  write_method(_method) {
    panic\$3("method is not implemented yet.");
  }
  write_const(_const) {
    this.appendi("const ");
    this.write_pat(_const.lhs);
    this.append(" = ");
    this.write_expr(_const.rhs);
    this.append("\\n");
  }
  write_var(_var) {
    this.appendi("let ");
    this.write_pat(_var.lhs);
    if (_var.rhs) {
      this.append(" = ");
      this.write_expr(_var.rhs);
    }
    this.append("\\n");
  }
  write_ret(n) {
    this.append("return ");
    if (n.v) {
      this.write_expr(n.v);
    }
  }
  write_break(expr) {
    this.append("break");
  }
  write_stmt(stmt) {
    if (stmt.t === "expr") {
      this.appendi("");
      this.write_expr(stmt);
      this.append("\\n");
    } else if (stmt.id === "const") {
      this.write_const(stmt.v);
    } else if (stmt.id === "var") {
      this.write_var(stmt.v);
    } else if (stmt.id === "break") {
      this.write_break(stmt);
    } else {
      panic\$3("cannot write stmt: " + to_str(stmt));
    }
  }
  write_body(body, is_main, main_args) {
    this.append(" {\\n");
    this.push();
    this.indent_level += 1;
    if (main_args) {
      for (const [k, v2] of Object.entries(main_args)) {
        this.append(\`const \${k} = '\${v2}'
\`);
      }
    }
    let i = 0;
    const length = body.v.length;
    while (i < length) {
      const stmt = body.v[i];
      this.write_stmt(stmt);
      i += 1;
    }
    this.pop();
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_id(id2) {
    this.append(id2.v[1]);
  }
  write_ref(expr) {
    const _ref = expr.v.v[1];
    if (_ref === this.current_instance) {
      this.append("this");
    } else {
      this.append(_ref);
    }
  }
  write_str(expr) {
    const str = expr.v.v[1];
    const symbol2 = str.indexOf("\${") === -1 ? '"' : "\`";
    this.append(symbol2 + str + symbol2);
  }
  write_str_id(expr) {
    this.append(symbol + expr.v.v[1] + symbol);
  }
  is_call(expr) {
    return expr.v.id === "bin" && expr.v.v.op.v === "(";
  }
  write_iret(expr) {
    if (!(contains(["when", "while", "if", "for", "return"], expr.v.node) || expr.v.t === "()" || expr.v.t === "void" || expr.v.t === "" || this.is_call(expr) || expr.semicolon)) {
      this.append("return ");
    }
    if (this.is_call(expr)) {
      this.append("const temp_seen_var = ");
      this.write_expr(expr.v);
      this.append("\\n");
      this.append("return temp_seen_var");
    } else {
      this.write_expr(expr.v);
    }
  }
  write_list(expr) {
    this.append("[");
    let i = 0;
    const length = expr.v.length;
    while (i < length) {
      this.write_expr(expr.v[i]);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("]");
  }
  write_structl(expr) {
    const fields = expr.v;
    this.append("{");
    let i = 0;
    while (i < fields.length) {
      const field = fields[i];
      const key = field.k;
      if (key.v.v[1]) {
        this.write_id(key.v);
      } else {
        this.write_str_id(key.v);
      }
      const value = field.v;
      this.append(": ");
      this.write_expr(value);
      if (i < fields.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("}");
  }
  write_args(expr) {
    this.append("(");
    let i = 0;
    while (i < expr.v.length) {
      let _expr = expr.v[i];
      if (_expr.v.op && _expr.v.op.v === ":") {
        _expr = _expr.v.ropr;
      }
      this.write_expr(_expr);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(")");
  }
  write_named_arg(narg) {
    narg.v[0].v[1];
    const v2 = narg.v[1];
    this.write_expr(v2);
  }
  write_tuple(expr) {
    this.append("[");
    let i = 0;
    while (i < expr.v.length) {
      let arg = expr.v[i];
      if (arg.id === "narg") {
        arg = expr.v[i].v[1];
      }
      this.write_expr(arg);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("]");
  }
  write_named_tuple(expr) {
    this.append("{");
    expr.v.forEach((pair, i) => {
      const k = pair[0].v[1];
      const v2 = pair[1];
      this.append(k);
      this.append(": ");
      this.write_expr(v2);
      if (i < expr.v.length) {
        this.append(",");
      }
    });
    this.append("}");
  }
  write_when(expr) {
    this.appendi("switch(");
    this.write_expr(expr.v.expr);
    this.append(") {\\n");
    this.indent_level += 1;
    let i = 0;
    while (i < expr.v.arms.length) {
      const arm = expr.v.arms[i];
      const pats = arm.v.pats;
      const _expr = arm.v.expr;
      let j = 0;
      while (j < pats.length) {
        if (pats[j].id !== "_") {
          this.appendi("case ");
        }
        this.write_pat(pats[j]);
        this.append(" :\\n");
        j += 1;
      }
      this.indent_level += 1;
      this.appendi("");
      this.write_expr(_expr);
      this.append("\\n");
      this.appendi("break\\n");
      this.indent_level -= 1;
      i += 1;
    }
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_prefix_uni(expr) {
    const op = expr.v.op.v;
    switch (op) {
      case ".":
        {
          if (expr.v.opr.v.v[1] === "none") {
            this.append("null");
            return;
          } else {
            panic\$3("enum variants are not supported, found : (." + expr.v.opr.v.v[1] + ")");
          }
        }
        break;
      case "not":
        this.append("!");
        break;
      case "!":
      case "-":
        this.append(op);
        break;
      default:
        panic\$3("unsupported op: " + op);
        break;
    }
    this.write_expr(expr.v.opr);
  }
  write_pipe(stack) {
    while (stack.length > 0) {
      let expr = stack.pop();
      switch (expr.id) {
        case "ref":
          this.write_expr(expr);
          if (stack.length > 0) {
            this.append("(");
            this.write_pipe(stack);
            this.append(")");
          }
          break;
        case "call":
          const lhs = expr.v[0];
          const rhs = expr.v[1];
          this.write_expr(lhs);
          this.append("(");
          this.write_pipe(stack);
          if (this.current.slice(-1) !== "(" && rhs.length > 0) {
            this.append(", ");
          }
          rhs.forEach((el, i) => {
            this.write_expr(el);
            if (i < rhs.length - 1) {
              this.append(", ");
            }
          });
          this.append(")");
          break;
        case "int":
        case "float":
        case "str":
        case "[":
        case "tuple":
        case "named_tuple":
          this.write_expr(expr);
          break;
        default:
          throw new Error("syntax error |> :" + to_str(expr));
      }
    }
  }
  write_runtime_fn() {
  }
  write_call(expr) {
    pprint(expr);
    const runtime_impl = this.runtime && this.runtime.get_fn(expr);
    if (runtime_impl) {
      if (runtime_impl._import) {
        this.prepend(runtime_impl._import);
      }
      this.append(runtime_impl.code);
      return;
    }
    this.to_en_id(expr.v[0].v);
    if (expr.v[0].v.v[1] === "html") {
      const page = this.html_gen.en.write_html(expr, "");
      this.append(\` (() => \\\`\${page}\\\`)() \`);
      return;
    } else if (expr.v[0].v.v[1] === "صفحة_الشبكة") {
      const page = this.html_gen.ar.write_ar_html(expr, "");
      this.append(\`(() => \\\`\${page}\\\`)()\`);
      return;
    } else if (this.symtab.structs.includes(expr.v[0].v.v[1])) {
      this.append("new ");
    }
    this.write_expr(expr.v[0]);
    this.append("(");
    const args = expr.v[1];
    if (args) {
      args.forEach((arg, i) => {
        this.write_expr(arg);
        if (i < args.length - 1) {
          this.append(", ");
        }
      });
    }
    if (expr.v[2]) {
      if (args) {
        this.append(", ");
      }
      this.write_children(expr.v[2]);
    }
    this.append(")");
  }
  write_children(block) {
    if (!block || block.length === 0) {
      return;
    }
    this.append("[");
    block.forEach((expr) => {
      this.write_expr(expr);
      this.append(",");
    });
    this.append("]");
  }
  write_bin(expr) {
    const op = expr.v.op.v;
    switch (op) {
      case "[":
        this.write_expr(expr.v.lopr);
        this.append("[");
        this.write_expr(expr.v.ropr);
        this.append("]");
        break;
      case "=":
        this.write_expr(expr.v.lopr);
        this.append("=");
        this.write_expr(expr.v.ropr);
        break;
      case ":":
        this.appendi("let ");
        this.write_expr(expr.v.lopr);
        this.append("\\n");
        break;
      case "++":
        this.write_expr(expr.v.lopr);
        this.append("+");
        this.write_expr(expr.v.ropr);
        break;
      case "|>":
        throw new Error("|> not implemented");
      case "||>":
        throw new Error(" ||> : WIP , " + to_str(expr));
      case ":>":
        throw new Error(" :> : WIP , " + to_str(expr));
      case "==":
      case "!=":
      case "<":
      case "<=":
      case ">":
      case ">=":
      case "|":
      case "||":
      case "&":
      case "&&":
      case "+":
      case "-":
      case "/":
      case "*":
      case "+=":
      case "-=":
      case "*=":
      case "\\\\=":
      case ".":
        this.write_expr(expr.v.lopr);
        this.append(op);
        if (op === "==" || op === "!=") {
          this.append("=");
        }
        this.write_expr(expr.v.ropr);
        break;
      default:
        panic\$3("cannot write binary operation: " + to_str(expr));
        break;
    }
  }
  write_afn(expr) {
    this.push();
    this.write_params(expr.v.params);
    this.append("=>");
    this.write_body(expr.v.body);
    this.pop();
  }
  write_expr(expr) {
    if (expr.grouped) {
      this.append("(");
    }
    switch (expr.id) {
      case "void":
        this.append("null");
        break;
      case ";":
        break;
      case "ref":
        this.write_ref(expr);
        break;
      case "bool":
        this.append(expr.v.v[1]);
        break;
      case "int":
      case "float":
        this.append(to_maghrib_num(expr.v[0].v[1]));
        break;
      case "char":
        this.append("'" + expr.v.v[1] + "'");
        break;
      case "str":
        this.write_str(expr);
        break;
      case "return":
        this.write_ret(expr);
        break;
      case "iret":
        this.write_iret(expr);
        break;
      case "[":
        this.write_list(expr);
        break;
      case "{":
        this.write_structl(expr);
        break;
      case "args":
        this.write_args(expr);
        break;
      case "named_arg":
        this.write_named_arg(expr);
        break;
      case "tuple":
        this.write_tuple(expr);
        break;
      case "named_tuple":
        this.write_named_tuple(expr);
        break;
      case "when":
        this.write_when(expr);
        break;
      case "do_block":
        this.write_do_block(expr);
        break;
      case "block":
        this.write_block(expr);
        break;
      case "prefix":
        this.write_prefix_uni(expr);
        break;
      case "call":
        this.write_call(expr);
        break;
      case "bin":
        this.write_bin(expr);
        break;
      case "afn":
        this.write_afn(expr);
        break;
      default:
        panic\$3("cannot write expr: " + to_str(expr));
    }
    if (expr.grouped) {
      this.append(")");
    }
  }
  write_helper_fns() {
    this.append(HELPERS);
  }
  get_code() {
    return this.current;
  }
}
class HtmlCssJSGen {
  run(lang2, ast, symtab, main_args, opts2) {
    const en_html = new HtmlWriter(new JSGen());
    const ar_html = new ArHtmlWriter(new JSGen());
    const html_gen = {
      en: en_html,
      ar: ar_html
    };
    const js_gen = new JSGen();
    js_gen.init(
      lang2,
      ast,
      symtab,
      html_gen,
      main_args,
      opts2
    );
    return js_gen.run();
  }
}
class Gen {
  ast;
  symtab;
  main_args;
  target;
  target_opts;
  lang;
  init(ast, symtab, main_args, target, target_opts) {
    this.ast = ast;
    this.symtab = symtab;
    this.main_args = main_args;
    this.target = target;
    this.target_opts = target_opts;
  }
  // FIXME: setting lang separately , to avoid breaking the code for current release ,
  //              need to refactor later.
  set_lang(lang2) {
    this.lang = lang2;
  }
  async run() {
    let gen;
    const target = to_lowercase(this.target);
    if (target === "js") {
      gen = new HtmlCssJSGen();
    } else if (SUPPORTED_GEN.includes(target)) {
      const { default: Gen2 } = await import(url.pathToFileURL(this.target_opts.deps.path));
      gen = new Gen2();
    } else {
      panic\$2('target "' + this.target + '" is not supported');
    }
    return gen.run(
      this.lang || en,
      this.ast,
      this.symtab,
      this.main_args,
      this.target_opts
    );
  }
}
class Compiler {
  src;
  main_args;
  target;
  target_opts;
  lang;
  tokens;
  ast;
  symtab;
  gen_code;
  init(src, main_args, lang2, target_opts) {
    this.src = src;
    this.main_args = main_args;
    this.target = target_opts && target_opts.target || "js";
    this.target_opts = target_opts || {};
    this.lang = lang2 || "en";
  }
  init_ar(src, main_args, target_opts) {
    return this.init(src, main_args, "ar", target_opts);
  }
  async get_code() {
    if (!this.gen_code) {
      await this.run();
    }
    return this.gen_code;
  }
  async run() {
    this.scan(true);
    this.parse();
    await this.generate(this.target);
  }
  scan(ignore_cmts_ws) {
    const lexer = new Lexer();
    lexer.init(this.lang, this.src, ignore_cmts_ws);
    lexer.run();
    this.tokens = lexer.tokens;
    if (!is_empty(lexer.errs)) {
      pprint\$1(lexer.errs);
      panic\$2("");
    }
  }
  parse() {
    const parser = new Parser();
    parser.init(this.tokens);
    parser.run();
    this.ast = parser.ast;
    this.symtab = parser.symtab;
    if (!is_empty(parser.errs)) {
      pprint\$1(parser.errs);
      panic\$2("");
    }
  }
  semantic() {
    const semantic = new Semantic(this.ast, this.symtab);
    semantic.run();
    if (!is_empty(semantic.errs)) {
      pprint\$1(semantic.errs);
      panic\$2("");
    }
  }
  async generate(target) {
    const gen = new Gen();
    gen.init(this.ast, this.symtab, this.main_args, target, this.target_opts);
    gen.set_lang(this.lang);
    this.gen_code = await gen.run();
  }
}
const DEFAULT_DARK_THEME = "panda-syntax";
const DEFAULT_LIGHT_THEME = "ttcn_modified";
const USER_ALLOWED_OPTS = ["mode", "lang", "theme", "statusbar"];
const CODE_OPTS = {
  lang: "en",
  mode: "code",
  theme: "light",
  output: false,
  toolbar: false,
  readonly: true,
  statusbar: true,
  copy: false
};
const EDITOR_OPTS = {
  lang: "en",
  mode: "editor",
  theme: "light",
  output: true,
  toolbar: true,
  readonly: false,
  statusbar: true,
  copy: false
};
const userOpts = window.opts;
const optMode = userOpts.mode || "code";
let opts;
switch (optMode) {
  case "code":
    opts = CODE_OPTS;
    break;
  case "editor":
    opts = EDITOR_OPTS;
    break;
  default:
    throw new Error("invalid mode! : " + optMode);
}
let langFromURL = new URLSearchParams(window.location.search).get("lang");
let lang = langFromURL || userOpts.lang;
Object.keys(userOpts).forEach((k) => {
  if (!USER_ALLOWED_OPTS.includes(k)) {
    throw new Error("invalid option: " + k);
  }
  opts[k] = userOpts[k];
});
window.console["log"] = (data) => writeP(data);
window.console["error"] = (err) => {
  if (isChrome()) {
    writeP(err.stack, ERROR_COLOR);
  } else {
    writeP(err, ERROR_COLOR);
  }
};
const ERROR_COLOR = "rgb(217 83 77)";
const RUNNING_COLOR = "rgb(108 141 211)";
const jsBeautifyOptions = {
  "indent_size": "4",
  "indent_char": " ",
  "max_preserve_newlines": "5",
  "preserve_newlines": true,
  "keep_array_indentation": false,
  "break_chained_methods": false,
  "indent_scripts": "normal",
  "brace_style": "collapse",
  "space_before_conditional": false,
  "unescape_strings": false,
  "jslint_happy": false,
  "end_with_newline": false,
  "wrap_line_length": "0",
  "indent_inner_html": false,
  "comma_first": false,
  "e4x": false,
  "indent_empty_lines": false
};
const commonKeyMap = {
  "Ctrl-9": (cm) => cm.foldCode(cm.getCursor()),
  "Tab": () => indent(),
  "Shift-Tab": () => dedent(),
  "Ctrl-'": () => {
    insertChar("«»");
  },
  "Ctrl-0": () => {
    run();
  },
  "Ctrl-=": () => {
    increaseFont();
  },
  "Ctrl--": () => {
    decreaseFont();
  }
};
const CM_COMMANDS = ["findCtrl"];
const eval_div = document.querySelector("#eval");
const previewArea = document.querySelector("#preview_area");
const observer = new MutationObserver((mutationsList, observer2) => {
  if (onPageLoad) {
    onPageLoad = false;
  } else {
    showPreview();
  }
});
observer.observe(previewArea, { characterData: false, childList: true, attributes: true });
const editor = CodeMirror.fromTextArea(document.querySelector("#code"), {
  lineNumbers: true,
  lineWrapping: true,
  direction: getDir(lang),
  scrollbarStyle: "simple",
  indentUnit: 4,
  tabSize: 4,
  styleActiveLine: true,
  matchBrackets: true,
  autoCloseBrackets: true,
  lineNumberFormatter: lineNumberFormatter(getDir(lang)),
  extraKeys: {
    ...commonKeyMap
  },
  foldGutter: true,
  gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
  commands: CM_COMMANDS
});
const targetEditor = CodeMirror.fromTextArea(document.querySelector("#target_code"), {
  lineNumbers: true,
  lineWrapping: true,
  direction: "ltr",
  scrollbarStyle: "simple",
  indentUnit: 4,
  tabSize: 4,
  styleActiveLine: true,
  matchBrackets: true,
  autoCloseBrackets: true,
  mode: "javascript",
  lineNumberFormatter: lineNumberFormatter("ltr"),
  foldGutter: true,
  gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
  commands: CM_COMMANDS
});
targetEditor.setSize(460);
let keydown = {};
let isMaghrib;
let isArabic;
let fontSize;
let editorLang;
let projPath;
let onPageLoad;
function isChrome() {
  return navigator.userAgentData ? true : false;
}
function getDir(lang2) {
  return lang2 === "ar" ? "rtl" : "ltr";
}
const SAMPLE_CODE = {
  ar: \`دل بدء {
    اطبع_سطر(«السلام عليكم!»)  
}\`,
  en: \`fn main { 
    println('hello world') 
}\`
};
await init(lang);
await setupListeners();
async function init(langId) {
  isMaghrib = langId === "ar_m";
  isArabic = langId.startsWith("ar");
  let lang2 = langId.startsWith("ar") ? "ar" : "en";
  fontSize = 14;
  editorLang = lang2;
  projPath = "";
  onPageLoad = true;
  document.querySelector("#right_side").style.display = "none";
  document.querySelector("#preview").style.display = "none";
  document.querySelector("body").style.visibility = "hidden";
  await setEditorLang(lang2);
  document.querySelector("#left_side_label").innerText = editorLang === "ar" ? "س" : "seen";
  document.querySelector("#preview_label").innerText = editorLang === "ar" ? "العرض الأولي" : "Preview";
  setFontSize(fontSize);
  setTitle(lang2);
  setDirection(lang2);
  setLabels(INDEX_LABELS, lang2);
  setTooltipLabels(TOOLTIP_LABELS, lang2);
  setSyntaxHighlighter(lang2);
  editor.setValue(lang2 === "ar" ? SAMPLE_CODE.ar : SAMPLE_CODE.en);
  editor.clearHistory();
  arSetup(lang2);
  setCursorPosition(1, 1);
  if (projPath) {
    openProj(projPath);
  }
  await setTheme(opts.theme);
  if (isCodeMode()) {
    codeMode();
  }
  if (!opts.statusbar) {
    removeStatusBar();
  }
  document.querySelector("body").style.visibility = "visible";
}
function isCodeMode() {
  return opts.mode === "code";
}
function removeStatusBar() {
  document.querySelector("#status_bar").setAttribute("style", "display: none;");
}
function codeMode() {
  document.querySelector("#output_container").setAttribute("style", "display: none;");
  document.querySelector("#editor_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#left_side_titlebar").setAttribute("style", "display: none;");
  document.querySelector("#right_side_titlebar").setAttribute("style", "display: none;");
  document.querySelector("#tabs_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#tabs_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#side_by_side").setAttribute("style", "margin-top: 0;");
}
async function setEditorLang(lang2) {
  editorLang = lang2;
}
async function setTitle(lang2, text) {
  if (lang2 === "ar") {
    text = text === void 0 ? "محرر س" : text;
    document.title = text;
  } else {
    text = text === void 0 ? "Seen Editor" : text;
    document.title = text;
  }
}
async function arSetup(lang2) {
  if (lang2 === "ar") {
    document.querySelector("#left_side_label").innerText = "س";
    document.querySelector("#left_side_label").style.fontSize = "17px";
    document.querySelector("#left_side_label").style.marginLeft = "0px";
    document.querySelector("#left_side_label").style.marginRight = "5px";
    document.querySelector("#right_side_label").style.marginLeft = "0px";
    document.querySelector("#right_side_label").style.marginRight = "5px";
    document.querySelector("#right_side_close").style.cssFloat = "left";
    document.querySelector("#right_side_toolbar").style.cssFloat = "left";
    document.querySelector("#preview_label").style.marginLeft = "0px";
    document.querySelector("#preview_label").style.marginRight = "5px";
    document.querySelector("#preview_close").style.cssFloat = "left";
  }
}
async function setDirection(lang2) {
  let dir = getDir(lang2);
  editor.setOption("direction", dir);
  document.querySelector("html").setAttribute("dir", dir);
  document.querySelector("#container").setAttribute("dir", dir);
  document.querySelector("#editor_output").setAttribute("dir", dir);
  document.querySelector("#preview").setAttribute("dir", dir);
  document.querySelector("#preview_area").setAttribute("dir", dir);
  document.querySelector("#output").setAttribute("dir", dir);
  document.querySelector("#status_bar").setAttribute("dir", dir);
  document.querySelector("#status_bar").style.textAlign = dir === "rtl" ? "left" : "right";
}
function setCursorPosition(line, ch) {
  document.querySelector("#status_bar").textContent = editorLang === "ar" ? \`سطر \${toEasternDigits(line)}, عمودي \${toEasternDigits(ch)}\` : \`Ln \${line}, Col \${ch}\`;
}
function insertChar(char) {
  let c = char;
  if (isArabic) {
    const cursor = editor.doc.getCursor();
    const line = cursor.line;
    editor.doc.replaceRange(c, cursor);
    editor.doc.setCursor(line, cursor.ch + c.length);
  } else {
    return CodeMirror.Pass;
  }
}
function indent() {
  if (editor.somethingSelected()) {
    var sel = editor.getSelection("\\n");
    if (sel.length > 0 && (sel.indexOf("\\n") > -1 || sel.length === editor.getLine(editor.getCursor().line).length)) {
      editor.indentSelection("add");
      return CodeMirror.Pass;
    }
  }
  var spaces = Array(editor.getOption("indentUnit") + 1).join(" ");
  editor.replaceSelection(spaces);
}
function dedent() {
  editor.indentSelection("subtract");
}
function increaseFont() {
  fontSize++;
  setFontSize(fontSize);
}
function decreaseFont() {
  fontSize--;
  setFontSize(fontSize);
}
async function setThemeFromOptions() {
  let themes = document.querySelector("#theme");
  let name = themes.options[themes.selectedIndex].value;
  await setTheme(name);
}
async function setTheme(name) {
  if (name === "dark") {
    name = DEFAULT_DARK_THEME;
    document.querySelector("#theme").value = DEFAULT_DARK_THEME;
  } else if (name === "light") {
    name = DEFAULT_LIGHT_THEME;
    document.querySelector("#theme").value = "ttcn";
  }
  const updateThemeClass = (el, name2) => {
    [...el.classList].forEach((className) => {
      if (className.startsWith("cm-s")) {
        el.classList.remove(className);
      }
    });
    name2.split(" ").forEach((name3) => {
      el.classList.add(\`cm-s-\${name3}\`);
    });
  };
  editor.setOption("theme", name);
  targetEditor.setOption("theme", name);
  updateThemeClass(document.querySelector("#wrapper"), name);
  updateThemeClass(document.querySelector("#editor_output"), name);
  updateThemeClass(document.querySelector("#output"), name);
  setFooterTheme();
  const inherited = window.getComputedStyle(document.querySelector("#run")).getPropertyValue("color");
  document.querySelector("#theme").style.backgroundImage = \`url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!Font%20Awesome%20Free%206.6.0%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202024%20Fonticons,%20Inc.--%3e%3cpath%20fill='\${inherited}'%20d='M512%20256c0%20.9%200%201.8%200%202.7c-.4%2036.5-33.6%2061.3-70.1%2061.3L344%20320c-26.5%200-48%2021.5-48%2048c0%203.4%20.4%206.7%201%209.9c2.1%2010.2%206.5%2020%2010.8%2029.9c6.1%2013.8%2012.1%2027.5%2012.1%2042c0%2031.8-21.6%2060.7-53.4%2062c-3.5%20.1-7%20.2-10.6%20.2C114.6%20512%200%20397.4%200%20256S114.6%200%20256%200S512%20114.6%20512%20256zM128%20288a32%2032%200%201%200%20-64%200%2032%2032%200%201%200%2064%200zm0-96a32%2032%200%201%200%200-64%2032%2032%200%201%200%200%2064zM288%2096a32%2032%200%201%200%20-64%200%2032%2032%200%201%200%2064%200zm96%2096a32%2032%200%201%200%200-64%2032%2032%200%201%200%200%2064z'/%3e%3c/svg%3e")\`;
}
function setFooterTheme() {
  const status_bar = document.querySelector("#status_bar");
  const output_style = window.getComputedStyle(document.querySelector("#output"));
  status_bar.style.fontSize = output_style.getPropertyValue("font-size");
  status_bar.style.color = output_style.getPropertyValue("color");
  status_bar.style.backgroundColor = output_style.getPropertyValue("background-color");
}
function setFontSize(size) {
  let els = document.querySelectorAll(".CodeMirror");
  els = [...els, ...document.querySelectorAll("button")];
  els.push(document.querySelector("#status_bar"));
  els.forEach((el) => {
    el.style.fontSize = \`\${size}px\`;
  });
}
function setSyntaxHighlighter(lang2) {
  const mode = lang2 === "ar" ? "seen-ar" : "seen-en";
  editor.setOption("mode", mode);
}
function showRightSide() {
  document.querySelector("#right_side").style.display = "flex";
}
function hideRightSide() {
  document.querySelector("#right_side").style.display = "none";
}
function showPreview() {
  document.querySelector("#preview").style.display = "flex";
}
function hidePreview() {
  document.querySelector("#preview").style.display = "none";
}
function resetOutput() {
  output.replaceChildren();
}
function runInsideIframe(code) {
  eval_div.replaceChildren();
  const iframe = document.createElement("iframe");
  eval_div.appendChild(iframe);
  iframe.contentWindow || iframe;
  const iframe_doc = iframe.contentDocument || iframe.contentWindow.document;
  const html = \` <head>
        <script>window.console=window.parent.console<\\/script>
        <script>\${code}<\\/script>
      </head>
      <body>
      </body>\`;
  iframe_doc.open();
  iframe_doc.write(html);
  iframe_doc.close();
}
async function run() {
  hideRightSide();
  hidePreview();
  resetOutput();
  try {
    let compiler = await genJS();
    runInsideIframe(await compiler.get_code());
    const END = editorLang === "ar" ? "انتهى" : "End";
    writeP("\\n");
    writeP(\`--- \${END} ---
\`, RUNNING_COLOR);
  } catch (err) {
    console.error(err);
  }
}
async function closeRightSide() {
  hideRightSide();
  targetEditor.setValue("");
}
async function closePreview() {
  hidePreview();
  previewArea.replaceChildren();
}
async function js() {
  hidePreview();
  showRightSide();
  await genJS();
}
async function genJS() {
  let content = editor.getValue();
  let compiler = new Compiler();
  let target_opts = { ignore_export: true };
  const main_args = {
    preview_id: "#preview_area",
    معرف_منطقة_العرض: "#preview_area"
  };
  compiler.init(content, main_args, editorLang, target_opts);
  await compiler.run();
  document.querySelector("#right_side_label").innerText = editorLang === "ar" ? "نص البرنامج" : "Code";
  let code = js_beautify(compiler.gen_code, jsBeautifyOptions);
  targetEditor.setOption("mode", "javascript");
  targetEditor.setOption("direction", "ltr");
  targetEditor.setOption("lineNumberFormatter", lineNumberFormatter("ltr"));
  targetEditor.setValue(code);
  return compiler;
}
async function clear() {
  document.querySelector("#output").innerHTML = "";
}
async function setupListeners() {
  document.querySelector("body").addEventListener("keydown", (e) => handleKeydown(e));
  document.querySelector("body").addEventListener("keyup", (e) => {
    keydown[e.key] = false;
  });
  document.querySelector("#theme").addEventListener("change", () => setThemeFromOptions());
  document.querySelector("#run").addEventListener("click", () => run());
  document.querySelector("#srccode").addEventListener("click", () => js());
  document.querySelector("#right_side_close").addEventListener("click", () => closeRightSide());
  document.querySelector("#preview_close").addEventListener("click", () => closePreview());
  document.querySelector("#clear").addEventListener("click", () => clear());
  editor.on("cursorActivity", (args) => {
    let { line, ch } = editor.getCursor();
    line += 1;
    ch += 1;
    setCursorPosition(line, ch);
  });
}
function lineNumberFormatter(dir) {
  if (dir === "rtl") {
    return (n) => toEasternDigits(n);
  } else {
    return (n) => n;
  }
}
function handleKeydown(e) {
  keydown[e.key] = true;
  let keys = "";
  Object.entries(keydown).forEach(([k, v2]) => {
    if (keydown[k]) {
      keys += k;
    }
  });
  switch (keys.toLowerCase()) {
    case "0control":
    case "control0":
      run();
      break;
    case "-control":
    case "control-":
      increaseFont();
      break;
    case "=control":
    case "control=":
      decreaseFont();
      break;
  }
}
function writeOutput(el) {
  var output2 = document.querySelector("#output");
  output2.appendChild(el);
  output2.scrollTop = output2.scrollHeight;
}
function writeP(text, color) {
  if (text === "") {
    console.log("\\n");
  }
  if (isArabic) {
    if (text) {
      text = toArabicPunctuations(text);
    }
    if (!isMaghrib) {
      if (text) {
        text = toMashriqNumerals(text);
      }
    }
  }
  const p = document.createElement("p");
  p.textContent = text;
  p.setAttribute("dir", getDir(editorLang));
  p.style.whiteSpace = "pre-wrap";
  if (color) {
    p.style.color = color;
  }
  writeOutput(p);
}
function toArabicPunctuations(text) {
  const p = /["'](.*?)["']/gi;
  return text.toString().replace(p, (matched, g1) => {
    if (matched) {
      return \`«\${g1}»\`;
    } else {
      return text;
    }
  });
}
function toMashriqNumerals(text) {
  function toMashriqNum(n) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "0":
          v2 += "٠";
          break;
        case "1":
          v2 += "١";
          break;
        case "2":
          v2 += "٢";
          break;
        case "3":
          v2 += "٣";
          break;
        case "4":
          v2 += "٤";
          break;
        case "5":
          v2 += "٥";
          break;
        case "6":
          v2 += "٦";
          break;
        case "7":
          v2 += "٧";
          break;
        case "8":
          v2 += "٨";
          break;
        case "9":
          v2 += "٩";
          break;
        case ".":
          v2 += "٫";
          break;
        default:
          panic();
      }
      i += 1;
    }
    return v2;
  }
  const p = /([0123456789]+)(\\.)?([0123456789]+)?/gi;
  text = text.replace(p, (matched, g1, g2, g3) => {
    if (matched) {
      let v2 = \`\${toMashriqNum(g1)}\`;
      if (g2) {
        v2 += ",";
        if (g3) {
          v2 += \`\${toMashriqNum(g3)}\`;
        }
      }
      return v2;
    } else {
      return text;
    }
  });
  return text;
}
function panic(v2) {
  throw new Error(v2);
}
function setEditorValue(code) {
  editor.setValue(code);
}
window.setEditorValue = setEditorValue;
window.hideRightSide = hideRightSide;
window.hidePreview = hidePreview;
window.resetOutput = resetOutput;
window.setTheme = setTheme;
</script>
		<style rel="stylesheet" crossorigin>.CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor .CodeMirror-line::selection,.cm-fat-cursor .CodeMirror-line>span::selection,.cm-fat-cursor .CodeMirror-line>span>span::selection{background:transparent}.cm-fat-cursor .CodeMirror-line::-moz-selection,.cm-fat-cursor .CodeMirror-line>span::-moz-selection,.cm-fat-cursor .CodeMirror-line>span>span::-moz-selection{background:transparent}.cm-fat-cursor{caret-color:transparent}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;inset:-50px 0 0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error,.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:#ff96004d}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative;z-index:0}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;inset:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors,.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:#ff06}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}.CodeMirror-simplescroll-horizontal div,.CodeMirror-simplescroll-vertical div{position:absolute;background:#ccc;-moz-box-sizing:border-box;box-sizing:border-box;border:1px solid #bbb;border-radius:2px}.CodeMirror-simplescroll-horizontal,.CodeMirror-simplescroll-vertical{position:absolute;z-index:6;background:#eee}.CodeMirror-simplescroll-horizontal{bottom:0;left:0;height:8px}.CodeMirror-simplescroll-horizontal div{bottom:0;height:100%}.CodeMirror-simplescroll-vertical{right:0;top:0;width:8px}.CodeMirror-simplescroll-vertical div{right:0;width:100%}.CodeMirror-overlayscroll .CodeMirror-scrollbar-filler,.CodeMirror-overlayscroll .CodeMirror-gutter-filler{display:none}.CodeMirror-overlayscroll-horizontal div,.CodeMirror-overlayscroll-vertical div{position:absolute;background:#bcd;border-radius:3px}.CodeMirror-overlayscroll-horizontal,.CodeMirror-overlayscroll-vertical{position:absolute;z-index:6}.CodeMirror-overlayscroll-horizontal{bottom:0;left:0;height:6px}.CodeMirror-overlayscroll-horizontal div{bottom:0;height:100%}.CodeMirror-overlayscroll-vertical{right:0;top:0;width:6px}.CodeMirror-overlayscroll-vertical div{right:0;width:100%}.CodeMirror-foldmarker{color:#00f;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded{cursor:pointer}.CodeMirror-foldgutter-open:after{content:"▾"}.CodeMirror-foldgutter-folded:after{content:"▸"}.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;-webkit-box-shadow:2px 3px 5px rgba(0,0,0,.2);-moz-box-shadow:2px 3px 5px rgba(0,0,0,.2);box-shadow:2px 3px 5px #0003;border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}*{box-sizing:border-box}.CodeMirror{flex-grow:1;font-family:monospace;border:solid 1px}html,body{width:100%;height:100%;margin:0;padding:0}body{display:flex;flex-direction:column;font-family:monospace}#wrapper{flex-grow:1;display:flex;flex-direction:column;margin:0;padding:0}#container{flex-grow:1;display:flex;flex-direction:row}#project_label{margin-left:5px;margin-right:5px;border:1px solid}.icon{width:20px;height:20px}#theme{-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;padding-top:15px;font-size:0px;background:transparent;background-repeat:no-repeat;margin-top:1px;cursor:pointer}option{font-size:15px}#theme:focus{outline:none}#editor_output{flex-grow:1;display:flex;flex-direction:column}#side_by_side{display:flex;flex-grow:1;flex-direction:row;margin-top:5px}#preview{height:100%;flex-grow:1;display:flex;flex-direction:column;margin-left:5px;margin-right:5px;overflow:scroll;-webkit-scrollbar:none;-ms-overflow-style:none;scrollbar-width:none}#preview_area{border:none;display:flex;overflow:auto;outline:1px solid;height:100%;margin:5px}#left_side_label,#right_side_label{overflow:auto}#left_side,#right_side{display:flex;flex-direction:column;justify-content:stretch}#left_side{flex-grow:3;width:0}#right_side{flex-grow:auto}#tabs_toolbar{overflow:hidden;border-bottom:1px solid}.tab{flex-shrink:0;flex-grow:0;overflow:hidden;align-items:flex-start;cursor:pointer}#editor_toolbar{margin:5px}#left_side_toolbar{display:inline-block}#right_side_toolbar{overflow:hidden;float:right;display:inline-block}#path{margin-left:10px;border-bottom:1px solid}#output_area{display:flex;justify-content:space-between}#output_toolbar{margin-left:5px;margin-right:5px}#right_side_close{float:right;margin:0;line-height:0px}#preview_titlebar{display:flex;justify-content:space-between;padding-left:5px;padding-right:5px}#output{max-height:150px;overflow:auto;word-break:break-all;flex-grow:none}#status_bar{padding-right:5px;padding-left:5px}p{margin:5px 10px 0}.btn-link{cursor:pointer;background:none;border:none}.btn-link:hover{text-decoration:underline}button,select,option,.icon,.divider{color:inherit;background-color:inherit;border:none}button{cursor:pointer}button:hover,#theme:hover{filter:invert(50%) contrast(100%)}#eval{display:none}.divider{margin-top:25px;display:flex;flex-direction:row;-webkit-user-select:none;-ms-user-select:none;user-select:none}.divider-content{color:#6c8dd3;overflow:nowrap;text-align:center;text-justify:center}.divider-part{display:inline;border:.5px solid inherit;flex-grow:3}.cm-s-colorforth.CodeMirror{background:#000;color:#f8f8f8}.cm-s-colorforth .CodeMirror-gutters{background:#0a001f;border-right:1px solid #aaa}.cm-s-colorforth .CodeMirror-guttermarker{color:#ffbd40}.cm-s-colorforth .CodeMirror-guttermarker-subtle{color:#78846f}.cm-s-colorforth .CodeMirror-linenumber{color:#bababa}.cm-s-colorforth .CodeMirror-cursor{border-left:1px solid white}.cm-s-colorforth span.cm-comment{color:#ededed}.cm-s-colorforth span.cm-def{color:#ff1c1c;font-weight:700}.cm-s-colorforth span.cm-keyword{color:#ffd900}.cm-s-colorforth span.cm-builtin{color:#00d95a}.cm-s-colorforth span.cm-variable{color:#73ff00}.cm-s-colorforth span.cm-string{color:#007bff}.cm-s-colorforth span.cm-number{color:#00c4ff}.cm-s-colorforth span.cm-atom{color:#606060}.cm-s-colorforth span.cm-variable-2{color:#eee}.cm-s-colorforth span.cm-variable-3,.cm-s-colorforth span.cm-type{color:#ddd}.cm-s-colorforth span.cm-meta{color:#ff0}.cm-s-colorforth span.cm-qualifier{color:#fff700}.cm-s-colorforth span.cm-bracket{color:#cc7}.cm-s-colorforth span.cm-tag{color:#ffbd40}.cm-s-colorforth span.cm-attribute{color:#fff700}.cm-s-colorforth span.cm-error{color:red}.cm-s-colorforth div.CodeMirror-selected{background:#333d53}.cm-s-colorforth span.cm-compilation{background:#ffffff1f}.cm-s-colorforth .CodeMirror-activeline-background{background:#253540}.cm-s-eclipse span.cm-meta{color:#ff1717}.cm-s-eclipse span.cm-keyword{line-height:1em;font-weight:700;color:#7f0055}.cm-s-eclipse span.cm-atom{color:#219}.cm-s-eclipse span.cm-number{color:#164}.cm-s-eclipse span.cm-def{color:#00f}.cm-s-eclipse span.cm-variable{color:#000}.cm-s-eclipse span.cm-variable-2,.cm-s-eclipse span.cm-variable-3,.cm-s-eclipse span.cm-type{color:#0000c0}.cm-s-eclipse span.cm-property,.cm-s-eclipse span.cm-operator{color:#000}.cm-s-eclipse span.cm-comment{color:#3f7f5f}.cm-s-eclipse span.cm-string{color:#2a00ff}.cm-s-eclipse span.cm-string-2{color:#f50}.cm-s-eclipse span.cm-qualifier{color:#555}.cm-s-eclipse span.cm-builtin{color:#30a}.cm-s-eclipse span.cm-bracket{color:#cc7}.cm-s-eclipse span.cm-tag{color:#170}.cm-s-eclipse span.cm-attribute{color:#00c}.cm-s-eclipse span.cm-link{color:#219}.cm-s-eclipse span.cm-error{color:red}.cm-s-eclipse .CodeMirror-activeline-background{background:#e8f2ff}.cm-s-eclipse .CodeMirror-matchingbracket{outline:1px solid grey;color:#000!important}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483e}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:#49483efc}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:#49483efc}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0px}.cm-s-monokai .CodeMirror-guttermarker{color:#fff}.cm-s-monokai .CodeMirror-guttermarker-subtle,.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom,.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-comment.cm-attribute{color:#97b757}.cm-s-monokai span.cm-comment.cm-def{color:#bc9262}.cm-s-monokai span.cm-comment.cm-tag{color:#bc6283}.cm-s-monokai span.cm-comment.cm-type{color:#5998a6}.cm-s-monokai span.cm-property,.cm-s-monokai span.cm-attribute{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-builtin{color:#66d9ef}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header,.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-night.CodeMirror{background:#0a001f;color:#f8f8f8}.cm-s-night div.CodeMirror-selected{background:#447}.cm-s-night .CodeMirror-line::selection,.cm-s-night .CodeMirror-line>span::selection,.cm-s-night .CodeMirror-line>span>span::selection{background:#444477fc}.cm-s-night .CodeMirror-line::-moz-selection,.cm-s-night .CodeMirror-line>span::-moz-selection,.cm-s-night .CodeMirror-line>span>span::-moz-selection{background:#444477fc}.cm-s-night .CodeMirror-gutters{background:#0a001f;border-right:1px solid #aaa}.cm-s-night .CodeMirror-guttermarker{color:#fff}.cm-s-night .CodeMirror-guttermarker-subtle{color:#bbb}.cm-s-night .CodeMirror-linenumber{color:#f8f8f8}.cm-s-night .CodeMirror-cursor{border-left:1px solid white}.cm-s-night span.cm-comment{color:#8900d1}.cm-s-night span.cm-atom{color:#845dc4}.cm-s-night span.cm-number,.cm-s-night span.cm-attribute{color:#ffd500}.cm-s-night span.cm-keyword{color:#599eff}.cm-s-night span.cm-string{color:#37f14a}.cm-s-night span.cm-meta{color:#7678e2}.cm-s-night span.cm-variable-2,.cm-s-night span.cm-tag{color:#99b2ff}.cm-s-night span.cm-variable-3,.cm-s-night span.cm-def,.cm-s-night span.cm-type{color:#fff}.cm-s-night span.cm-bracket{color:#8da6ce}.cm-s-night span.cm-builtin,.cm-s-night span.cm-special{color:#ff9e59}.cm-s-night span.cm-link{color:#845dc4}.cm-s-night span.cm-error{color:#9d1e15}.cm-s-night .CodeMirror-activeline-background{background:#1c005a}.cm-s-night .CodeMirror-matchingbracket{outline:1px solid grey;color:#fff!important}.solarized.base03{color:#002b36}.solarized.base02{color:#073642}.solarized.base01{color:#586e75}.solarized.base00{color:#657b83}.solarized.base0{color:#839496}.solarized.base1{color:#93a1a1}.solarized.base2{color:#eee8d5}.solarized.base3{color:#fdf6e3}.solarized.solar-yellow{color:#b58900}.solarized.solar-orange{color:#cb4b16}.solarized.solar-red{color:#dc322f}.solarized.solar-magenta{color:#d33682}.solarized.solar-violet{color:#6c71c4}.solarized.solar-blue{color:#268bd2}.solarized.solar-cyan{color:#2aa198}.solarized.solar-green{color:#859900}.cm-s-solarized{line-height:1.45em;color-profile:sRGB;rendering-intent:auto}.cm-s-solarized.cm-s-dark{color:#839496;background-color:#002b36}.cm-s-solarized.cm-s-light{background-color:#fdf6e3;color:#657b83}.cm-s-solarized .CodeMirror-widget{text-shadow:none}.cm-s-solarized .cm-header{color:#586e75}.cm-s-solarized .cm-quote{color:#93a1a1}.cm-s-solarized .cm-keyword{color:#cb4b16}.cm-s-solarized .cm-atom,.cm-s-solarized .cm-number{color:#d33682}.cm-s-solarized .cm-def{color:#2aa198}.cm-s-solarized .cm-variable{color:#839496}.cm-s-solarized .cm-variable-2{color:#b58900}.cm-s-solarized .cm-variable-3,.cm-s-solarized .cm-type{color:#6c71c4}.cm-s-solarized .cm-property{color:#2aa198}.cm-s-solarized .cm-operator{color:#6c71c4}.cm-s-solarized .cm-comment{color:#586e75;font-style:italic}.cm-s-solarized .cm-string{color:#859900}.cm-s-solarized .cm-string-2{color:#b58900}.cm-s-solarized .cm-meta{color:#859900}.cm-s-solarized .cm-qualifier{color:#b58900}.cm-s-solarized .cm-builtin{color:#d33682}.cm-s-solarized .cm-bracket{color:#cb4b16}.cm-s-solarized .CodeMirror-matchingbracket{color:#859900}.cm-s-solarized .CodeMirror-nonmatchingbracket{color:#dc322f}.cm-s-solarized .cm-tag{color:#93a1a1}.cm-s-solarized .cm-attribute{color:#2aa198}.cm-s-solarized .cm-hr{color:transparent;border-top:1px solid #586e75;display:block}.cm-s-solarized .cm-link{color:#93a1a1;cursor:pointer}.cm-s-solarized .cm-special{color:#6c71c4}.cm-s-solarized .cm-em{color:#999;text-decoration:underline;text-decoration-style:dotted}.cm-s-solarized .cm-error,.cm-s-solarized .cm-invalidchar{color:#586e75;border-bottom:1px dotted #dc322f}.cm-s-solarized.cm-s-dark div.CodeMirror-selected{background:#073642}.cm-s-solarized.cm-s-dark.CodeMirror ::selection{background:#073642fc}.cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection,.cm-s-dark .CodeMirror-line>span::-moz-selection,.cm-s-dark .CodeMirror-line>span>span::-moz-selection{background:#073642fc}.cm-s-solarized.cm-s-light div.CodeMirror-selected{background:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-line::selection,.cm-s-light .CodeMirror-line>span::selection,.cm-s-light .CodeMirror-line>span>span::selection{background:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection,.cm-s-light .CodeMirror-line>span::-moz-selection,.cm-s-light .CodeMirror-line>span>span::-moz-selection{background:#eee8d5}.cm-s-solarized.CodeMirror{-moz-box-shadow:inset 7px 0 12px -6px #000;-webkit-box-shadow:inset 7px 0 12px -6px #000;box-shadow:inset 7px 0 12px -6px #000}.cm-s-solarized .CodeMirror-gutters{border-right:0}.cm-s-solarized.cm-s-dark .CodeMirror-gutters{background-color:#073642}.cm-s-solarized.cm-s-dark .CodeMirror-linenumber{color:#586e75}.cm-s-solarized.cm-s-light .CodeMirror-gutters{background-color:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-linenumber{color:#839496}.cm-s-solarized .CodeMirror-linenumber{padding:0 5px}.cm-s-solarized .CodeMirror-guttermarker-subtle{color:#586e75}.cm-s-solarized.cm-s-dark .CodeMirror-guttermarker{color:#ddd}.cm-s-solarized.cm-s-light .CodeMirror-guttermarker{color:#cb4b16}.cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text{color:#586e75}.cm-s-solarized .CodeMirror-cursor{border-left:1px solid #819090}.cm-s-solarized.cm-s-light.cm-fat-cursor .CodeMirror-cursor{background:#7e7}.cm-s-solarized.cm-s-light .cm-animate-fat-cursor{background-color:#7e7}.cm-s-solarized.cm-s-dark.cm-fat-cursor .CodeMirror-cursor{background:#586e75}.cm-s-solarized.cm-s-dark .cm-animate-fat-cursor{background-color:#586e75}.cm-s-solarized.cm-s-dark .CodeMirror-activeline-background{background:#ffffff0f}.cm-s-solarized.cm-s-light .CodeMirror-activeline-background{background:#0000000f}.cm-s-the-matrix.CodeMirror{background:#000;color:#0f0}.cm-s-the-matrix div.CodeMirror-selected{background:#2d2d2d}.cm-s-the-matrix .CodeMirror-line::selection,.cm-s-the-matrix .CodeMirror-line>span::selection,.cm-s-the-matrix .CodeMirror-line>span>span::selection{background:#2d2d2dfc}.cm-s-the-matrix .CodeMirror-line::-moz-selection,.cm-s-the-matrix .CodeMirror-line>span::-moz-selection,.cm-s-the-matrix .CodeMirror-line>span>span::-moz-selection{background:#2d2d2dfc}.cm-s-the-matrix .CodeMirror-gutters{background:#060;border-right:2px solid #00FF00}.cm-s-the-matrix .CodeMirror-guttermarker{color:#0f0}.cm-s-the-matrix .CodeMirror-guttermarker-subtle,.cm-s-the-matrix .CodeMirror-linenumber{color:#fff}.cm-s-the-matrix .CodeMirror-cursor{border-left:1px solid #00FF00}.cm-s-the-matrix span.cm-keyword{color:#008803;font-weight:700}.cm-s-the-matrix span.cm-atom{color:#3ff}.cm-s-the-matrix span.cm-number{color:#ffb94f}.cm-s-the-matrix span.cm-def{color:#99c}.cm-s-the-matrix span.cm-variable{color:#f6c}.cm-s-the-matrix span.cm-variable-2{color:#c6f}.cm-s-the-matrix span.cm-variable-3,.cm-s-the-matrix span.cm-type{color:#96f}.cm-s-the-matrix span.cm-property{color:#62ffa0}.cm-s-the-matrix span.cm-operator{color:#999}.cm-s-the-matrix span.cm-comment{color:#ccc}.cm-s-the-matrix span.cm-string{color:#39c}.cm-s-the-matrix span.cm-meta{color:#c9f}.cm-s-the-matrix span.cm-qualifier{color:#fff700}.cm-s-the-matrix span.cm-builtin{color:#30a}.cm-s-the-matrix span.cm-bracket{color:#cc7}.cm-s-the-matrix span.cm-tag{color:#ffbd40}.cm-s-the-matrix span.cm-attribute{color:#fff700}.cm-s-the-matrix span.cm-error{color:red}.cm-s-the-matrix .CodeMirror-activeline-background{background:#040}.cm-s-ttcn .cm-quote{color:#f00000}.cm-s-ttcn .cm-header,.cm-strong{font-weight:700}.cm-s-ttcn .cm-link{text-decoration:underline}.cm-s-ttcn .cm-header{color:#00f000;font-weight:700}.cm-s-ttcn .cm-atom{color:#219}.cm-s-ttcn .cm-attribute{color:#00c000}.cm-s-ttcn .cm-bracket{color:#997000}.cm-s-ttcn .cm-comment{color:green}.cm-s-ttcn .cm-def{color:#00f000}.cm-s-ttcn .cm-em{font-style:italic}.cm-s-ttcn .cm-error{color:#f00000}.cm-s-ttcn .cm-hr{color:#999000}.cm-s-ttcn .cm-keyword{color:purple;font-weight:700}.cm-s-ttcn .cm-link{color:#00c;text-decoration:underline}.cm-s-ttcn .cm-meta{color:#555000}.cm-s-ttcn .cm-negative{color:#d44000}.cm-s-ttcn .cm-positive{color:#292000}.cm-s-ttcn .cm-qualifier{color:#555000}.cm-s-ttcn .cm-strikethrough{text-decoration:line-through}.cm-s-ttcn .cm-string{color:#8b0000}.cm-s-ttcn .cm-string-2{color:#f50000}.cm-s-ttcn .cm-strong{font-weight:700}.cm-s-ttcn .cm-tag{color:#170}.cm-s-ttcn .cm-variable{color:olive}.cm-s-ttcn .cm-variable-2{color:#05a000}.cm-s-ttcn .cm-variable-3,.cm-s-ttcn .cm-type{color:#085000}.cm-s-ttcn .cm-invalidchar{color:#f00000}.cm-s-ttcn .cm-accessTypes,.cm-s-ttcn .cm-compareTypes{color:#27408b}.cm-s-ttcn .cm-cmipVerbs{color:#8b2252}.cm-s-ttcn .cm-modifier{color:#d2691e}.cm-s-ttcn .cm-status{color:#8b4545}.cm-s-ttcn .cm-storage{color:#a020f0}.cm-s-ttcn .cm-tags{color:#006400}.cm-s-ttcn .cm-externalCommands{color:#8b4545;font-weight:700}.cm-s-ttcn .cm-fileNCtrlMaskOptions,.cm-s-ttcn .cm-sectionTitle{color:#2e8b57;font-weight:700}.cm-s-ttcn .cm-booleanConsts,.cm-s-ttcn .cm-otherConsts,.cm-s-ttcn .cm-verdictConsts{color:#006400}.cm-s-ttcn .cm-configOps,.cm-s-ttcn .cm-functionOps,.cm-s-ttcn .cm-portOps,.cm-s-ttcn .cm-sutOps,.cm-s-ttcn .cm-timerOps,.cm-s-ttcn .cm-verdictOps{color:#00f}.cm-s-ttcn .cm-preprocessor,.cm-s-ttcn .cm-templateMatch,.cm-s-ttcn .cm-ttcn3Macros{color:#27408b}.cm-s-ttcn .cm-types{color:brown;font-weight:700}.cm-s-ttcn .cm-visibilityModifiers{font-weight:700}.cm-s-ayu-dark.CodeMirror{background:#0a0e14;color:#b3b1ad}.cm-s-ayu-dark div.CodeMirror-selected{background:#273747}.cm-s-ayu-dark .CodeMirror-line::selection,.cm-s-ayu-dark .CodeMirror-line>span::selection,.cm-s-ayu-dark .CodeMirror-line>span>span::selection{background:#273747}.cm-s-ayu-dark .CodeMirror-line::-moz-selection,.cm-s-ayu-dark .CodeMirror-line>span::-moz-selection,.cm-s-ayu-dark .CodeMirror-line>span>span::-moz-selection{background:#273747}.cm-s-ayu-dark .CodeMirror-gutters{background:#0a0e14;border-right:0px}.cm-s-ayu-dark .CodeMirror-guttermarker{color:#fff}.cm-s-ayu-dark .CodeMirror-guttermarker-subtle,.cm-s-ayu-dark .CodeMirror-linenumber{color:#3d424d}.cm-s-ayu-dark .CodeMirror-cursor{border-left:1px solid #e6b450}.cm-s-ayu-dark.cm-fat-cursor .CodeMirror-cursor,.cm-s-ayu-dark .cm-animate-fat-cursor{background-color:#a2a8a175!important}.cm-s-ayu-dark span.cm-comment{color:#626a73}.cm-s-ayu-dark span.cm-atom{color:#ae81ff}.cm-s-ayu-dark span.cm-number{color:#e6b450}.cm-s-ayu-dark span.cm-comment.cm-attribute{color:#ffb454}.cm-s-ayu-dark span.cm-comment.cm-def,.cm-s-ayu-dark span.cm-comment.cm-tag{color:#39bae6}.cm-s-ayu-dark span.cm-comment.cm-type{color:#5998a6}.cm-s-ayu-dark span.cm-property,.cm-s-ayu-dark span.cm-attribute{color:#ffb454}.cm-s-ayu-dark span.cm-keyword{color:#ff8f40}.cm-s-ayu-dark span.cm-builtin{color:#e6b450}.cm-s-ayu-dark span.cm-string{color:#c2d94c}.cm-s-ayu-dark span.cm-variable{color:#b3b1ad}.cm-s-ayu-dark span.cm-variable-2{color:#f07178}.cm-s-ayu-dark span.cm-variable-3{color:#39bae6}.cm-s-ayu-dark span.cm-type{color:#ff8f40}.cm-s-ayu-dark span.cm-def{color:#fe9}.cm-s-ayu-dark span.cm-bracket{color:#f8f8f2}.cm-s-ayu-dark span.cm-tag{color:#39bae6}.cm-s-ayu-dark span.cm-header{color:#c2d94c}.cm-s-ayu-dark span.cm-link{color:#39bae6}.cm-s-ayu-dark span.cm-error{color:#f33}.cm-s-ayu-dark .CodeMirror-activeline-background{background:#01060e}.cm-s-ayu-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-mbo.CodeMirror{background:#2c2c2c;color:#ffffec}.cm-s-mbo div.CodeMirror-selected{background:#716c62}.cm-s-mbo .CodeMirror-line::selection,.cm-s-mbo .CodeMirror-line>span::selection,.cm-s-mbo .CodeMirror-line>span>span::selection{background:#716c62fc}.cm-s-mbo .CodeMirror-line::-moz-selection,.cm-s-mbo .CodeMirror-line>span::-moz-selection,.cm-s-mbo .CodeMirror-line>span>span::-moz-selection{background:#716c62fc}.cm-s-mbo .CodeMirror-gutters{background:#4e4e4e;border-right:0px}.cm-s-mbo .CodeMirror-guttermarker{color:#fff}.cm-s-mbo .CodeMirror-guttermarker-subtle{color:gray}.cm-s-mbo .CodeMirror-linenumber{color:#dadada}.cm-s-mbo .CodeMirror-cursor{border-left:1px solid #ffffec}.cm-s-mbo span.cm-comment{color:#95958a}.cm-s-mbo span.cm-atom,.cm-s-mbo span.cm-number{color:#00a8c6}.cm-s-mbo span.cm-property,.cm-s-mbo span.cm-attribute{color:#9ddfe9}.cm-s-mbo span.cm-keyword{color:#ffb928}.cm-s-mbo span.cm-string{color:#ffcf6c}.cm-s-mbo span.cm-string.cm-property,.cm-s-mbo span.cm-variable{color:#ffffec}.cm-s-mbo span.cm-variable-2{color:#00a8c6}.cm-s-mbo span.cm-def{color:#ffffec}.cm-s-mbo span.cm-bracket{color:#fffffc;font-weight:700}.cm-s-mbo span.cm-tag{color:#9ddfe9}.cm-s-mbo span.cm-link{color:#f54b07}.cm-s-mbo span.cm-error{border-bottom:#636363;color:#ffffec}.cm-s-mbo span.cm-qualifier{color:#ffffec}.cm-s-mbo .CodeMirror-activeline-background{background:#494b41}.cm-s-mbo .CodeMirror-matchingbracket{color:#ffb928!important}.cm-s-mbo .CodeMirror-matchingtag{background:#ffffff5e}.cm-s-midnight .CodeMirror-activeline-background{background:#253540}.cm-s-midnight.CodeMirror{background:#0f192a;color:#d1edff}.cm-s-midnight div.CodeMirror-selected{background:#314d67}.cm-s-midnight .CodeMirror-line::selection,.cm-s-midnight .CodeMirror-line>span::selection,.cm-s-midnight .CodeMirror-line>span>span::selection{background:#314d67fc}.cm-s-midnight .CodeMirror-line::-moz-selection,.cm-s-midnight .CodeMirror-line>span::-moz-selection,.cm-s-midnight .CodeMirror-line>span>span::-moz-selection{background:#314d67fc}.cm-s-midnight .CodeMirror-gutters{background:#0f192a;border-right:1px solid}.cm-s-midnight .CodeMirror-guttermarker{color:#fff}.cm-s-midnight .CodeMirror-guttermarker-subtle,.cm-s-midnight .CodeMirror-linenumber{color:#d0d0d0}.cm-s-midnight .CodeMirror-cursor{border-left:1px solid #F8F8F0}.cm-s-midnight span.cm-comment{color:#428bdd}.cm-s-midnight span.cm-atom{color:#ae81ff}.cm-s-midnight span.cm-number{color:#d1edff}.cm-s-midnight span.cm-property,.cm-s-midnight span.cm-attribute{color:#a6e22e}.cm-s-midnight span.cm-keyword{color:#e83737}.cm-s-midnight span.cm-string{color:#1dc116}.cm-s-midnight span.cm-variable,.cm-s-midnight span.cm-variable-2{color:#ffaa3e}.cm-s-midnight span.cm-def{color:#4dd}.cm-s-midnight span.cm-bracket{color:#d1edff}.cm-s-midnight span.cm-tag{color:#449}.cm-s-midnight span.cm-link{color:#ae81ff}.cm-s-midnight span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-midnight .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-moxer.CodeMirror{background-color:#090a0f;color:#8e95b4;line-height:1.8}.cm-s-moxer .CodeMirror-gutters{background:#090a0f;color:#35394b;border:none}.cm-s-moxer .CodeMirror-guttermarker,.cm-s-moxer .CodeMirror-guttermarker-subtle,.cm-s-moxer .CodeMirror-linenumber{color:#35394b}.cm-s-moxer .CodeMirror-cursor{border-left:1px solid #FFCC00}.cm-s-moxer div.CodeMirror-selected{background:#80cbc433}.cm-s-moxer.CodeMirror-focused div.CodeMirror-selected{background:#212431}.cm-s-moxer .CodeMirror-line::selection,.cm-s-moxer .CodeMirror-line>span::selection,.cm-s-moxer .CodeMirror-line>span>span::selection{background:#212431}.cm-s-moxer .CodeMirror-line::-moz-selection,.cm-s-moxer .CodeMirror-line>span::-moz-selection,.cm-s-moxer .CodeMirror-line>span>span::-moz-selection{background:#212431}.cm-s-moxer .CodeMirror-activeline-background,.cm-s-moxer .CodeMirror-activeline-gutter .CodeMirror-linenumber{background:#21243180}.cm-s-moxer .cm-keyword,.cm-s-moxer .cm-operator{color:#d46c6c}.cm-s-moxer .cm-variable-2{color:#81c5da}.cm-s-moxer .cm-variable-3,.cm-s-moxer .cm-type{color:#f07178}.cm-s-moxer .cm-builtin{color:#ffcb6b}.cm-s-moxer .cm-atom{color:#a99be2}.cm-s-moxer .cm-number{color:#7ca4c0}.cm-s-moxer .cm-def{color:#f5dfa5}.cm-s-moxer .CodeMirror-line .cm-def~.cm-def{color:#81c5da}.cm-s-moxer .cm-string{color:#b2e4ae}.cm-s-moxer .cm-string-2{color:#f07178}.cm-s-moxer .cm-comment{color:#3f445a}.cm-s-moxer .cm-variable{color:#8e95b4}.cm-s-moxer .cm-tag{color:#ff5370}.cm-s-moxer .cm-meta{color:#ffcb6b}.cm-s-moxer .cm-attribute{color:#c792ea}.cm-s-moxer .cm-property{color:#81c5da}.cm-s-moxer .cm-qualifier,.cm-s-moxer .cm-variable-3,.cm-s-moxer .cm-type{color:#decb6b}.cm-s-moxer .cm-error{color:#fff;background-color:#ff5370}.cm-s-moxer .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-panda-syntax{background:#292a2b;color:#e6e6e6;font-family:Operator Mono,Source Code Pro,Menlo,Monaco,Consolas,Courier New,monospace}.cm-s-panda-syntax .CodeMirror-cursor{border-color:#ff2c6d}.cm-s-panda-syntax .CodeMirror-activeline-background{background:#637b9c1a}.cm-s-panda-syntax .CodeMirror-selected{background:#fff}.cm-s-panda-syntax .cm-comment{font-style:italic;color:#676b79}.cm-s-panda-syntax .cm-operator{color:#f3f3f3}.cm-s-panda-syntax .cm-string{color:#19f9d8}.cm-s-panda-syntax .cm-string-2{color:#ffb86c}.cm-s-panda-syntax .cm-tag{color:#ff2c6d}.cm-s-panda-syntax .cm-meta{color:#b084eb}.cm-s-panda-syntax .cm-number{color:#ffb86c}.cm-s-panda-syntax .cm-atom{color:#ff2c6d}.cm-s-panda-syntax .cm-keyword{color:#ff75b5}.cm-s-panda-syntax .cm-variable{color:#ffb86c}.cm-s-panda-syntax .cm-variable-2,.cm-s-panda-syntax .cm-variable-3,.cm-s-panda-syntax .cm-type{color:#ff9ac1}.cm-s-panda-syntax .cm-def{color:#e6e6e6}.cm-s-panda-syntax .cm-property{color:#f3f3f3}.cm-s-panda-syntax .cm-unit,.cm-s-panda-syntax .cm-attribute{color:#ffb86c}.cm-s-panda-syntax .CodeMirror-matchingbracket{border-bottom:1px dotted #19F9D8;padding-bottom:2px;color:#e6e6e6}.cm-s-panda-syntax .CodeMirror-gutters{background:#292a2b;border-right-color:#ffffff1a}.cm-s-panda-syntax .CodeMirror-linenumber{color:#e6e6e6;opacity:.6}.cm-s-tomorrow-night-eighties.CodeMirror{background:#000;color:#ccc}.cm-s-tomorrow-night-eighties div.CodeMirror-selected{background:#2d2d2d}.cm-s-tomorrow-night-eighties .CodeMirror-line::selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span::selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span>span::selection{background:#2d2d2dfc}.cm-s-tomorrow-night-eighties .CodeMirror-line::-moz-selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span::-moz-selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span>span::-moz-selection{background:#2d2d2dfc}.cm-s-tomorrow-night-eighties .CodeMirror-gutters{background:#000;border-right:0px}.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker{color:#f2777a}.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker-subtle{color:#777}.cm-s-tomorrow-night-eighties .CodeMirror-linenumber{color:#515151}.cm-s-tomorrow-night-eighties .CodeMirror-cursor{border-left:1px solid #6A6A6A}.cm-s-tomorrow-night-eighties span.cm-comment{color:#d27b53}.cm-s-tomorrow-night-eighties span.cm-atom,.cm-s-tomorrow-night-eighties span.cm-number{color:#a16a94}.cm-s-tomorrow-night-eighties span.cm-property,.cm-s-tomorrow-night-eighties span.cm-attribute{color:#9c9}.cm-s-tomorrow-night-eighties span.cm-keyword{color:#f2777a}.cm-s-tomorrow-night-eighties span.cm-string{color:#fc6}.cm-s-tomorrow-night-eighties span.cm-variable{color:#9c9}.cm-s-tomorrow-night-eighties span.cm-variable-2{color:#69c}.cm-s-tomorrow-night-eighties span.cm-def{color:#f99157}.cm-s-tomorrow-night-eighties span.cm-bracket{color:#ccc}.cm-s-tomorrow-night-eighties span.cm-tag{color:#f2777a}.cm-s-tomorrow-night-eighties span.cm-link{color:#a16a94}.cm-s-tomorrow-night-eighties span.cm-error{background:#f2777a;color:#6a6a6a}.cm-s-tomorrow-night-eighties .CodeMirror-activeline-background{background:#343600}.cm-s-tomorrow-night-eighties .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}
</style>
	</head>
	<body style="visibility: hidden;">
		<div id="wrapper" class="CodeMirror">
			<div id="container">							
				<div id="editor_output">
					<div id="tabs_toolbar">
					<div id="editor_toolbar">
						<div id="left_side_toolbar" >
							<button id="run">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 384 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80L0 432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>
							</button>
						</div>
						<div id="right_side_toolbar">
							<button id="srccode">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 640 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"/></svg>
							</button>
							<select name="theme" id="theme" class="icon">
								<option id="theme_ttcn" value="ttcn"></option>
								<option id="theme_default" value="default"></option>
								<option id="theme_solarized_light" value="solarized"></option>
								<option id="theme_eclipse" value="eclipse"></option>
								<option id="theme_midnight" value="midnight"></option>
								<option id="theme_panda_syntax" value="panda-syntax"></option>
								<option id="theme_tomorrow_night_eighties" value="tomorrow-night-eighties"></option>
								<option id="theme_night" value="night"></option>
								<option id="theme_colorforth" value="colorforth"></option>								
								<option id="theme_monokai" value="monokai"></option>
								<option id="theme_the_matrix" value="the-matrix"></option>
								<option id="theme_ayu_dark" value="ayu-dark"></option>
								<option id="theme_moxer" value="moxer"></option>
								<option id="theme_mbo" value="mbo"></option>						
							</select>					
						</div>
					</div>		
					</div>
					<div id="side_by_side">
						<div id="left_side">
							<div id="left_side_titlebar">
								<label id="left_side_label"></label>
								<span id="src_opts">
								</span>
							</div>
							<textarea id="code" name="code"></textarea>
					    </div>
						<div id="right_side">
							<div id = "right_side_titlebar">
								<label id="right_side_label"></label>
								 <button id="right_side_close">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/></svg>
								 </button>
							</div>
							<textarea id="target_code" name="target_code"></textarea>
						</div>
						<div id="preview">
							<div id="preview_titlebar">
								<label id="preview_label"></label>
								<button id="preview_close" class="icon" style="padding: 0px; margin: 0px;">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/></svg>
								</button>
							</div>
							<iframe id="preview_area"></iframe>							
							
						</div>
					</div>			
					<div id="output_container">
						<div id="output_area">
							<label id="output_label"></label>		
							<div id="output_toolbar">
								<button id="clear">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 576 512">!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M566.6 54.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192-34.7-34.7c-4.2-4.2-10-6.6-16-6.6c-12.5 0-22.6 10.1-22.6 22.6l0 29.1L364.3 320l29.1 0c12.5 0 22.6-10.1 22.6-22.6c0-6-2.4-11.8-6.6-16l-34.7-34.7 192-192zM341.1 353.4L222.6 234.9c-42.7-3.7-85.2 11.7-115.8 42.3l-8 8C76.5 307.5 64 337.7 64 369.2c0 6.8 7.1 11.2 13.2 8.2l51.1-25.5c5-2.5 9.5 4.1 5.4 7.9L7.3 473.4C2.7 477.6 0 483.6 0 489.9C0 502.1 9.9 512 22.1 512l173.3 0c38.8 0 75.9-15.4 103.4-42.8c30.6-30.6 45.9-73.1 42.3-115.8z"/></svg>
								</button>
							</div>		
						</div>	
						<div id="output" class="CodeMirror"></div>
					</div>
				</div>
			</div>
		</div>	
		<footer id="status_bar"></footer>		
		<div id="eval"></div>
	</body>
</html>`
                const iframe = document.createElement('iframe');
                iframe.id = id;
                iframe.sandbox = 'allow-forms allow-scripts allow-same-origin';
                iframe.setAttribute("style","width:100%; height: 100%;");
                // iframe.src = 'data:text/html,'; 
                parent.replaceChildren()
                parent.appendChild(iframe)
                const iframe_win = iframe.contentWindow || iframe;                
                // iframe_win.opts = opts ;
                iframe.srcdoc = ` ${code.replace("'%SEEN_EDITOR__OPTS%'", `${JSON.stringify(opts)}`)} `;
                return iframe
              }

              export function SeenCode(id, parent, opts) { 
                opts.mode = 'code'
                const code = `<!doctype html>
<html>
	<head>
		<meta charset="utf-8"/>

		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
		<meta http-equiv="Pragma" content="no-cache">
		<meta http-equiv="Expires" content="0">

		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="">
		<meta name="keywords" content=" ">		



		<script> window.opts = '%SEEN_EDITOR__OPTS%' </script>


		 				
		<script type="module">
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
})(void 0, function() {
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;
  var gecko = /gecko\\/\\d/i.test(userAgent);
  var ie_upto10 = /MSIE \\d/.test(userAgent);
  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);
  var edge = /Edge\\/(\\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\\//.test(userAgent);
  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);
  var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);
  var chrome_version = chrome && +chrome[1];
  var presto = /Opera\\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);
  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\\bCrOS\\b/.test(userAgent);
  var windows = /win/i.test(platform);
  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);
  if (presto_version) {
    presto_version = Number(presto_version[1]);
  }
  if (presto_version && presto_version >= 15) {
    presto = false;
    webkit = true;
  }
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || ie && ie_version >= 9;
  function classTest(cls) {
    return new RegExp("(^|\\\\s)" + cls + "(?:\$|\\\\s)\\\\s*");
  }
  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count) {
      e.removeChild(e.firstChild);
    }
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) {
      e.className = className;
    }
    if (style) {
      e.style.cssText = style;
    }
    if (typeof content == "string") {
      e.appendChild(document.createTextNode(content));
    } else if (content) {
      for (var i2 = 0; i2 < content.length; ++i2) {
        e.appendChild(content[i2]);
      }
    }
    return e;
  }
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e;
  }
  var range;
  if (document.createRange) {
    range = function(node, start, end, endNode) {
      var r = document.createRange();
      r.setEnd(endNode || node, end);
      r.setStart(node, start);
      return r;
    };
  } else {
    range = function(node, start, end) {
      var r = document.body.createTextRange();
      try {
        r.moveToElementText(node.parentNode);
      } catch (e) {
        return r;
      }
      r.collapse(true);
      r.moveEnd("character", end);
      r.moveStart("character", start);
      return r;
    };
  }
  function contains2(parent, child) {
    if (child.nodeType == 3) {
      child = child.parentNode;
    }
    if (parent.contains) {
      return parent.contains(child);
    }
    do {
      if (child.nodeType == 11) {
        child = child.host;
      }
      if (child == parent) {
        return true;
      }
    } while (child = child.parentNode);
  }
  function activeElt(doc2) {
    var activeElement;
    try {
      activeElement = doc2.activeElement;
    } catch (e) {
      activeElement = doc2.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
      activeElement = activeElement.shadowRoot.activeElement;
    }
    return activeElement;
  }
  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) {
      node.className += (current ? " " : "") + cls;
    }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i2 = 0; i2 < as.length; i2++) {
      if (as[i2] && !classTest(as[i2]).test(b)) {
        b += " " + as[i2];
      }
    }
    return b;
  }
  var selectInput = function(node) {
    node.select();
  };
  if (ios) {
    selectInput = function(node) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    };
  } else if (ie) {
    selectInput = function(node) {
      try {
        node.select();
      } catch (_e) {
      }
    };
  }
  function doc(cm) {
    return cm.display.wrapper.ownerDocument;
  }
  function win(cm) {
    return doc(cm).defaultView;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
      return f.apply(null, args);
    };
  }
  function copyObj(obj, target, overwrite) {
    if (!target) {
      target = {};
    }
    for (var prop2 in obj) {
      if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
        target[prop2] = obj[prop2];
      }
    }
    return target;
  }
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\\s\\u00a0]/);
      if (end == -1) {
        end = string.length;
      }
    }
    for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
      var nextTab = string.indexOf("	", i2);
      if (nextTab < 0 || nextTab >= end) {
        return n + (end - i2);
      }
      n += nextTab - i2;
      n += tabSize - n % tabSize;
      i2 = nextTab + 1;
    }
  }
  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function(self2) {
    self2.id = 0;
    if (self2.time <= +/* @__PURE__ */ new Date()) {
      self2.f();
    } else {
      setTimeout(self2.handler, self2.time - +/* @__PURE__ */ new Date());
    }
  };
  Delayed.prototype.set = function(ms, f) {
    this.f = f;
    var time = +/* @__PURE__ */ new Date() + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };
  function indexOf(array, elt2) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      if (array[i2] == elt2) {
        return i2;
      }
    }
    return -1;
  }
  var scrollerGap = 50;
  var Pass = { toString: function() {
    return "CodeMirror.Pass";
  } };
  var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0; ; ) {
      var nextTab = string.indexOf("	", pos);
      if (nextTab == -1) {
        nextTab = string.length;
      }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal) {
        return pos + Math.min(skipped, goal - col);
      }
      col += nextTab - pos;
      col += tabSize - col % tabSize;
      pos = nextTab + 1;
      if (col >= goal) {
        return pos;
      }
    }
  }
  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n) {
      spaceStrs.push(lst(spaceStrs) + " ");
    }
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function map(array, f) {
    var out = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      out[i2] = f(array[i2], i2);
    }
    return out;
  }
  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) {
      pos++;
    }
    array.splice(pos, 0, value);
  }
  function nothing() {
  }
  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) {
      copyObj(props, inst);
    }
    return inst;
  }
  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;
  function isWordCharBasic(ch) {
    return /\\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isWordChar(ch, helper) {
    if (!helper) {
      return isWordCharBasic(ch);
    }
    if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) {
      return true;
    }
    return helper.test(ch);
  }
  function isEmpty(obj) {
    for (var n in obj) {
      if (obj.hasOwnProperty(n) && obj[n]) {
        return false;
      }
    }
    return true;
  }
  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;
  function isExtendingChar(ch) {
    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
  }
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
      pos += dir;
    }
    return pos;
  }
  function findFirst(pred, from, to) {
    var dir = from > to ? -1 : 1;
    for (; ; ) {
      if (from == to) {
        return from;
      }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) {
        return pred(mid) ? from : to;
      }
      if (pred(mid)) {
        to = mid;
      } else {
        from = mid + dir;
      }
    }
  }
  function iterateBidiSections(order, from, to, f) {
    if (!order) {
      return f(from, to, "ltr", 0);
    }
    var found = false;
    for (var i2 = 0; i2 < order.length; ++i2) {
      var part = order[i2];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
        found = true;
      }
    }
    if (!found) {
      f(from, to, "ltr");
    }
  }
  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i2 = 0; i2 < order.length; ++i2) {
      var cur = order[i2];
      if (cur.from < ch && cur.to > ch) {
        return i2;
      }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") {
          found = i2;
        } else {
          bidiOther = i2;
        }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") {
          found = i2;
        } else {
          bidiOther = i2;
        }
      }
    }
    return found != null ? found : bidiOther;
  }
  var bidiOrdering = /* @__PURE__ */ function() {
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 247) {
        return lowTypes.charAt(code);
      } else if (1424 <= code && code <= 1524) {
        return "R";
      } else if (1536 <= code && code <= 1785) {
        return arabicTypes.charAt(code - 1536);
      } else if (1774 <= code && code <= 2220) {
        return "r";
      } else if (8192 <= code && code <= 8203) {
        return "w";
      } else if (code == 8204) {
        return "b";
      } else {
        return "L";
      }
    }
    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from;
      this.to = to;
    }
    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";
      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
        return false;
      }
      var len = str.length, types = [];
      for (var i2 = 0; i2 < len; ++i2) {
        types.push(charType(str.charCodeAt(i2)));
      }
      for (var i\$12 = 0, prev = outerType; i\$12 < len; ++i\$12) {
        var type2 = types[i\$12];
        if (type2 == "m") {
          types[i\$12] = prev;
        } else {
          prev = type2;
        }
      }
      for (var i\$22 = 0, cur = outerType; i\$22 < len; ++i\$22) {
        var type\$1 = types[i\$22];
        if (type\$1 == "1" && cur == "r") {
          types[i\$22] = "n";
        } else if (isStrong.test(type\$1)) {
          cur = type\$1;
          if (type\$1 == "r") {
            types[i\$22] = "R";
          }
        }
      }
      for (var i\$3 = 1, prev\$1 = types[0]; i\$3 < len - 1; ++i\$3) {
        var type\$2 = types[i\$3];
        if (type\$2 == "+" && prev\$1 == "1" && types[i\$3 + 1] == "1") {
          types[i\$3] = "1";
        } else if (type\$2 == "," && prev\$1 == types[i\$3 + 1] && (prev\$1 == "1" || prev\$1 == "n")) {
          types[i\$3] = prev\$1;
        }
        prev\$1 = type\$2;
      }
      for (var i\$4 = 0; i\$4 < len; ++i\$4) {
        var type\$3 = types[i\$4];
        if (type\$3 == ",") {
          types[i\$4] = "N";
        } else if (type\$3 == "%") {
          var end = void 0;
          for (end = i\$4 + 1; end < len && types[end] == "%"; ++end) {
          }
          var replace2 = i\$4 && types[i\$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
          for (var j = i\$4; j < end; ++j) {
            types[j] = replace2;
          }
          i\$4 = end - 1;
        }
      }
      for (var i\$5 = 0, cur\$1 = outerType; i\$5 < len; ++i\$5) {
        var type\$4 = types[i\$5];
        if (cur\$1 == "L" && type\$4 == "1") {
          types[i\$5] = "L";
        } else if (isStrong.test(type\$4)) {
          cur\$1 = type\$4;
        }
      }
      for (var i\$6 = 0; i\$6 < len; ++i\$6) {
        if (isNeutral.test(types[i\$6])) {
          var end\$1 = void 0;
          for (end\$1 = i\$6 + 1; end\$1 < len && isNeutral.test(types[end\$1]); ++end\$1) {
          }
          var before = (i\$6 ? types[i\$6 - 1] : outerType) == "L";
          var after = (end\$1 < len ? types[end\$1] : outerType) == "L";
          var replace\$1 = before == after ? before ? "L" : "R" : outerType;
          for (var j\$1 = i\$6; j\$1 < end\$1; ++j\$1) {
            types[j\$1] = replace\$1;
          }
          i\$6 = end\$1 - 1;
        }
      }
      var order = [], m;
      for (var i\$7 = 0; i\$7 < len; ) {
        if (countsAsLeft.test(types[i\$7])) {
          var start = i\$7;
          for (++i\$7; i\$7 < len && countsAsLeft.test(types[i\$7]); ++i\$7) {
          }
          order.push(new BidiSpan(0, start, i\$7));
        } else {
          var pos = i\$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i\$7; i\$7 < len && types[i\$7] != "L"; ++i\$7) {
          }
          for (var j\$2 = pos; j\$2 < i\$7; ) {
            if (countsAsNum.test(types[j\$2])) {
              if (pos < j\$2) {
                order.splice(at, 0, new BidiSpan(1, pos, j\$2));
                at += isRTL;
              }
              var nstart = j\$2;
              for (++j\$2; j\$2 < i\$7 && countsAsNum.test(types[j\$2]); ++j\$2) {
              }
              order.splice(at, 0, new BidiSpan(2, nstart, j\$2));
              at += isRTL;
              pos = j\$2;
            } else {
              ++j\$2;
            }
          }
          if (pos < i\$7) {
            order.splice(at, 0, new BidiSpan(1, pos, i\$7));
          }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\\s+\$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }
      return direction == "rtl" ? order.reverse() : order;
    };
  }();
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) {
      order = line.order = bidiOrdering(line.text, direction);
    }
    return order;
  }
  var noHandlers = [];
  var on = function(emitter, type2, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type2, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type2, f);
    } else {
      var map2 = emitter._handlers || (emitter._handlers = {});
      map2[type2] = (map2[type2] || noHandlers).concat(f);
    }
  };
  function getHandlers(emitter, type2) {
    return emitter._handlers && emitter._handlers[type2] || noHandlers;
  }
  function off(emitter, type2, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type2, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type2, f);
    } else {
      var map2 = emitter._handlers, arr = map2 && map2[type2];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1) {
          map2[type2] = arr.slice(0, index).concat(arr.slice(index + 1));
        }
      }
    }
  }
  function signal(emitter, type2) {
    var handlers = getHandlers(emitter, type2);
    if (!handlers.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i2 = 0; i2 < handlers.length; ++i2) {
      handlers[i2].apply(null, args);
    }
  }
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string") {
      e = { type: e, preventDefault: function() {
        this.defaultPrevented = true;
      } };
    }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }
  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) {
      return;
    }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i2 = 0; i2 < arr.length; ++i2) {
      if (indexOf(set, arr[i2]) == -1) {
        set.push(arr[i2]);
      }
    }
  }
  function hasHandler(emitter, type2) {
    return getHandlers(emitter, type2).length > 0;
  }
  function eventMixin(ctor) {
    ctor.prototype.on = function(type2, f) {
      on(this, type2, f);
    };
    ctor.prototype.off = function(type2, f) {
      off(this, type2, f);
    };
  }
  function e_preventDefault(e) {
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      e.cancelBubble = true;
    }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) {
        b = 1;
      } else if (e.button & 2) {
        b = 3;
      } else if (e.button & 4) {
        b = 2;
      }
    }
    if (mac && e.ctrlKey && b == 1) {
      b = 3;
    }
    return b;
  }
  var dragAndDrop = function() {
    if (ie && ie_version < 9) {
      return false;
    }
    var div = elt("div");
    return "draggable" in div || "dragDrop" in div;
  }();
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "​");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0) {
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
      }
    }
    var node = zwspSupported ? elt("span", "​") : elt("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node;
  }
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) {
      return badBidiRects;
    }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("AخA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) {
      return false;
    }
    return badBidiRects = r1.right - r0.right < 3;
  }
  var splitLinesAuto = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\\n", pos);
      if (nl == -1) {
        nl = string.length;
      }
      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);
      var rt = line.indexOf("\\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string) {
    return string.split(/\\r\\n?|\\n/);
  };
  var hasSelection = window.getSelection ? function(te) {
    try {
      return te.selectionStart != te.selectionEnd;
    } catch (e) {
      return false;
    }
  } : function(te) {
    var range2;
    try {
      range2 = te.ownerDocument.selection.createRange();
    } catch (e) {
    }
    if (!range2 || range2.parentElement() != te) {
      return false;
    }
    return range2.compareEndPoints("StartToEnd", range2) != 0;
  };
  var hasCopyEvent = function() {
    var e = elt("div");
    if ("oncopy" in e) {
      return true;
    }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  }();
  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) {
      return badZoomedRects;
    }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
  }
  var modes = {}, mimeModes = {};
  function defineMode(name, mode) {
    if (arguments.length > 2) {
      mode.dependencies = Array.prototype.slice.call(arguments, 2);
    }
    modes[name] = mode;
  }
  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") {
        found = { name: found };
      }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml\$/.test(spec)) {
      return resolveMode("application/xml");
    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+json\$/.test(spec)) {
      return resolveMode("application/json");
    }
    if (typeof spec == "string") {
      return { name: spec };
    } else {
      return spec || { name: "null" };
    }
  }
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) {
      return getMode(options, "text/plain");
    }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop2 in exts) {
        if (!exts.hasOwnProperty(prop2)) {
          continue;
        }
        if (modeObj.hasOwnProperty(prop2)) {
          modeObj["_" + prop2] = modeObj[prop2];
        }
        modeObj[prop2] = exts[prop2];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) {
      modeObj.helperType = spec.helperType;
    }
    if (spec.modeProps) {
      for (var prop\$1 in spec.modeProps) {
        modeObj[prop\$1] = spec.modeProps[prop\$1];
      }
    }
    return modeObj;
  }
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  }
  function copyState(mode, state) {
    if (state === true) {
      return state;
    }
    if (mode.copyState) {
      return mode.copyState(state);
    }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) {
        val = val.concat([]);
      }
      nstate[n] = val;
    }
    return nstate;
  }
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) {
        break;
      }
      state = info.state;
      mode = info.mode;
    }
    return info || { mode, state };
  }
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };
  StringStream.prototype.eol = function() {
    return this.pos >= this.string.length;
  };
  StringStream.prototype.sol = function() {
    return this.pos == this.lineStart;
  };
  StringStream.prototype.peek = function() {
    return this.string.charAt(this.pos) || void 0;
  };
  StringStream.prototype.next = function() {
    if (this.pos < this.string.length) {
      return this.string.charAt(this.pos++);
    }
  };
  StringStream.prototype.eat = function(match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") {
      ok = ch == match;
    } else {
      ok = ch && (match.test ? match.test(ch) : match(ch));
    }
    if (ok) {
      ++this.pos;
      return ch;
    }
  };
  StringStream.prototype.eatWhile = function(match) {
    var start = this.pos;
    while (this.eat(match)) {
    }
    return this.pos > start;
  };
  StringStream.prototype.eatSpace = function() {
    var start = this.pos;
    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {
      ++this.pos;
    }
    return this.pos > start;
  };
  StringStream.prototype.skipToEnd = function() {
    this.pos = this.string.length;
  };
  StringStream.prototype.skipTo = function(ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  };
  StringStream.prototype.backUp = function(n) {
    this.pos -= n;
  };
  StringStream.prototype.column = function() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.indentation = function() {
    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
  };
  StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function(str) {
        return caseInsensitive ? str.toLowerCase() : str;
      };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) {
          this.pos += pattern.length;
        }
        return true;
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) {
        return null;
      }
      if (match && consume !== false) {
        this.pos += match[0].length;
      }
      return match;
    }
  };
  StringStream.prototype.current = function() {
    return this.string.slice(this.start, this.pos);
  };
  StringStream.prototype.hideFirstChars = function(n, inner) {
    this.lineStart += n;
    try {
      return inner();
    } finally {
      this.lineStart -= n;
    }
  };
  StringStream.prototype.lookAhead = function(n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n);
  };
  StringStream.prototype.baseToken = function() {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos);
  };
  function getLine(doc2, n) {
    n -= doc2.first;
    if (n < 0 || n >= doc2.size) {
      throw new Error("There is no line " + (n + doc2.first) + " in the document.");
    }
    var chunk = doc2;
    while (!chunk.lines) {
      for (var i2 = 0; ; ++i2) {
        var child = chunk.children[i2], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc2, start, end) {
    var out = [], n = start.line;
    doc2.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) {
        text = text.slice(0, end.ch);
      }
      if (n == start.line) {
        text = text.slice(start.ch);
      }
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc2, from, to) {
    var out = [];
    doc2.iter(from, to, function(line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) {
      for (var n = line; n; n = n.parent) {
        n.height += diff;
      }
    }
  }
  function lineNo(line) {
    if (line.parent == null) {
      return null;
    }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i2 = 0; ; ++i2) {
        if (chunk.children[i2] == cur) {
          break;
        }
        no += chunk.children[i2].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i\$12 = 0; i\$12 < chunk.children.length; ++i\$12) {
        var child = chunk.children[i\$12], ch = child.height;
        if (h < ch) {
          chunk = child;
          continue outer;
        }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    var i2 = 0;
    for (; i2 < chunk.lines.length; ++i2) {
      var line = chunk.lines[i2], lh = line.height;
      if (h < lh) {
        break;
      }
      h -= lh;
    }
    return n + i2;
  }
  function isLine(doc2, l) {
    return l >= doc2.first && l < doc2.first + doc2.size;
  }
  function lineNumberFor(options, i2) {
    return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
  }
  function Pos(line, ch, sticky) {
    if (sticky === void 0) sticky = null;
    if (!(this instanceof Pos)) {
      return new Pos(line, ch, sticky);
    }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }
  function cmp(a, b) {
    return a.line - b.line || a.ch - b.ch;
  }
  function equalCursorPos(a, b) {
    return a.sticky == b.sticky && cmp(a, b) == 0;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function maxPos(a, b) {
    return cmp(a, b) < 0 ? b : a;
  }
  function minPos(a, b) {
    return cmp(a, b) < 0 ? a : b;
  }
  function clipLine(doc2, n) {
    return Math.max(doc2.first, Math.min(n, doc2.first + doc2.size - 1));
  }
  function clipPos(doc2, pos) {
    if (pos.line < doc2.first) {
      return Pos(doc2.first, 0);
    }
    var last = doc2.first + doc2.size - 1;
    if (pos.line > last) {
      return Pos(last, getLine(doc2, last).text.length);
    }
    return clipToLen(pos, getLine(doc2, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) {
      return Pos(pos.line, linelen);
    } else if (ch < 0) {
      return Pos(pos.line, 0);
    } else {
      return pos;
    }
  }
  function clipPosArray(doc2, array) {
    var out = [];
    for (var i2 = 0; i2 < array.length; i2++) {
      out[i2] = clipPos(doc2, array[i2]);
    }
    return out;
  }
  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };
  var Context = function(doc2, state, line, lookAhead) {
    this.state = state;
    this.doc = doc2;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };
  Context.prototype.lookAhead = function(n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) {
      this.maxLookAhead = n;
    }
    return line;
  };
  Context.prototype.baseToken = function(n) {
    if (!this.baseTokens) {
      return null;
    }
    while (this.baseTokens[this.baseTokenPos] <= n) {
      this.baseTokenPos += 2;
    }
    var type2 = this.baseTokens[this.baseTokenPos + 1];
    return {
      type: type2 && type2.replace(/( |^)overlay .*/, ""),
      size: this.baseTokens[this.baseTokenPos] - n
    };
  };
  Context.prototype.nextLine = function() {
    this.line++;
    if (this.maxLookAhead > 0) {
      this.maxLookAhead--;
    }
  };
  Context.fromSaved = function(doc2, saved, line) {
    if (saved instanceof SavedContext) {
      return new Context(doc2, copyState(doc2.mode, saved.state), line, saved.lookAhead);
    } else {
      return new Context(doc2, copyState(doc2.mode, saved), line);
    }
  };
  Context.prototype.save = function(copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
  };
  function highlightLine(cm, line, context, forceToEnd) {
    var st = [cm.state.modeGen], lineClasses = {};
    runMode(
      cm,
      line.text,
      cm.doc.mode,
      context,
      function(end, style) {
        return st.push(end, style);
      },
      lineClasses,
      forceToEnd
    );
    var state = context.state;
    var loop = function(o2) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function(end, style) {
        var start = i2;
        while (at < end) {
          var i_end = st[i2];
          if (i_end > end) {
            st.splice(i2, 1, end, st[i2 + 1], i_end);
          }
          i2 += 2;
          at = Math.min(end, i_end);
        }
        if (!style) {
          return;
        }
        if (overlay.opaque) {
          st.splice(start, i2 - start, end, "overlay " + style);
          i2 = start + 2;
        } else {
          for (; start < i2; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };
    for (var o = 0; o < cm.state.overlays.length; ++o) loop(o);
    return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
  }
  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) {
        context.state = resetState;
      }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) {
        line.styleClasses = result.classes;
      } else if (line.styleClasses) {
        line.styleClasses = null;
      }
      if (updateFrontier === cm.doc.highlightFrontier) {
        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
      }
    }
    return line.styles;
  }
  function getContextBefore(cm, n, precise) {
    var doc2 = cm.doc, display = cm.display;
    if (!doc2.mode.startState) {
      return new Context(doc2, true, n);
    }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc2.first && getLine(doc2, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc2, saved, start) : new Context(doc2, startState(doc2.mode), start);
    doc2.iter(start, n, function(line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) {
      doc2.modeFrontier = context.line;
    }
    return context;
  }
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") {
      callBlankLine(mode, context.state);
    }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }
  function callBlankLine(mode, state) {
    if (mode.blankLine) {
      return mode.blankLine(state);
    }
    if (!mode.innerMode) {
      return;
    }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) {
      return inner.mode.blankLine(inner.state);
    }
  }
  function readToken(mode, stream, state, inner) {
    for (var i2 = 0; i2 < 10; i2++) {
      if (inner) {
        inner[0] = innerMode(mode, state).mode;
      }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) {
        return style;
      }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.");
  }
  var Token2 = function(stream, type2, state) {
    this.start = stream.start;
    this.end = stream.pos;
    this.string = stream.current();
    this.type = type2 || null;
    this.state = state;
  };
  function takeToken(cm, pos, precise, asArray) {
    var doc2 = cm.doc, mode = doc2.mode, style;
    pos = clipPos(doc2, pos);
    var line = getLine(doc2, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) {
      tokens = [];
    }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) {
        tokens.push(new Token2(stream, style, copyState(doc2.mode, context.state)));
      }
    }
    return asArray ? tokens : new Token2(stream, style, context.state);
  }
  function extractLineClasses(type2, output2) {
    if (type2) {
      for (; ; ) {
        var lineClass = type2.match(/(?:^|\\s+)line-(background-)?(\\S+)/);
        if (!lineClass) {
          break;
        }
        type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
        var prop2 = lineClass[1] ? "bgClass" : "textClass";
        if (output2[prop2] == null) {
          output2[prop2] = lineClass[2];
        } else if (!new RegExp("(?:^|\\\\s)" + lineClass[2] + "(?:\$|\\\\s)").test(output2[prop2])) {
          output2[prop2] += " " + lineClass[2];
        }
      }
    }
    return type2;
  }
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) {
      flattenSpans = cm.options.flattenSpans;
    }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") {
      extractLineClasses(callBlankLine(mode, context.state), lineClasses);
    }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) {
          processLine(cm, text, context, stream.pos);
        }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) {
          style = "m-" + (style ? mName + " " + style : mName);
        }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5e3);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      var pos = Math.min(stream.pos, curStart + 5e3);
      f(pos, curStyle);
      curStart = pos;
    }
  }
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc2 = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc2.first) {
        return doc2.first;
      }
      var line = getLine(doc2, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc2.modeFrontier)) {
        return search;
      }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function retreatFrontier(doc2, n) {
    doc2.modeFrontier = Math.min(doc2.modeFrontier, n);
    if (doc2.highlightFrontier < n - 10) {
      return;
    }
    var start = doc2.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc2, line).stateAfter;
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break;
      }
    }
    doc2.highlightFrontier = Math.min(doc2.highlightFrontier, start);
  }
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }
  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }
  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from;
    this.to = to;
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans) {
      for (var i2 = 0; i2 < spans.length; ++i2) {
        var span = spans[i2];
        if (span.marker == marker) {
          return span;
        }
      }
    }
  }
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i2 = 0; i2 < spans.length; ++i2) {
      if (spans[i2] != span) {
        (r || (r = [])).push(spans[i2]);
      }
    }
    return r;
  }
  function addMarkedSpan(line, span, op) {
    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {
      line.markedSpans.push(span);
    } else {
      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
      if (inThisOp) {
        inThisOp.add(line.markedSpans);
      }
    }
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) {
      for (var i2 = 0; i2 < old.length; ++i2) {
        var span = old[i2], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
        }
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) {
      for (var i2 = 0; i2 < old.length; ++i2) {
        var span = old[i2], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push(new MarkedSpan(
            marker,
            startsBefore ? null : span.from - endCh,
            span.to == null ? null : span.to - endCh
          ));
        }
      }
    }
    return nw;
  }
  function stretchSpansOverChange(doc2, change) {
    if (change.full) {
      return null;
    }
    var oldFirst = isLine(doc2, change.from.line) && getLine(doc2, change.from.line).markedSpans;
    var oldLast = isLine(doc2, change.to.line) && getLine(doc2, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) {
      return null;
    }
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i2 = 0; i2 < first.length; ++i2) {
        var span = first[i2];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) {
            span.to = startCh;
          } else if (sameLine) {
            span.to = found.to == null ? null : found.to + offset;
          }
        }
      }
    }
    if (last) {
      for (var i\$12 = 0; i\$12 < last.length; ++i\$12) {
        var span\$1 = last[i\$12];
        if (span\$1.to != null) {
          span\$1.to += offset;
        }
        if (span\$1.from == null) {
          var found\$1 = getMarkedSpanFor(first, span\$1.marker);
          if (!found\$1) {
            span\$1.from = offset;
            if (sameLine) {
              (first || (first = [])).push(span\$1);
            }
          }
        } else {
          span\$1.from += offset;
          if (sameLine) {
            (first || (first = [])).push(span\$1);
          }
        }
      }
    }
    if (first) {
      first = clearEmptySpans(first);
    }
    if (last && last != first) {
      last = clearEmptySpans(last);
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first) {
        for (var i\$22 = 0; i\$22 < first.length; ++i\$22) {
          if (first[i\$22].to == null) {
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i\$22].marker, null, null));
          }
        }
      }
      for (var i\$3 = 0; i\$3 < gap; ++i\$3) {
        newMarkers.push(gapMarkers);
      }
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function clearEmptySpans(spans) {
    for (var i2 = 0; i2 < spans.length; ++i2) {
      var span = spans[i2];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
        spans.splice(i2--, 1);
      }
    }
    if (!spans.length) {
      return null;
    }
    return spans;
  }
  function removeReadOnlyRanges(doc2, from, to) {
    var markers = null;
    doc2.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) {
        for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
          var mark = line.markedSpans[i3].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
            (markers || (markers = [])).push(mark);
          }
        }
      }
    });
    if (!markers) {
      return null;
    }
    var parts = [{ from, to }];
    for (var i2 = 0; i2 < markers.length; ++i2) {
      var mk = markers[i2], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
          continue;
        }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
          newParts.push({ from: p.from, to: m.from });
        }
        if (dto > 0 || !mk.inclusiveRight && !dto) {
          newParts.push({ from: m.to, to: p.to });
        }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts;
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) {
      return;
    }
    for (var i2 = 0; i2 < spans.length; ++i2) {
      spans[i2].marker.detachLine(line);
    }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) {
      return;
    }
    for (var i2 = 0; i2 < spans.length; ++i2) {
      spans[i2].marker.attachLine(line);
    }
    line.markedSpans = spans;
  }
  function extraLeft(marker) {
    return marker.inclusiveLeft ? -1 : 0;
  }
  function extraRight(marker) {
    return marker.inclusiveRight ? 1 : 0;
  }
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) {
      return lenDiff;
    }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) {
      return -fromCmp;
    }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) {
      return toCmp;
    }
    return b.id - a.id;
  }
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
        sp = sps[i2];
        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAtSide(line, true);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAtSide(line, false);
  }
  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) {
      for (var i2 = 0; i2 < sps.length; ++i2) {
        var sp = sps[i2];
        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
          found = sp.marker;
        }
      }
    }
    return found;
  }
  function conflictingCollapsedRange(doc2, lineNo2, from, to, marker) {
    var line = getLine(doc2, lineNo2);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var i2 = 0; i2 < sps.length; ++i2) {
        var sp = sps[i2];
        if (!sp.marker.collapsed) {
          continue;
        }
        var found = sp.marker.find(0);
        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
          continue;
        }
        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
          return true;
        }
      }
    }
  }
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line)) {
      line = merged.find(-1, true).line;
    }
    return line;
  }
  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return line;
  }
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }
  function visualLineNo(doc2, lineN) {
    var line = getLine(doc2, lineN), vis = visualLine(line);
    if (line == vis) {
      return lineN;
    }
    return lineNo(vis);
  }
  function visualLineEndNo(doc2, lineN) {
    if (lineN > doc2.lastLine()) {
      return lineN;
    }
    var line = getLine(doc2, lineN), merged;
    if (!lineIsHidden(doc2, line)) {
      return lineN;
    }
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
    }
    return lineNo(line) + 1;
  }
  function lineIsHidden(doc2, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) {
      for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
        sp = sps[i2];
        if (!sp.marker.collapsed) {
          continue;
        }
        if (sp.from == null) {
          return true;
        }
        if (sp.marker.widgetNode) {
          continue;
        }
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc2, line, sp)) {
          return true;
        }
      }
    }
  }
  function lineIsHiddenInner(doc2, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc2, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length) {
      return true;
    }
    for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
      sp = line.markedSpans[i2];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc2, line, sp)) {
        return true;
      }
    }
  }
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
      var line = chunk.lines[i2];
      if (line == lineObj) {
        break;
      } else {
        h += line.height;
      }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i\$12 = 0; i\$12 < p.children.length; ++i\$12) {
        var cur = p.children[i\$12];
        if (cur == chunk) {
          break;
        } else {
          h += cur.height;
        }
      }
    }
    return h;
  }
  function lineLength(line) {
    if (line.height == 0) {
      return 0;
    }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found\$1 = merged.find(0, true);
      len -= cur.text.length - found\$1.from.ch;
      cur = found\$1.to.line;
      len += cur.text.length - found\$1.to.ch;
    }
    return len;
  }
  function findMaxLine(cm) {
    var d = cm.display, doc2 = cm.doc;
    d.maxLine = getLine(doc2, doc2.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc2.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  var Line = function(text, markedSpans, estimateHeight2) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight2 ? estimateHeight2(this) : 1;
  };
  Line.prototype.lineNo = function() {
    return lineNo(this);
  };
  eventMixin(Line);
  function updateLine(line, text, markedSpans, estimateHeight2) {
    line.text = text;
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    if (line.styles) {
      line.styles = null;
    }
    if (line.order != null) {
      line.order = null;
    }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
    if (estHeight != line.height) {
      updateLineHeight(line, estHeight);
    }
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\\s*\$/.test(style)) {
      return null;
    }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] || (cache[style] = style.replace(/\\S+/g, "cm-\$&"));
  }
  function buildLineContent(cm, lineView) {
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {
      pre: eltP("pre", [content], "CodeMirror-line"),
      content,
      col: 0,
      pos: 0,
      cm,
      trailingSpace: false,
      splitSpaces: cm.getOption("lineWrapping")
    };
    lineView.measure = {};
    for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
      var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
      builder.pos = 0;
      builder.addToken = buildToken;
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass) {
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        }
        if (line.styleClasses.textClass) {
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
        }
      }
      if (builder.map.length == 0) {
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
      }
      if (i2 == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
        builder.content.className = "cm-tab-wrap-hack";
      }
    }
    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className) {
      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
    }
    return builder;
  }
  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "•", "cm-invalidchar");
    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token;
  }
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) {
      return;
    }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) {
        mustWrap = true;
      }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt]));
          } else {
            content.appendChild(txt);
          }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) {
          break;
        }
        pos += skipped + 1;
        var txt\$1 = void 0;
        if (m[0] == "	") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt\$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt\$1.setAttribute("role", "presentation");
          txt\$1.setAttribute("cm-text", "	");
          builder.col += tabWidth;
        } else if (m[0] == "\\r" || m[0] == "\\n") {
          txt\$1 = content.appendChild(elt("span", m[0] == "\\r" ? "␍" : "␤", "cm-invalidchar"));
          txt\$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt\$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt\$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) {
            content.appendChild(elt("span", [txt\$1]));
          } else {
            content.appendChild(txt\$1);
          }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt\$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) {
        fullStyle += startStyle;
      }
      if (endStyle) {
        fullStyle += endStyle;
      }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) {
          if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
            token.setAttribute(attr, attributes[attr]);
          }
        }
      }
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) {
      return text;
    }
    var spaceBefore = trailingBefore, result = "";
    for (var i2 = 0; i2 < text.length; i2++) {
      var ch = text.charAt(i2);
      if (ch == " " && spaceBefore && (i2 == text.length - 1 || text.charCodeAt(i2 + 1) == 32)) {
        ch = " ";
      }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result;
  }
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (; ; ) {
        var part = void 0;
        for (var i2 = 0; i2 < order.length; i2++) {
          part = order[i2];
          if (part.to > start && part.from <= start) {
            break;
          }
        }
        if (part.to >= end) {
          return inner(builder, text, style, startStyle, endStyle, css, attributes);
        }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }
  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
    }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget) {
        widget = builder.content.appendChild(document.createElement("span"));
      }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i\$12 = 1; i\$12 < styles.length; i\$12 += 2) {
        builder.addToken(builder, allText.slice(at, at = styles[i\$12]), interpretTokenStyle(styles[i\$12 + 1], builder.cm.options));
      }
      return;
    }
    var len = allText.length, pos = 0, i2 = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (; ; ) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null;
        nextChange = Infinity;
        var foundBookmarks = [], endStyles = void 0;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) {
              spanStyle += " " + m.className;
            }
            if (m.css) {
              css = (css ? css + ";" : "") + m.css;
            }
            if (m.startStyle && sp.from == pos) {
              spanStartStyle += " " + m.startStyle;
            }
            if (m.endStyle && sp.to == nextChange) {
              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
            }
            if (m.title) {
              (attributes || (attributes = {})).title = m.title;
            }
            if (m.attributes) {
              for (var attr in m.attributes) {
                (attributes || (attributes = {}))[attr] = m.attributes[attr];
              }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
              collapsed = sp;
            }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) {
          for (var j\$1 = 0; j\$1 < endStyles.length; j\$1 += 2) {
            if (endStyles[j\$1 + 1] == nextChange) {
              spanEndStyle += " " + endStyles[j\$1];
            }
          }
        }
        if (!collapsed || collapsed.from == pos) {
          for (var j\$2 = 0; j\$2 < foundBookmarks.length; ++j\$2) {
            buildCollapsedSpan(builder, 0, foundBookmarks[j\$2]);
          }
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(
            builder,
            (collapsed.to == null ? len + 1 : collapsed.to) - pos,
            collapsed.marker,
            collapsed.from == null
          );
          if (collapsed.to == null) {
            return;
          }
          if (collapsed.to == pos) {
            collapsed = false;
          }
        }
      }
      if (pos >= len) {
        break;
      }
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(
              builder,
              tokenText,
              style ? style + spanStyle : spanStyle,
              spanStartStyle,
              pos + tokenText.length == nextChange ? spanEndStyle : "",
              css,
              attributes
            );
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i2++]);
        style = interpretTokenStyle(styles[i2++], builder.cm.options);
      }
    }
  }
  function LineView(doc2, line, lineN) {
    this.line = line;
    this.rest = visualLineContinued(line);
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc2, line);
  }
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }
  var operationGroup = null;
  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }
  function fireCallbacksForOps(group) {
    var callbacks = group.delayedCallbacks, i2 = 0;
    do {
      for (; i2 < callbacks.length; i2++) {
        callbacks[i2].call(null);
      }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers) {
          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
          }
        }
      }
    } while (i2 < callbacks.length);
  }
  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) {
      return;
    }
    try {
      fireCallbacksForOps(group);
    } finally {
      operationGroup = null;
      endCb(group);
    }
  }
  var orphanDelayedCallbacks = null;
  function signalLater(emitter, type2) {
    var arr = getHandlers(emitter, type2);
    if (!arr.length) {
      return;
    }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function(i3) {
      list.push(function() {
        return arr[i3].apply(null, args);
      });
    };
    for (var i2 = 0; i2 < arr.length; ++i2)
      loop(i2);
  }
  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i2 = 0; i2 < delayed.length; ++i2) {
      delayed[i2]();
    }
  }
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type2 = lineView.changes[j];
      if (type2 == "text") {
        updateLineText(cm, lineView);
      } else if (type2 == "gutter") {
        updateLineGutter(cm, lineView, lineN, dims);
      } else if (type2 == "class") {
        updateLineClasses(cm, lineView);
      } else if (type2 == "widget") {
        updateLineWidgets(cm, lineView, dims);
      }
    }
    lineView.changes = null;
  }
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode) {
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) {
        lineView.node.style.zIndex = 2;
      }
    }
    return lineView.node;
  }
  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) {
      cls += " CodeMirror-linebackground";
    }
    if (lineView.background) {
      if (cls) {
        lineView.background.className = cls;
      } else {
        lineView.background.parentNode.removeChild(lineView.background);
        lineView.background = null;
      }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) {
      lineView.node = built.pre;
    }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }
  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass) {
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    } else if (lineView.node != lineView.text) {
      lineView.node.className = "";
    }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }
  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt(
        "div",
        null,
        "CodeMirror-gutter-background " + lineView.line.gutterClass,
        "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"
      );
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap\$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
      gutterWrap.setAttribute("aria-hidden", "true");
      cm.display.input.setUneditable(gutterWrap);
      wrap\$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass) {
        gutterWrap.className += " " + lineView.line.gutterClass;
      }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
        lineView.lineNumber = gutterWrap.appendChild(
          elt(
            "div",
            lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"
          )
        );
      }
      if (markers) {
        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
          var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
          if (found) {
            gutterWrap.appendChild(elt(
              "div",
              [found],
              "CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"
            ));
          }
        }
      }
    }
  }
  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) {
      lineView.alignable = null;
    }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) {
        lineView.node.removeChild(node);
      }
    }
    insertLineWidgets(cm, lineView, dims);
  }
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) {
      lineView.bgClass = built.bgClass;
    }
    if (built.textClass) {
      lineView.textClass = built.textClass;
    }
    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node;
  }
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) {
      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
        insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
      }
    }
  }
  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) {
      return;
    }
    var wrap = ensureLineWrapped(lineView);
    for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
      var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) {
        node.setAttribute("cm-ignore-events", "true");
      }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above) {
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      } else {
        wrap.appendChild(node);
      }
      signalLater(widget, "redraw");
    }
  }
  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) {
        node.style.marginLeft = -dims.gutterTotalWidth + "px";
      }
    }
  }
  function widgetHeight(widget) {
    if (widget.height != null) {
      return widget.height;
    }
    var cm = widget.doc.cm;
    if (!cm) {
      return 0;
    }
    if (!contains2(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter) {
        parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
      }
      if (widget.noHScroll) {
        parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
      }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight;
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
        return true;
      }
    }
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingH(display) {
    if (display.cachedPaddingH) {
      return display.cachedPaddingH;
    }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
    if (!isNaN(data.left) && !isNaN(data.right)) {
      display.cachedPaddingH = data;
    }
    return data;
  }
  function scrollGap(cm) {
    return scrollerGap - cm.display.nativeBarWidth;
  }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
  }
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i2 = 0; i2 < rects.length - 1; i2++) {
          var cur = rects[i2], next = rects[i2 + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2) {
            heights.push((cur.bottom + next.top) / 2 - rect.top);
          }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line) {
      return { map: lineView.measure.map, cache: lineView.measure.cache };
    }
    if (lineView.rest) {
      for (var i2 = 0; i2 < lineView.rest.length; i2++) {
        if (lineView.rest[i2] == line) {
          return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
        }
      }
      for (var i\$12 = 0; i\$12 < lineView.rest.length; i\$12++) {
        if (lineNo(lineView.rest[i\$12]) > lineN) {
          return { map: lineView.measure.maps[i\$12], cache: lineView.measure.caches[i\$12], before: true };
        }
      }
    }
  }
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
      return cm.display.view[findViewIndex(cm, lineN)];
    }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
      return ext;
    }
  }
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view) {
      view = updateExternalMeasurement(cm, line);
    }
    var info = mapFromLineView(view, line, lineN);
    return {
      line,
      view,
      rect: null,
      map: info.map,
      cache: info.cache,
      before: info.before,
      hasHeights: false
    };
  }
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) {
      ch = -1;
    }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect) {
        prepared.rect = prepared.view.text.getBoundingClientRect();
      }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) {
        prepared.cache[key] = found;
      }
    }
    return {
      left: found.left,
      right: found.right,
      top: varHeight ? found.rtop : found.top,
      bottom: varHeight ? found.rbottom : found.bottom
    };
  }
  var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
  function nodeAndOffsetInLineMap(map2, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    for (var i2 = 0; i2 < map2.length; i2 += 3) {
      mStart = map2[i2];
      mEnd = map2[i2 + 1];
      if (ch < mStart) {
        start = 0;
        end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i2 == map2.length - 3 || ch == mEnd && map2[i2 + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) {
          collapse = "right";
        }
      }
      if (start != null) {
        node = map2[i2 + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
          collapse = bias;
        }
        if (bias == "left" && start == 0) {
          while (i2 && map2[i2 - 2] == map2[i2 - 3] && map2[i2 - 1].insertLeft) {
            node = map2[(i2 -= 3) + 2];
            collapse = "left";
          }
        }
        if (bias == "right" && start == mEnd - mStart) {
          while (i2 < map2.length - 3 && map2[i2 + 3] == map2[i2 + 4] && !map2[i2 + 5].insertLeft) {
            node = map2[(i2 += 3) + 2];
            collapse = "right";
          }
        }
        break;
      }
    }
    return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
  }
  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") {
      for (var i2 = 0; i2 < rects.length; i2++) {
        if ((rect = rects[i2]).left != rect.right) {
          break;
        }
      }
    } else {
      for (var i\$12 = rects.length - 1; i\$12 >= 0; i\$12--) {
        if ((rect = rects[i\$12]).left != rect.right) {
          break;
        }
      }
    }
    return rect;
  }
  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
    var rect;
    if (node.nodeType == 3) {
      for (var i\$12 = 0; i\$12 < 4; i\$12++) {
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
          --start;
        }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
          ++end;
        }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
          rect = node.parentNode.getBoundingClientRect();
        } else {
          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
        }
        if (rect.left || rect.right || start == 0) {
          break;
        }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) {
        rect = maybeUpdateRectForZooming(cm.display.measure, rect);
      }
    } else {
      if (start > 0) {
        collapse = bias = "right";
      }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      } else {
        rect = node.getBoundingClientRect();
      }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan) {
        rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
      } else {
        rect = nullRect;
      }
    }
    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i2 = 0;
    for (; i2 < heights.length - 1; i2++) {
      if (mid < heights[i2]) {
        break;
      }
    }
    var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
    var result = {
      left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
      right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
      top,
      bottom: bot
    };
    if (!rect.left && !rect.right) {
      result.bogus = true;
    }
    if (!cm.options.singleCursorHeightPerLine) {
      result.rtop = rtop;
      result.rbottom = rbot;
    }
    return result;
  }
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
      return rect;
    }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {
      left: rect.left * scaleX,
      right: rect.right * scaleX,
      top: rect.top * scaleY,
      bottom: rect.bottom * scaleY
    };
  }
  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          lineView.measure.caches[i2] = {};
        }
      }
    }
  }
  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i2 = 0; i2 < cm.display.view.length; i2++) {
      clearLineMeasurementCacheFor(cm.display.view[i2]);
    }
  }
  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) {
      cm.display.maxLineChanged = true;
    }
    cm.display.lineNumChars = null;
  }
  function pageScrollX(doc2) {
    if (chrome && android) {
      return -(doc2.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc2.body).marginLeft));
    }
    return doc2.defaultView.pageXOffset || (doc2.documentElement || doc2.body).scrollLeft;
  }
  function pageScrollY(doc2) {
    if (chrome && android) {
      return -(doc2.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc2.body).marginTop));
    }
    return doc2.defaultView.pageYOffset || (doc2.documentElement || doc2.body).scrollTop;
  }
  function widgetTopHeight(lineObj) {
    var ref = visualLine(lineObj);
    var widgets = ref.widgets;
    var height = 0;
    if (widgets) {
      for (var i2 = 0; i2 < widgets.length; ++i2) {
        if (widgets[i2].above) {
          height += widgetHeight(widgets[i2]);
        }
      }
    }
    return height;
  }
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height;
      rect.bottom += height;
    }
    if (context == "line") {
      return rect;
    }
    if (!context) {
      context = "local";
    }
    var yOff = heightAtLine(lineObj);
    if (context == "local") {
      yOff += paddingTop(cm.display);
    } else {
      yOff -= cm.display.viewOffset;
    }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY(doc(cm)));
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX(doc(cm)));
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") {
      return coords;
    }
    var left = coords.left, top = coords.top;
    if (context == "page") {
      left -= pageScrollX(doc(cm));
      top -= pageScrollY(doc(cm));
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }
    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
  }
  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) {
      lineObj = getLine(cm.doc, pos.line);
    }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    function get(ch2, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
      if (right) {
        m.left = m.right;
      } else {
        m.right = m.left;
      }
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) {
      return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
    }
    function getBidi(ch2, partPos2, invert) {
      var part = order[partPos2], right = part.level == 1;
      return get(invert ? ch2 - 1 : ch2, right != invert);
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) {
      val.other = getBidi(ch, other, sticky != "before");
    }
    return val;
  }
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) {
      left = charWidth(cm.display) * pos.ch;
    }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return { left, right: left, top, bottom: top + lineObj.height };
  }
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) {
      pos.outside = outside;
    }
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc2 = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) {
      return PosWithInfo(doc2.first, 0, null, -1, -1);
    }
    var lineN = lineAtHeight(doc2, y), last = doc2.first + doc2.size - 1;
    if (lineN > last) {
      return PosWithInfo(doc2.first + doc2.size - 1, getLine(doc2, last).text.length, null, 1, 1);
    }
    if (x < 0) {
      x = 0;
    }
    var lineObj = getLine(doc2, lineN);
    for (; ; ) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) {
        return found;
      }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) {
        return rangeEnd;
      }
      lineObj = getLine(doc2, lineN = rangeEnd.line);
    }
  }
  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function(ch) {
      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
    }, end, 0);
    end = findFirst(function(ch) {
      return measureCharPrepared(cm, preparedMeasure, ch).top > y;
    }, begin, end);
    return { begin, end };
  }
  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) {
      preparedMeasure = prepareMeasureForLine(cm, lineObj);
    }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
  }
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
  }
  function coordsCharInner(cm, lineObj, lineNo2, x, y) {
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    var widgetHeight2 = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;
    var order = getOrder(lineObj, cm.doc.direction);
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }
    var chAround = null, boxAround = null;
    var ch = findFirst(function(ch2) {
      var box = measureCharPrepared(cm, preparedMeasure, ch2);
      box.top += widgetHeight2;
      box.bottom += widgetHeight2;
      if (!boxIsAfter(box, x, y, false)) {
        return false;
      }
      if (box.top <= y && box.left <= x) {
        chAround = ch2;
        boxAround = box;
      }
      return true;
    }, begin, end);
    var baseX, sticky, outside = false;
    if (boxAround) {
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      if (!ltr && (ch == end || ch == begin)) {
        ch++;
      }
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
      var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }
    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
  }
  function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
    var index = findFirst(function(i2) {
      var part2 = order[i2], ltr2 = part2.level != 1;
      return boxIsAfter(cursorCoords(
        cm,
        Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"),
        "line",
        lineObj,
        preparedMeasure
      ), x, y, true);
    }, 0, order.length - 1);
    var part = order[index];
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(
        cm,
        Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"),
        "line",
        lineObj,
        preparedMeasure
      );
      if (boxIsAfter(start, x, y, true) && start.top > y) {
        part = order[index - 1];
      }
    }
    return part;
  }
  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\\s/.test(lineObj.text.charAt(end - 1))) {
      end--;
    }
    var part = null, closestDist = null;
    for (var i2 = 0; i2 < order.length; i2++) {
      var p = order[i2];
      if (p.from >= end || p.to <= begin) {
        continue;
      }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) {
      part = order[order.length - 1];
    }
    if (part.from < begin) {
      part = { from: begin, to: part.to, level: part.level };
    }
    if (part.to > end) {
      part = { from: part.from, to: end, level: part.level };
    }
    return part;
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null) {
      return display.cachedTextHeight;
    }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      for (var i2 = 0; i2 < 49; ++i2) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) {
      display.cachedTextHeight = height;
    }
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null) {
      return display.cachedCharWidth;
    }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) {
      display.cachedCharWidth = width;
    }
    return width || 10;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
      var id2 = cm.display.gutterSpecs[i2].className;
      left[id2] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id2] = n.clientWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) {
        return 0;
      }
      var widgetsHeight = 0;
      if (line.widgets) {
        for (var i2 = 0; i2 < line.widgets.length; i2++) {
          if (line.widgets[i2].height) {
            widgetsHeight += line.widgets[i2].height;
          }
        }
      }
      if (wrapping) {
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      } else {
        return widgetsHeight + th;
      }
    };
  }
  function estimateLineHeights(cm) {
    var doc2 = cm.doc, est = estimateHeight(cm);
    doc2.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    });
  }
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
      return null;
    }
    var x, y, space2 = display.lineSpace.getBoundingClientRect();
    try {
      x = e.clientX - space2.left;
      y = e.clientY - space2.top;
    } catch (e\$1) {
      return null;
    }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) {
      return null;
    }
    n -= cm.display.viewFrom;
    if (n < 0) {
      return null;
    }
    var view = cm.display.view;
    for (var i2 = 0; i2 < view.length; i2++) {
      n -= view[i2].size;
      if (n < 0) {
        return i2;
      }
    }
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null) {
      from = cm.doc.first;
    }
    if (to == null) {
      to = cm.doc.first + cm.doc.size;
    }
    if (!lendiff) {
      lendiff = 0;
    }
    var display = cm.display;
    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
      display.updateLineNumbers = from;
    }
    cm.curOp.viewChanged = true;
    if (from >= display.viewTo) {
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
        resetView(cm);
      }
    } else if (to <= display.viewFrom) {
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) {
      resetView(cm);
    } else if (from <= display.viewFrom) {
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) {
      var cut\$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut\$1) {
        display.view = display.view.slice(0, cut\$1.index);
        display.viewTo = cut\$1.lineN;
      } else {
        resetView(cm);
      }
    } else {
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }
    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN) {
        ext.lineN += lendiff;
      } else if (from < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
    }
  }
  function regLineChange(cm, line, type2) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
      display.externalMeasured = null;
    }
    if (line < display.viewFrom || line >= display.viewTo) {
      return;
    }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) {
      return;
    }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type2) == -1) {
      arr.push(type2);
    }
  }
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }
  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
      return { index, lineN: newN };
    }
    var n = cm.display.viewFrom;
    for (var i2 = 0; i2 < index; i2++) {
      n += view[i2].size;
    }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) {
          return null;
        }
        diff = n + view[index].size - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff;
      newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) {
        return null;
      }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return { index, lineN: newN };
  }
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from) {
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      } else if (display.viewFrom < from) {
        display.view = display.view.slice(findViewIndex(cm, from));
      }
      display.viewFrom = from;
      if (display.viewTo < to) {
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      } else if (display.viewTo > to) {
        display.view = display.view.slice(0, findViewIndex(cm, to));
      }
    }
    display.viewTo = to;
  }
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i2 = 0; i2 < view.length; i2++) {
      var lineView = view[i2];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) {
        ++dirty;
      }
    }
    return dirty;
  }
  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }
  function prepareSelection(cm, primary) {
    if (primary === void 0) primary = true;
    var doc2 = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();
    var customCursor = cm.options.\$customCursor;
    if (customCursor) {
      primary = true;
    }
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      if (!primary && i2 == doc2.sel.primIndex) {
        continue;
      }
      var range2 = doc2.sel.ranges[i2];
      if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
        continue;
      }
      var collapsed = range2.empty();
      if (customCursor) {
        var head = customCursor(cm, range2);
        if (head) {
          drawSelectionCursor(cm, head, curFragment);
        }
      } else if (collapsed || cm.options.showCursorWhenSelecting) {
        drawSelectionCursor(cm, range2.head, curFragment);
      }
      if (!collapsed) {
        drawSelectionRange(cm, range2, selFragment);
      }
    }
    return result;
  }
  function drawSelectionCursor(cm, head, output2) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
    var cursor = output2.appendChild(elt("div", " ", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {
      var charPos = charCoords(cm, head, "div", null, null);
      var width = charPos.right - charPos.left;
      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
    }
    if (pos.other) {
      var otherCursor = output2.appendChild(elt("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
    }
  }
  function cmpCoords(a, b) {
    return a.top - b.top || a.left - b.left;
  }
  function drawSelectionRange(cm, range2, output2) {
    var display = cm.display, doc2 = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc2.direction == "ltr";
    function add(left, top, width, bottom) {
      if (top < 0) {
        top = 0;
      }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\\n                             height: " + (bottom - top) + "px"));
    }
    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc2, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }
      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop2)[prop2];
      }
      var order = getOrder(lineObj, doc2.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");
        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i2 == 0, last = !order || i2 == order.length - 1;
        if (toPos.top - fromPos.top <= 3) {
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else {
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) {
            add(leftSide, fromPos.bottom, null, toPos.top);
          }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }
        if (!start || cmpCoords(fromPos, start) < 0) {
          start = fromPos;
        }
        if (cmpCoords(toPos, start) < 0) {
          start = toPos;
        }
        if (!end || cmpCoords(fromPos, end) < 0) {
          end = fromPos;
        }
        if (cmpCoords(toPos, end) < 0) {
          end = toPos;
        }
      });
      return { start, end };
    }
    var sFrom = range2.from(), sTo = range2.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc2, sFrom.line), toLine = getLine(doc2, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top) {
        add(leftSide, leftEnd.bottom, null, rightStart.top);
      }
    }
    output2.appendChild(fragment);
  }
  function restartBlink(cm) {
    if (!cm.state.focused) {
      return;
    }
    var display = cm.display;
    clearInterval(display.blinker);
    var on2 = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0) {
      display.blinker = setInterval(function() {
        if (!cm.hasFocus()) {
          onBlur(cm);
        }
        display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
    } else if (cm.options.cursorBlinkRate < 0) {
      display.cursorDiv.style.visibility = "hidden";
    }
  }
  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) {
        onFocus(cm);
      }
    }
  }
  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      if (cm.state.delayingBlurEvent) {
        cm.state.delayingBlurEvent = false;
        if (cm.state.focused) {
          onBlur(cm);
        }
      }
    }, 100);
  }
  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
      cm.state.delayingBlurEvent = false;
    }
    if (cm.options.readOnly == "nocursor") {
      return;
    }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) {
          setTimeout(function() {
            return cm.display.input.reset(true);
          }, 20);
        }
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) {
      return;
    }
    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {
      if (!cm.state.focused) {
        cm.display.shift = false;
      }
    }, 150);
  }
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
    var oldHeight = display.lineDiv.getBoundingClientRect().top;
    var mustScroll = 0;
    for (var i2 = 0; i2 < display.view.length; i2++) {
      var cur = display.view[i2], wrapping = cm.options.lineWrapping;
      var height = void 0, width = 0;
      if (cur.hidden) {
        continue;
      }
      oldHeight += cur.line.height;
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        if (!wrapping && cur.text.firstChild) {
          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
        }
      }
      var diff = cur.line.height - height;
      if (diff > 5e-3 || diff < -5e-3) {
        if (oldHeight < viewTop) {
          mustScroll -= diff;
        }
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) {
          for (var j = 0; j < cur.rest.length; j++) {
            updateWidgetHeight(cur.rest[j]);
          }
        }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (Math.abs(mustScroll) > 2) {
      display.scroller.scrollTop += mustScroll;
    }
  }
  function updateWidgetHeight(line) {
    if (line.widgets) {
      for (var i2 = 0; i2 < line.widgets.length; ++i2) {
        var w = line.widgets[i2], parent = w.node.parentNode;
        if (parent) {
          w.height = parent.offsetHeight;
        }
      }
    }
  }
  function visibleLines(display, doc2, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
    var from = lineAtHeight(doc2, top), to = lineAtHeight(doc2, bottom);
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc2.lastLine()) >= to) {
        from = lineAtHeight(doc2, heightAtLine(getLine(doc2, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return { from, to: Math.max(to, from + 1) };
  }
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) {
      return;
    }
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    var doc2 = display.wrapper.ownerDocument;
    if (rect.top + box.top < 0) {
      doScroll = true;
    } else if (rect.bottom + box.top > (doc2.defaultView.innerHeight || doc2.documentElement.clientHeight)) {
      doScroll = false;
    }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "​", null, "position: absolute;\\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) {
      margin = 0;
    }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {
        left: Math.min(coords.left, endCoords.left),
        top: Math.min(coords.top, endCoords.top) - margin,
        right: Math.max(coords.left, endCoords.left),
        bottom: Math.max(coords.bottom, endCoords.bottom) + margin
      };
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
          changed = true;
        }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
          changed = true;
        }
      }
      if (!changed) {
        break;
      }
    }
    return rect;
  }
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop);
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft);
    }
  }
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) {
      rect.top = 0;
    }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen2 = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen2) {
      rect.bottom = rect.top + screen2;
    }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen2) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
      if (newTop != screentop) {
        result.scrollTop = newTop;
      }
    }
    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) {
      rect.right = rect.left + screenw;
    }
    if (rect.left < 10) {
      result.scrollLeft = 0;
    } else if (rect.left < screenleft) {
      result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
    } else if (rect.right > screenw + screenleft - 3) {
      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
    }
    return result;
  }
  function addToScrollTop(cm, top) {
    if (top == null) {
      return;
    }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
  }
  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) {
      resolveScrollToPos(cm);
    }
    if (x != null) {
      cm.curOp.scrollLeft = x;
    }
    if (y != null) {
      cm.curOp.scrollTop = y;
    }
  }
  function scrollToRange(cm, range2) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range2;
  }
  function resolveScrollToPos(cm) {
    var range2 = cm.curOp.scrollToPos;
    if (range2) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
      scrollToCoordsRange(cm, from, to, range2.margin);
    }
  }
  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) {
      return;
    }
    if (!gecko) {
      updateDisplaySimple(cm, { top: val });
    }
    setScrollTop(cm, val, true);
    if (gecko) {
      updateDisplaySimple(cm);
    }
    startWorker(cm, 100);
  }
  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) {
      return;
    }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) {
      cm.display.scroller.scrollTop = val;
    }
  }
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
      return;
    }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) {
      cm.display.scroller.scrollLeft = val;
    }
    cm.display.scrollbars.setScrollLeft(val);
  }
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth,
      clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    };
  }
  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert);
    place(horiz);
    on(vert, "scroll", function() {
      if (vert.clientHeight) {
        scroll(vert.scrollTop, "vertical");
      }
    });
    on(horiz, "scroll", function() {
      if (horiz.clientWidth) {
        scroll(horiz.scrollLeft, "horizontal");
      }
    });
    this.checkedZeroWidth = false;
    if (ie && ie_version < 8) {
      this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
    }
  };
  NativeScrollbars.prototype.update = function(measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;
    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.scrollTop = 0;
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }
    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }
    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) {
        this.zeroWidthHack();
      }
      this.checkedZeroWidth = true;
    }
    return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
  };
  NativeScrollbars.prototype.setScrollLeft = function(pos) {
    if (this.horiz.scrollLeft != pos) {
      this.horiz.scrollLeft = pos;
    }
    if (this.disableHoriz) {
      this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
    }
  };
  NativeScrollbars.prototype.setScrollTop = function(pos) {
    if (this.vert.scrollTop != pos) {
      this.vert.scrollTop = pos;
    }
    if (this.disableVert) {
      this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
    }
  };
  NativeScrollbars.prototype.zeroWidthHack = function() {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.visibility = this.vert.style.visibility = "hidden";
    this.disableHoriz = new Delayed();
    this.disableVert = new Delayed();
  };
  NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {
    bar.style.visibility = "";
    function maybeDisable() {
      var box = bar.getBoundingClientRect();
      var elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt2 != bar) {
        bar.style.visibility = "hidden";
      } else {
        delay.set(1e3, maybeDisable);
      }
    }
    delay.set(1e3, maybeDisable);
  };
  NativeScrollbars.prototype.clear = function() {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };
  var NullScrollbars = function() {
  };
  NullScrollbars.prototype.update = function() {
    return { bottom: 0, right: 0 };
  };
  NullScrollbars.prototype.setScrollLeft = function() {
  };
  NullScrollbars.prototype.setScrollTop = function() {
  };
  NullScrollbars.prototype.clear = function() {
  };
  function updateScrollbars(cm, measure) {
    if (!measure) {
      measure = measureForScrollbars(cm);
    }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
        updateHeightsInViewport(cm);
      }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth;
      startHeight = cm.display.barHeight;
    }
  }
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);
    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else {
      d.scrollbarFiller.style.display = "";
    }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else {
      d.gutterFiller.style.display = "";
    }
  }
  var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass) {
        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      on(node, "mousedown", function() {
        if (cm.state.focused) {
          setTimeout(function() {
            return cm.display.input.focus();
          }, 0);
        }
      });
      node.setAttribute("cm-not-content", "true");
    }, function(pos, axis) {
      if (axis == "horizontal") {
        setScrollLeft(cm, pos);
      } else {
        updateScrollTop(cm, pos);
      }
    }, cm);
    if (cm.display.scrollbars.addClass) {
      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      cm,
      viewChanged: false,
      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height,
      // Used to detect need to update scrollbar
      forceUpdate: false,
      // Used to force a redraw
      updateInput: 0,
      // Whether to reset the input textarea
      typing: false,
      // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,
      // Accumulated changes, for firing change events
      cursorActivityHandlers: null,
      // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0,
      // Tracks which cursorActivity handlers have been called already
      selectionChanged: false,
      // Whether the selection needs to be redrawn
      updateMaxLine: false,
      // Set when the widest line needs to be determined anew
      scrollLeft: null,
      scrollTop: null,
      // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,
      // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId,
      // Unique ID
      markArrays: null
      // Used by addMarkedSpan
    };
    pushOperation(cm.curOp);
  }
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) {
      finishOperation(op, function(group) {
        for (var i2 = 0; i2 < group.ops.length; i2++) {
          group.ops[i2].cm.curOp = null;
        }
        endOperations(group);
      });
    }
  }
  function endOperations(group) {
    var ops = group.ops;
    for (var i2 = 0; i2 < ops.length; i2++) {
      endOperation_R1(ops[i2]);
    }
    for (var i\$12 = 0; i\$12 < ops.length; i\$12++) {
      endOperation_W1(ops[i\$12]);
    }
    for (var i\$22 = 0; i\$22 < ops.length; i\$22++) {
      endOperation_R2(ops[i\$22]);
    }
    for (var i\$3 = 0; i\$3 < ops.length; i\$3++) {
      endOperation_W2(ops[i\$3]);
    }
    for (var i\$4 = 0; i\$4 < ops.length; i\$4++) {
      endOperation_finish(ops[i\$4]);
    }
  }
  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) {
      findMaxLine(cm);
    }
    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
  }
  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }
  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) {
      updateHeightsInViewport(cm);
    }
    op.barMeasure = measureForScrollbars(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }
    if (op.updatedDisplay || op.selectionChanged) {
      op.preparedSelection = display.input.prepareSelection();
    }
  }
  function endOperation_W2(op) {
    var cm = op.cm;
    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft) {
        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
      }
      cm.display.maxLineChanged = false;
    }
    var takeFocus = op.focus && op.focus == activeElt(doc(cm));
    if (op.preparedSelection) {
      cm.display.input.showSelection(op.preparedSelection, takeFocus);
    }
    if (op.updatedDisplay || op.startHeight != cm.doc.height) {
      updateScrollbars(cm, op.barMeasure);
    }
    if (op.updatedDisplay) {
      setDocumentHeight(cm, op.barMeasure);
    }
    if (op.selectionChanged) {
      restartBlink(cm);
    }
    if (cm.state.focused && op.updateInput) {
      cm.display.input.reset(op.typing);
    }
    if (takeFocus) {
      ensureFocus(op.cm);
    }
  }
  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc2 = cm.doc;
    if (op.updatedDisplay) {
      postUpdateDisplay(cm, op.update);
    }
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
      display.wheelStartX = display.wheelStartY = null;
    }
    if (op.scrollTop != null) {
      setScrollTop(cm, op.scrollTop, op.forceScroll);
    }
    if (op.scrollLeft != null) {
      setScrollLeft(cm, op.scrollLeft, true, true);
    }
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(
        cm,
        clipPos(doc2, op.scrollToPos.from),
        clipPos(doc2, op.scrollToPos.to),
        op.scrollToPos.margin
      );
      maybeScrollWindow(cm, rect);
    }
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) {
      for (var i2 = 0; i2 < hidden.length; ++i2) {
        if (!hidden[i2].lines.length) {
          signal(hidden[i2], "hide");
        }
      }
    }
    if (unhidden) {
      for (var i\$12 = 0; i\$12 < unhidden.length; ++i\$12) {
        if (unhidden[i\$12].lines.length) {
          signal(unhidden[i\$12], "unhide");
        }
      }
    }
    if (display.wrapper.offsetHeight) {
      doc2.scrollTop = cm.display.scroller.scrollTop;
    }
    if (op.changeObjs) {
      signal(cm, "changes", cm, op.changeObjs);
    }
    if (op.update) {
      op.update.finish();
    }
  }
  function runInOp(cm, f) {
    if (cm.curOp) {
      return f();
    }
    startOperation(cm);
    try {
      return f();
    } finally {
      endOperation(cm);
    }
  }
  function operation(cm, f) {
    return function() {
      if (cm.curOp) {
        return f.apply(cm, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(cm, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  function methodOp(f) {
    return function() {
      if (this.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(this);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(this);
      }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) {
        return f.apply(this, arguments);
      }
      startOperation(cm);
      try {
        return f.apply(this, arguments);
      } finally {
        endOperation(cm);
      }
    };
  }
  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo) {
      cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
  }
  function highlightWorker(cm) {
    var doc2 = cm.doc;
    if (doc2.highlightFrontier >= cm.display.viewTo) {
      return;
    }
    var end = +/* @__PURE__ */ new Date() + cm.options.workTime;
    var context = getContextBefore(cm, doc2.highlightFrontier);
    var changedLines = [];
    doc2.iter(context.line, Math.min(doc2.first + doc2.size, cm.display.viewTo + 500), function(line) {
      if (context.line >= cm.display.viewFrom) {
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc2.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) {
          context.state = resetState;
        }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) {
          line.styleClasses = newCls;
        } else if (oldCls) {
          line.styleClasses = null;
        }
        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
          ischange = oldStyles[i2] != line.styles[i2];
        }
        if (ischange) {
          changedLines.push(context.line);
        }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength) {
          processLine(cm, line.text, context);
        }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+/* @__PURE__ */ new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    doc2.highlightFrontier = context.line;
    doc2.modeFrontier = Math.max(doc2.modeFrontier, context.line);
    if (changedLines.length) {
      runInOp(cm, function() {
        for (var i2 = 0; i2 < changedLines.length; i2++) {
          regLineChange(cm, changedLines[i2], "text");
        }
      });
    }
  }
  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;
    this.viewport = viewport;
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };
  DisplayUpdate.prototype.signal = function(emitter, type2) {
    if (hasHandler(emitter, type2)) {
      this.events.push(arguments);
    }
  };
  DisplayUpdate.prototype.finish = function() {
    for (var i2 = 0; i2 < this.events.length; i2++) {
      signal.apply(null, this.events[i2]);
    }
  };
  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }
  function selectionSnapshot(cm) {
    if (cm.hasFocus()) {
      return null;
    }
    var active = activeElt(doc(cm));
    if (!active || !contains2(cm.display.lineDiv, active)) {
      return null;
    }
    var result = { activeElt: active };
    if (window.getSelection) {
      var sel = win(cm).getSelection();
      if (sel.anchorNode && sel.extend && contains2(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result;
  }
  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(snapshot.activeElt.ownerDocument)) {
      return;
    }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)\$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains2(document.body, snapshot.anchorNode) && contains2(document.body, snapshot.focusNode)) {
      var doc2 = snapshot.activeElt.ownerDocument;
      var sel = doc2.defaultView.getSelection(), range2 = doc2.createRange();
      range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range2.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range2);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc2 = cm.doc;
    if (update.editorIsHidden) {
      resetView(cm);
      return false;
    }
    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
      return false;
    }
    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }
    var end = doc2.first + doc2.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc2.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) {
      from = Math.max(doc2.first, display.viewFrom);
    }
    if (display.viewTo > to && display.viewTo - to < 20) {
      to = Math.min(end, display.viewTo);
    }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }
    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);
    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    cm.display.mover.style.top = display.viewOffset + "px";
    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
      return false;
    }
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "none";
    }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) {
      display.lineDiv.style.display = "";
    }
    display.renderedView = display.view;
    restoreSelection(selSnapshot);
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;
    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }
    display.updateLineNumbers = null;
    return true;
  }
  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;
    for (var first = true; ; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        if (viewport && viewport.top != null) {
          viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
        }
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
          break;
        }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) {
        break;
      }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }
    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom;
      cm.display.reportedViewTo = cm.display.viewTo;
    }
  }
  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node2) {
      var next = node2.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node2) {
        node2.style.display = "none";
      } else {
        node2.parentNode.removeChild(node2);
      }
      return next;
    }
    var view = display.view, lineN = display.viewFrom;
    for (var i2 = 0; i2 < view.length; i2++) {
      var lineView = view[i2];
      if (lineView.hidden) ;
      else if (!lineView.node || lineView.node.parentNode != container) {
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else {
        while (cur != lineView.node) {
          cur = rm(cur);
        }
        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) {
            updateNumber = false;
          }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) {
      cur = rm(cur);
    }
  }
  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
    signalLater(display, "gutterChanged", display);
  }
  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
  }
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
      return;
    }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i2 = 0; i2 < view.length; i2++) {
      if (!view[i2].hidden) {
        if (cm.options.fixedGutter) {
          if (view[i2].gutter) {
            view[i2].gutter.style.left = left;
          }
          if (view[i2].gutterBackground) {
            view[i2].gutterBackground.style.left = left;
          }
        }
        var align = view[i2].alignable;
        if (align) {
          for (var j = 0; j < align.length; j++) {
            align[j].style.left = left;
          }
        }
      }
    }
    if (cm.options.fixedGutter) {
      display.gutters.style.left = comp + gutterW + "px";
    }
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) {
      return false;
    }
    var doc2 = cm.doc, last = lineNumberFor(cm.options, doc2.first + doc2.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt(
        "div",
        [elt("div", last)],
        "CodeMirror-linenumber CodeMirror-gutter-elt"
      ));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true;
    }
    return false;
  }
  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i2 = 0; i2 < gutters.length; i2++) {
      var name = gutters[i2], style = null;
      if (typeof name != "string") {
        style = name.style;
        name = name.className;
      }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) {
          continue;
        } else {
          sawLineNumbers = true;
        }
      }
      result.push({ className: name, style });
    }
    if (lineNumbers && !sawLineNumbers) {
      result.push({ className: "CodeMirror-linenumbers", style: null });
    }
    return result;
  }
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i2 = 0; i2 < specs.length; ++i2) {
      var ref = specs[i2];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) {
        gElt.style.cssText = style;
      }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }
  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }
  function Display(place, doc2, input, options) {
    var d = this;
    this.input = input;
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    d.measure = elt("div", null, "CodeMirror-measure");
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    d.lineSpace = eltP(
      "div",
      [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
      null,
      "position: relative; outline: none"
    );
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    d.mover = elt("div", [lines], null, "position: relative");
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
    if (chrome && chrome_version >= 105) {
      d.wrapper.style.clipPath = "inset(0px)";
    }
    d.wrapper.setAttribute("translate", "no");
    if (ie && ie_version < 8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (!webkit && !(gecko && mobile)) {
      d.scroller.draggable = true;
    }
    if (place) {
      if (place.appendChild) {
        place.appendChild(d.wrapper);
      } else {
        place(d.wrapper);
      }
    }
    d.viewFrom = d.viewTo = doc2.first;
    d.reportedViewFrom = d.reportedViewTo = doc2.first;
    d.view = [];
    d.renderedView = null;
    d.externalMeasured = null;
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;
    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.alignWidgets = false;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    d.shift = false;
    d.selForContextMenu = null;
    d.activeTouch = null;
    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);
    input.init(d);
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie) {
    wheelPixelsPerUnit = -0.53;
  } else if (gecko) {
    wheelPixelsPerUnit = 15;
  } else if (chrome) {
    wheelPixelsPerUnit = -0.7;
  } else if (safari) {
    wheelPixelsPerUnit = -1 / 3;
  }
  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
      dx = e.detail;
    }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
      dy = e.detail;
    } else if (dy == null) {
      dy = e.wheelDelta;
    }
    return { x: dx, y: dy };
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta;
  }
  function onScrollWheel(cm, e) {
    if (chrome && chrome_version == 102) {
      if (cm.display.chromeScrollHack == null) {
        cm.display.sizer.style.pointerEvents = "none";
      } else {
        clearTimeout(cm.display.chromeScrollHack);
      }
      cm.display.chromeScrollHack = setTimeout(function() {
        cm.display.chromeScrollHack = null;
        cm.display.sizer.style.pointerEvents = "";
      }, 100);
    }
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
    var pixelsPerUnit = wheelPixelsPerUnit;
    if (e.deltaMode === 0) {
      dx = e.deltaX;
      dy = e.deltaY;
      pixelsPerUnit = 1;
    }
    var display = cm.display, scroll = display.scroller;
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) {
      return;
    }
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i2 = 0; i2 < view.length; i2++) {
          if (view[i2].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }
    if (dx && !gecko && !presto && pixelsPerUnit != null) {
      if (dy && canScrollY) {
        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
      }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
      if (!dy || dy && canScrollY) {
        e_preventDefault(e);
      }
      display.wheelStartX = null;
      return;
    }
    if (dy && pixelsPerUnit != null) {
      var pixels = dy * pixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) {
        top = Math.max(0, top + pixels - 50);
      } else {
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      }
      updateDisplaySimple(cm, { top, bottom: bot });
    }
    if (wheelSamples < 20 && e.deltaMode !== 0) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) {
            return;
          }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) {
            return;
          }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };
  Selection.prototype.primary = function() {
    return this.ranges[this.primIndex];
  };
  Selection.prototype.equals = function(other) {
    if (other == this) {
      return true;
    }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
      return false;
    }
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      var here = this.ranges[i2], there = other.ranges[i2];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
        return false;
      }
    }
    return true;
  };
  Selection.prototype.deepCopy = function() {
    var out = [];
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      out[i2] = new Range(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
    }
    return new Selection(out, this.primIndex);
  };
  Selection.prototype.somethingSelected = function() {
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      if (!this.ranges[i2].empty()) {
        return true;
      }
    }
    return false;
  };
  Selection.prototype.contains = function(pos, end) {
    if (!end) {
      end = pos;
    }
    for (var i2 = 0; i2 < this.ranges.length; i2++) {
      var range2 = this.ranges[i2];
      if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
        return i2;
      }
    }
    return -1;
  };
  var Range = function(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  };
  Range.prototype.from = function() {
    return minPos(this.anchor, this.head);
  };
  Range.prototype.to = function() {
    return maxPos(this.anchor, this.head);
  };
  Range.prototype.empty = function() {
    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
  };
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) {
      return cmp(a.from(), b.from());
    });
    primIndex = indexOf(ranges, prim);
    for (var i2 = 1; i2 < ranges.length; i2++) {
      var cur = ranges[i2], prev = ranges[i2 - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i2 <= primIndex) {
          --primIndex;
        }
        ranges.splice(--i2, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }
  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }
  function changeEnd(change) {
    if (!change.text) {
      return change.to;
    }
    return Pos(
      change.from.line + change.text.length - 1,
      lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0)
    );
  }
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) {
      return pos;
    }
    if (cmp(pos, change.to) <= 0) {
      return changeEnd(change);
    }
    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) {
      ch += changeEnd(change).ch - change.to.ch;
    }
    return Pos(line, ch);
  }
  function computeSelAfterChange(doc2, change) {
    var out = [];
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      var range2 = doc2.sel.ranges[i2];
      out.push(new Range(
        adjustForChange(range2.anchor, change),
        adjustForChange(range2.head, change)
      ));
    }
    return normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
  }
  function offsetPos(pos, old, nw) {
    if (pos.line == old.line) {
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    } else {
      return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
  }
  function computeReplacedSel(doc2, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc2.first, 0), newPrev = oldPrev;
    for (var i2 = 0; i2 < changes.length; i2++) {
      var change = changes[i2];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range2 = doc2.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
        out[i2] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i2] = new Range(from, from);
      }
    }
    return new Selection(out, doc2.sel.primIndex);
  }
  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }
  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) {
      regChange(cm);
    }
  }
  function isWholeLineUpdate(doc2, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc2.cm || doc2.cm.options.wholeLineUpdateBefore);
  }
  function updateDoc(doc2, change, markedSpans, estimateHeight2) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text2, spans) {
      updateLine(line, text2, spans, estimateHeight2);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i2 = start; i2 < end; ++i2) {
        result.push(new Line(text[i2], spansFor(i2), estimateHeight2));
      }
      return result;
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc2, from.line), lastLine = getLine(doc2, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (change.full) {
      doc2.insert(0, linesFor(0, text.length));
      doc2.remove(text.length, doc2.size - text.length);
    } else if (isWholeLineUpdate(doc2, change)) {
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) {
        doc2.remove(from.line, nlines);
      }
      if (added.length) {
        doc2.insert(from.line, added);
      }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added\$1 = linesFor(1, text.length - 1);
        added\$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc2.insert(from.line + 1, added\$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc2.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added\$2 = linesFor(1, text.length - 1);
      if (nlines > 1) {
        doc2.remove(from.line + 1, nlines - 1);
      }
      doc2.insert(from.line + 1, added\$2);
    }
    signalLater(doc2, "change", doc2, change);
  }
  function linkedDocs(doc2, f, sharedHistOnly) {
    function propagate(doc3, skip, sharedHist) {
      if (doc3.linked) {
        for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
          var rel = doc3.linked[i2];
          if (rel.doc == skip) {
            continue;
          }
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared) {
            continue;
          }
          f(rel.doc, shared);
          propagate(rel.doc, doc3, shared);
        }
      }
    }
    propagate(doc2, null, true);
  }
  function attachDoc(cm, doc2) {
    if (doc2.cm) {
      throw new Error("This document is already in use.");
    }
    cm.doc = doc2;
    doc2.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    cm.options.direction = doc2.direction;
    if (!cm.options.lineWrapping) {
      findMaxLine(cm);
    }
    cm.options.mode = doc2.modeOption;
    regChange(cm);
  }
  function setDirectionClass(cm) {
    (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }
  function directionChanged(cm) {
    runInOp(cm, function() {
      setDirectionClass(cm);
      regChange(cm);
    });
  }
  function History(prev) {
    this.done = [];
    this.undone = [];
    this.undoDepth = prev ? prev.undoDepth : Infinity;
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
  }
  function historyChangeFromChange(doc2, change) {
    var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc2, change.from, change.to) };
    attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc2, function(doc3) {
      return attachLocalSpans(doc3, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) {
        array.pop();
      } else {
        break;
      }
    }
  }
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }
  function addChangeToHistory(doc2, change, selAfter, opId) {
    var hist = doc2.history;
    hist.undone.length = 0;
    var time = +/* @__PURE__ */ new Date(), cur;
    var last;
    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc2.cm ? doc2.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc2, change));
      }
    } else {
      var before = lst(hist.done);
      if (!before || !before.ranges) {
        pushSelectionToHistory(doc2.sel, hist.done);
      }
      cur = {
        changes: [historyChangeFromChange(doc2, change)],
        generation: hist.generation
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) {
          hist.done.shift();
        }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;
    if (!last) {
      signal(doc2, "historyAdded");
    }
  }
  function selectionEventCanBeMerged(doc2, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && /* @__PURE__ */ new Date() - doc2.history.lastSelTime <= (doc2.cm ? doc2.cm.options.historyEventDelay : 500);
  }
  function addSelectionToHistory(doc2, sel, opId, options) {
    var hist = doc2.history, origin = options && options.origin;
    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc2, origin, lst(hist.done), sel))) {
      hist.done[hist.done.length - 1] = sel;
    } else {
      pushSelectionToHistory(sel, hist.done);
    }
    hist.lastSelTime = +/* @__PURE__ */ new Date();
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false) {
      clearSelectionEvents(hist.undone);
    }
  }
  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel))) {
      dest.push(sel);
    }
  }
  function attachLocalSpans(doc2, change, from, to) {
    var existing = change["spans_" + doc2.id], n = 0;
    doc2.iter(Math.max(doc2.first, from), Math.min(doc2.first + doc2.size, to), function(line) {
      if (line.markedSpans) {
        (existing || (existing = change["spans_" + doc2.id] = {}))[n] = line.markedSpans;
      }
      ++n;
    });
  }
  function removeClearedSpans(spans) {
    if (!spans) {
      return null;
    }
    var out;
    for (var i2 = 0; i2 < spans.length; ++i2) {
      if (spans[i2].marker.explicitlyCleared) {
        if (!out) {
          out = spans.slice(0, i2);
        }
      } else if (out) {
        out.push(spans[i2]);
      }
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc2, change) {
    var found = change["spans_" + doc2.id];
    if (!found) {
      return null;
    }
    var nw = [];
    for (var i2 = 0; i2 < change.text.length; ++i2) {
      nw.push(removeClearedSpans(found[i2]));
    }
    return nw;
  }
  function mergeOldSpans(doc2, change) {
    var old = getOldSpans(doc2, change);
    var stretched = stretchSpansOverChange(doc2, change);
    if (!old) {
      return stretched;
    }
    if (!stretched) {
      return old;
    }
    for (var i2 = 0; i2 < old.length; ++i2) {
      var oldCur = old[i2], stretchCur = stretched[i2];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k) {
            if (oldCur[k].marker == span.marker) {
              continue spans;
            }
          }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i2] = stretchCur;
      }
    }
    return old;
  }
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i2 = 0; i2 < events.length; ++i2) {
      var event = events[i2];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({ changes: newChanges });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = void 0;
        newChanges.push({ from: change.from, to: change.to, text: change.text });
        if (newGroup) {
          for (var prop2 in change) {
            if (m = prop2.match(/^spans_(\\d+)\$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop2] = change[prop2];
                delete change[prop2];
              }
            }
          }
        }
      }
    }
    return copy;
  }
  function extendRange(range2, head, other, extend) {
    if (extend) {
      var anchor = range2.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != cmp(other, anchor) < 0) {
          anchor = head;
          head = other;
        } else if (posBefore != cmp(head, other) < 0) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }
  function extendSelection(doc2, head, other, options, extend) {
    if (extend == null) {
      extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
    }
    setSelection(doc2, new Selection([extendRange(doc2.sel.primary(), head, other, extend)], 0), options);
  }
  function extendSelections(doc2, heads, options) {
    var out = [];
    var extend = doc2.cm && (doc2.cm.display.shift || doc2.extend);
    for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
      out[i2] = extendRange(doc2.sel.ranges[i2], heads[i2], null, extend);
    }
    var newSel = normalizeSelection(doc2.cm, out, doc2.sel.primIndex);
    setSelection(doc2, newSel, options);
  }
  function replaceOneSelection(doc2, i2, range2, options) {
    var ranges = doc2.sel.ranges.slice(0);
    ranges[i2] = range2;
    setSelection(doc2, normalizeSelection(doc2.cm, ranges, doc2.sel.primIndex), options);
  }
  function setSimpleSelection(doc2, anchor, head, options) {
    setSelection(doc2, simpleSelection(anchor, head), options);
  }
  function filterSelectionChange(doc2, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          this.ranges[i2] = new Range(
            clipPos(doc2, ranges[i2].anchor),
            clipPos(doc2, ranges[i2].head)
          );
        }
      },
      origin: options && options.origin
    };
    signal(doc2, "beforeSelectionChange", doc2, obj);
    if (doc2.cm) {
      signal(doc2.cm, "beforeSelectionChange", doc2.cm, obj);
    }
    if (obj.ranges != sel.ranges) {
      return normalizeSelection(doc2.cm, obj.ranges, obj.ranges.length - 1);
    } else {
      return sel;
    }
  }
  function setSelectionReplaceHistory(doc2, sel, options) {
    var done = doc2.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc2, sel, options);
    } else {
      setSelection(doc2, sel, options);
    }
  }
  function setSelection(doc2, sel, options) {
    setSelectionNoUndo(doc2, sel, options);
    addSelectionToHistory(doc2, doc2.sel, doc2.cm ? doc2.cm.curOp.id : NaN, options);
  }
  function setSelectionNoUndo(doc2, sel, options) {
    if (hasHandler(doc2, "beforeSelectionChange") || doc2.cm && hasHandler(doc2.cm, "beforeSelectionChange")) {
      sel = filterSelectionChange(doc2, sel, options);
    }
    var bias = options && options.bias || (cmp(sel.primary().head, doc2.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc2, skipAtomicInSelection(doc2, sel, bias, true));
    if (!(options && options.scroll === false) && doc2.cm && doc2.cm.getOption("readOnly") != "nocursor") {
      ensureCursorVisible(doc2.cm);
    }
  }
  function setSelectionInner(doc2, sel) {
    if (sel.equals(doc2.sel)) {
      return;
    }
    doc2.sel = sel;
    if (doc2.cm) {
      doc2.cm.curOp.updateInput = 1;
      doc2.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc2.cm);
    }
    signalLater(doc2, "cursorActivity", doc2);
  }
  function reCheckSelection(doc2) {
    setSelectionInner(doc2, skipAtomicInSelection(doc2, doc2.sel, null, false));
  }
  function skipAtomicInSelection(doc2, sel, bias, mayClear) {
    var out;
    for (var i2 = 0; i2 < sel.ranges.length; i2++) {
      var range2 = sel.ranges[i2];
      var old = sel.ranges.length == doc2.sel.ranges.length && doc2.sel.ranges[i2];
      var newAnchor = skipAtomic(doc2, range2.anchor, old && old.anchor, bias, mayClear);
      var newHead = range2.head == range2.anchor ? newAnchor : skipAtomic(doc2, range2.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range2.anchor || newHead != range2.head) {
        if (!out) {
          out = sel.ranges.slice(0, i2);
        }
        out[i2] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc2.cm, out, sel.primIndex) : sel;
  }
  function skipAtomicInner(doc2, pos, oldPos, dir, mayClear) {
    var line = getLine(doc2, pos.line);
    if (line.markedSpans) {
      for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
        var sp = line.markedSpans[i2], m = sp.marker;
        var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
        var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
          if (mayClear) {
            signal(m, "beforeCursorEnter");
            if (m.explicitlyCleared) {
              if (!line.markedSpans) {
                break;
              } else {
                --i2;
                continue;
              }
            }
          }
          if (!m.atomic) {
            continue;
          }
          if (oldPos) {
            var near = m.find(dir < 0 ? 1 : -1), diff = void 0;
            if (dir < 0 ? preventCursorRight : preventCursorLeft) {
              near = movePos(doc2, near, -dir, near && near.line == pos.line ? line : null);
            }
            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
              return skipAtomicInner(doc2, near, pos, dir, mayClear);
            }
          }
          var far = m.find(dir < 0 ? -1 : 1);
          if (dir < 0 ? preventCursorLeft : preventCursorRight) {
            far = movePos(doc2, far, dir, far.line == pos.line ? line : null);
          }
          return far ? skipAtomicInner(doc2, far, pos, dir, mayClear) : null;
        }
      }
    }
    return pos;
  }
  function skipAtomic(doc2, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc2, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, dir, true) || skipAtomicInner(doc2, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc2, pos, oldPos, -dir, true);
    if (!found) {
      doc2.cantEdit = true;
      return Pos(doc2.first, 0);
    }
    return found;
  }
  function movePos(doc2, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc2.first) {
        return clipPos(doc2, Pos(pos.line - 1));
      } else {
        return null;
      }
    } else if (dir > 0 && pos.ch == (line || getLine(doc2, pos.line)).text.length) {
      if (pos.line < doc2.first + doc2.size - 1) {
        return Pos(pos.line + 1, 0);
      } else {
        return null;
      }
    } else {
      return new Pos(pos.line, pos.ch + dir);
    }
  }
  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }
  function filterChange(doc2, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() {
        return obj.canceled = true;
      }
    };
    if (update) {
      obj.update = function(from, to, text, origin) {
        if (from) {
          obj.from = clipPos(doc2, from);
        }
        if (to) {
          obj.to = clipPos(doc2, to);
        }
        if (text) {
          obj.text = text;
        }
        if (origin !== void 0) {
          obj.origin = origin;
        }
      };
    }
    signal(doc2, "beforeChange", doc2, obj);
    if (doc2.cm) {
      signal(doc2.cm, "beforeChange", doc2.cm, obj);
    }
    if (obj.canceled) {
      if (doc2.cm) {
        doc2.cm.curOp.updateInput = 2;
      }
      return null;
    }
    return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
  }
  function makeChange(doc2, change, ignoreReadOnly) {
    if (doc2.cm) {
      if (!doc2.cm.curOp) {
        return operation(doc2.cm, makeChange)(doc2, change, ignoreReadOnly);
      }
      if (doc2.cm.state.suppressEdits) {
        return;
      }
    }
    if (hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange")) {
      change = filterChange(doc2, change, true);
      if (!change) {
        return;
      }
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc2, change.from, change.to);
    if (split) {
      for (var i2 = split.length - 1; i2 >= 0; --i2) {
        makeChangeInner(doc2, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
      }
    } else {
      makeChangeInner(doc2, change);
    }
  }
  function makeChangeInner(doc2, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
      return;
    }
    var selAfter = computeSelAfterChange(doc2, change);
    addChangeToHistory(doc2, change, selAfter, doc2.cm ? doc2.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc2, change, selAfter, stretchSpansOverChange(doc2, change));
    var rebased = [];
    linkedDocs(doc2, function(doc3, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
        rebaseHist(doc3.history, change);
        rebased.push(doc3.history);
      }
      makeChangeSingleDoc(doc3, change, null, stretchSpansOverChange(doc3, change));
    });
  }
  function makeChangeFromHistory(doc2, type2, allowSelectionOnly) {
    var suppress = doc2.cm && doc2.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) {
      return;
    }
    var hist = doc2.history, event, selAfter = doc2.sel;
    var source = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
    var i2 = 0;
    for (; i2 < source.length; i2++) {
      event = source[i2];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc2.sel) : !event.ranges) {
        break;
      }
    }
    if (i2 == source.length) {
      return;
    }
    hist.lastOrigin = hist.lastSelOrigin = null;
    for (; ; ) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc2.sel)) {
          setSelection(doc2, event, { clearRedo: false });
          return;
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return;
      } else {
        break;
      }
    }
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({ changes: antiChanges, generation: hist.generation });
    hist.generation = event.generation || ++hist.maxGeneration;
    var filter = hasHandler(doc2, "beforeChange") || doc2.cm && hasHandler(doc2.cm, "beforeChange");
    var loop = function(i3) {
      var change = event.changes[i3];
      change.origin = type2;
      if (filter && !filterChange(doc2, change, false)) {
        source.length = 0;
        return {};
      }
      antiChanges.push(historyChangeFromChange(doc2, change));
      var after = i3 ? computeSelAfterChange(doc2, change) : lst(source);
      makeChangeSingleDoc(doc2, change, after, mergeOldSpans(doc2, change));
      if (!i3 && doc2.cm) {
        doc2.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
      }
      var rebased = [];
      linkedDocs(doc2, function(doc3, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc3.history) == -1) {
          rebaseHist(doc3.history, change);
          rebased.push(doc3.history);
        }
        makeChangeSingleDoc(doc3, change, null, mergeOldSpans(doc3, change));
      });
    };
    for (var i\$12 = event.changes.length - 1; i\$12 >= 0; --i\$12) {
      var returned = loop(i\$12);
      if (returned) return returned.v;
    }
  }
  function shiftDoc(doc2, distance) {
    if (distance == 0) {
      return;
    }
    doc2.first += distance;
    doc2.sel = new Selection(map(doc2.sel.ranges, function(range2) {
      return new Range(
        Pos(range2.anchor.line + distance, range2.anchor.ch),
        Pos(range2.head.line + distance, range2.head.ch)
      );
    }), doc2.sel.primIndex);
    if (doc2.cm) {
      regChange(doc2.cm, doc2.first, doc2.first - distance, distance);
      for (var d = doc2.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
        regLineChange(doc2.cm, l, "gutter");
      }
    }
  }
  function makeChangeSingleDoc(doc2, change, selAfter, spans) {
    if (doc2.cm && !doc2.cm.curOp) {
      return operation(doc2.cm, makeChangeSingleDoc)(doc2, change, selAfter, spans);
    }
    if (change.to.line < doc2.first) {
      shiftDoc(doc2, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc2.lastLine()) {
      return;
    }
    if (change.from.line < doc2.first) {
      var shift = change.text.length - 1 - (doc2.first - change.from.line);
      shiftDoc(doc2, shift);
      change = {
        from: Pos(doc2.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc2.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc2, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc2, change.from, change.to);
    if (!selAfter) {
      selAfter = computeSelAfterChange(doc2, change);
    }
    if (doc2.cm) {
      makeChangeSingleDocInEditor(doc2.cm, change, spans);
    } else {
      updateDoc(doc2, change, spans);
    }
    setSelectionNoUndo(doc2, selAfter, sel_dontScroll);
    if (doc2.cantEdit && skipAtomic(doc2, Pos(doc2.firstLine(), 0))) {
      doc2.cantEdit = false;
    }
  }
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc2 = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc2, from.line)));
      doc2.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (doc2.sel.contains(change.from, change.to) > -1) {
      signalCursorActivity(cm);
    }
    updateDoc(doc2, change, spans, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc2.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) {
        cm.curOp.updateMaxLine = true;
      }
    }
    retreatFrontier(doc2, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    if (change.full) {
      regChange(cm);
    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
      regLineChange(cm, from.line, "text");
    } else {
      regChange(cm, from.line, to.line + 1, lendiff);
    }
    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from,
        to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) {
        signalLater(cm, "change", cm, obj);
      }
      if (changesHandler) {
        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
      }
    }
    cm.display.selForContextMenu = null;
  }
  function replaceRange(doc2, code, from, to, origin) {
    var assign;
    if (!to) {
      to = from;
    }
    if (cmp(to, from) < 0) {
      assign = [to, from], from = assign[0], to = assign[1];
    }
    if (typeof code == "string") {
      code = doc2.splitLines(code);
    }
    makeChange(doc2, { from, to, text: code, origin });
  }
  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i2 = 0; i2 < array.length; ++i2) {
      var sub = array[i2], ok = true;
      if (sub.ranges) {
        if (!sub.copied) {
          sub = array[i2] = sub.deepCopy();
          sub.copied = true;
        }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j\$1 = 0; j\$1 < sub.changes.length; ++j\$1) {
        var cur = sub.changes[j\$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i2 + 1);
        i2 = 0;
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function changeLine(doc2, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") {
      line = getLine(doc2, clipLine(doc2, handle));
    } else {
      no = lineNo(handle);
    }
    if (no == null) {
      return null;
    }
    if (op(line, no) && doc2.cm) {
      regLineChange(doc2.cm, no, changeType);
    }
    return line;
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i2 = 0; i2 < lines.length; ++i2) {
      lines[i2].parent = this;
      height += lines[i2].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function() {
      return this.lines.length;
    },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i2 = at, e = at + n; i2 < e; ++i2) {
        var line = this.lines[i2];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i2 = 0; i2 < lines.length; ++i2) {
        lines[i2].parent = this;
      }
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at) {
        if (op(this.lines[at])) {
          return true;
        }
      }
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i2 = 0; i2 < children.length; ++i2) {
      var ch = children[i2];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function() {
      return this.size;
    },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i2--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        this.children[i2].collapse(lines);
      }
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length; ) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i2, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) {
        return;
      }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i2 = 0; i2 < this.children.length; ++i2) {
        var child = this.children[i2], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) {
            return true;
          }
          if ((n -= used) == 0) {
            break;
          }
          at = 0;
        } else {
          at -= sz;
        }
      }
    }
  };
  var LineWidget = function(doc2, node, options) {
    if (options) {
      for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
          this[opt] = options[opt];
        }
      }
    }
    this.doc = doc2;
    this.node = node;
  };
  LineWidget.prototype.clear = function() {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) {
      return;
    }
    for (var i2 = 0; i2 < ws.length; ++i2) {
      if (ws[i2] == this) {
        ws.splice(i2--, 1);
      }
    }
    if (!ws.length) {
      line.widgets = null;
    }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function() {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };
  LineWidget.prototype.changed = function() {
    var this\$1\$1 = this;
    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) {
      return;
    }
    if (!lineIsHidden(this.doc, line)) {
      updateLineHeight(line, line.height + diff);
    }
    if (cm) {
      runInOp(cm, function() {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this\$1\$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);
  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
      addToScrollTop(cm, diff);
    }
  }
  function addLineWidget(doc2, handle, node, options) {
    var widget = new LineWidget(doc2, node, options);
    var cm = doc2.cm;
    if (cm && widget.noHScroll) {
      cm.display.alignWidgets = true;
    }
    changeLine(doc2, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) {
        widgets.push(widget);
      } else {
        widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
      }
      widget.line = line;
      if (cm && !lineIsHidden(doc2, line)) {
        var aboveVisible = heightAtLine(line) < doc2.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) {
          addToScrollTop(cm, widget.height);
        }
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    if (cm) {
      signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
    }
    return widget;
  }
  var nextMarkerId = 0;
  var TextMarker = function(doc2, type2) {
    this.lines = [];
    this.type = type2;
    this.doc = doc2;
    this.id = ++nextMarkerId;
  };
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) {
      return;
    }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) {
      startOperation(cm);
    }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) {
        signalLater(this, "clear", found.from, found.to);
      }
    }
    var min = null, max = null;
    for (var i2 = 0; i2 < this.lines.length; ++i2) {
      var line = this.lines[i2];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) {
        regLineChange(cm, lineNo(line), "text");
      } else if (cm) {
        if (span.to != null) {
          max = lineNo(line);
        }
        if (span.from != null) {
          min = lineNo(line);
        }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
        updateLineHeight(line, textHeight(cm.display));
      }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) {
      for (var i\$12 = 0; i\$12 < this.lines.length; ++i\$12) {
        var visual = visualLine(this.lines[i\$12]), len = lineLength(visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    }
    if (min != null && cm && this.collapsed) {
      regChange(cm, min, max + 1);
    }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) {
        reCheckSelection(cm.doc);
      }
    }
    if (cm) {
      signalLater(cm, "markerCleared", cm, this, min, max);
    }
    if (withOp) {
      endOperation(cm);
    }
    if (this.parent) {
      this.parent.clear();
    }
  };
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") {
      side = 1;
    }
    var from, to;
    for (var i2 = 0; i2 < this.lines.length; ++i2) {
      var line = this.lines[i2];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) {
          return from;
        }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) {
          return to;
        }
      }
    }
    return from && { from, to };
  };
  TextMarker.prototype.changed = function() {
    var this\$1\$1 = this;
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) {
      return;
    }
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight) {
          updateLineHeight(line, line.height + dHeight);
        }
      }
      signalLater(cm, "markerChanged", cm, this\$1\$1);
    });
  };
  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
      }
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);
  function markText(doc2, from, to, options, type2) {
    if (options && options.shared) {
      return markTextShared(doc2, from, to, options, type2);
    }
    if (doc2.cm && !doc2.cm.curOp) {
      return operation(doc2.cm, markText)(doc2, from, to, options, type2);
    }
    var marker = new TextMarker(doc2, type2), diff = cmp(from, to);
    if (options) {
      copyObj(options, marker, false);
    }
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
      return marker;
    }
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) {
        marker.widgetNode.setAttribute("cm-ignore-events", "true");
      }
      if (options.insertLeft) {
        marker.widgetNode.insertLeft = true;
      }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc2, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc2, to.line, from, to, marker)) {
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      }
      seeCollapsedSpans();
    }
    if (marker.addToHistory) {
      addChangeToHistory(doc2, { from, to, origin: "markText" }, doc2.sel, NaN);
    }
    var curLine = from.line, cm = doc2.cm, updateMaxLine;
    doc2.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
        updateMaxLine = true;
      }
      if (marker.collapsed && curLine != from.line) {
        updateLineHeight(line, 0);
      }
      addMarkedSpan(line, new MarkedSpan(
        marker,
        curLine == from.line ? from.ch : null,
        curLine == to.line ? to.ch : null
      ), doc2.cm && doc2.cm.curOp);
      ++curLine;
    });
    if (marker.collapsed) {
      doc2.iter(from.line, to.line + 1, function(line) {
        if (lineIsHidden(doc2, line)) {
          updateLineHeight(line, 0);
        }
      });
    }
    if (marker.clearOnEnter) {
      on(marker, "beforeCursorEnter", function() {
        return marker.clear();
      });
    }
    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc2.history.done.length || doc2.history.undone.length) {
        doc2.clearHistory();
      }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine) {
        cm.curOp.updateMaxLine = true;
      }
      if (marker.collapsed) {
        regChange(cm, from.line, to.line + 1);
      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
        for (var i2 = from.line; i2 <= to.line; i2++) {
          regLineChange(cm, i2, "text");
        }
      }
      if (marker.atomic) {
        reCheckSelection(cm.doc);
      }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i2 = 0; i2 < markers.length; ++i2) {
      markers[i2].parent = this;
    }
  };
  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) {
      return;
    }
    this.explicitlyCleared = true;
    for (var i2 = 0; i2 < this.markers.length; ++i2) {
      this.markers[i2].clear();
    }
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };
  eventMixin(SharedTextMarker);
  function markTextShared(doc2, from, to, options, type2) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc2, from, to, options, type2)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc2, function(doc3) {
      if (widget) {
        options.widgetNode = widget.cloneNode(true);
      }
      markers.push(markText(doc3, clipPos(doc3, from), clipPos(doc3, to), options, type2));
      for (var i2 = 0; i2 < doc3.linked.length; ++i2) {
        if (doc3.linked[i2].isParent) {
          return;
        }
      }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function findSharedMarkers(doc2) {
    return doc2.findMarks(Pos(doc2.first, 0), doc2.clipPos(Pos(doc2.lastLine())), function(m) {
      return m.parent;
    });
  }
  function copySharedMarkers(doc2, markers) {
    for (var i2 = 0; i2 < markers.length; i2++) {
      var marker = markers[i2], pos = marker.find();
      var mFrom = doc2.clipPos(pos.from), mTo = doc2.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc2, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }
  function detachSharedMarkers(markers) {
    var loop = function(i3) {
      var marker = markers[i3], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function(d) {
        return linked.push(d);
      });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };
    for (var i2 = 0; i2 < markers.length; i2++) loop(i2);
  }
  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) {
      return new Doc(text, mode, firstLine, lineSep, direction);
    }
    if (firstLine == null) {
      firstLine = 0;
    }
    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = direction == "rtl" ? "rtl" : "ltr";
    this.extend = false;
    if (typeof text == "string") {
      text = this.splitLines(text);
    }
    updateDoc(this, { from: start, to: start, text });
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };
  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) {
        this.iterN(from - this.first, to - from, op);
      } else {
        this.iterN(this.first, this.first + this.size, from);
      }
    },
    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i2 = 0; i2 < lines.length; ++i2) {
        height += lines[i2].height;
      }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) {
      this.removeInner(at - this.first, n);
    },
    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.
    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) {
        return lines;
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: this.splitLines(code),
        origin: "setValue",
        full: true
      }, true);
      if (this.cm) {
        scrollToCoords(this.cm, 0, 0);
      }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) {
        return lines;
      }
      if (lineSep === "") {
        return lines.join("");
      }
      return lines.join(lineSep || this.lineSeparator());
    },
    getLine: function(line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    getLineHandle: function(line) {
      if (isLine(this, line)) {
        return getLine(this, line);
      }
    },
    getLineNumber: function(line) {
      return lineNo(line);
    },
    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") {
        line = getLine(this, line);
      }
      return visualLine(line);
    },
    lineCount: function() {
      return this.size;
    },
    firstLine: function() {
      return this.first;
    },
    lastLine: function() {
      return this.first + this.size - 1;
    },
    clipPos: function(pos) {
      return clipPos(this, pos);
    },
    getCursor: function(start) {
      var range2 = this.sel.primary(), pos;
      if (start == null || start == "head") {
        pos = range2.head;
      } else if (start == "anchor") {
        pos = range2.anchor;
      } else if (start == "end" || start == "to" || start === false) {
        pos = range2.to();
      } else {
        pos = range2.from();
      }
      return pos;
    },
    listSelections: function() {
      return this.sel.ranges;
    },
    somethingSelected: function() {
      return this.sel.somethingSelected();
    },
    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) {
        return;
      }
      var out = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        out[i2] = new Range(
          clipPos(this, ranges[i2].anchor),
          clipPos(this, ranges[i2].head || ranges[i2].anchor)
        );
      }
      if (primary == null) {
        primary = Math.min(ranges.length - 1, this.sel.primIndex);
      }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),
    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) {
        return lines;
      } else {
        return lines.join(lineSep || this.lineSeparator());
      }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
        if (lineSep !== false) {
          sel = sel.join(lineSep || this.lineSeparator());
        }
        parts[i2] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
        dup[i2] = code;
      }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
        var range2 = sel.ranges[i2];
        changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i\$12 = changes.length - 1; i\$12 >= 0; i\$12--) {
        makeChange(this, changes[i\$12]);
      }
      if (newSel) {
        setSelectionReplaceHistory(this, newSel);
      } else if (this.cm) {
        ensureCursorVisible(this.cm);
      }
    }),
    undo: docMethodOp(function() {
      makeChangeFromHistory(this, "undo");
    }),
    redo: docMethodOp(function() {
      makeChangeFromHistory(this, "redo");
    }),
    undoSelection: docMethodOp(function() {
      makeChangeFromHistory(this, "undo", true);
    }),
    redoSelection: docMethodOp(function() {
      makeChangeFromHistory(this, "redo", true);
    }),
    setExtending: function(val) {
      this.extend = val;
    },
    getExtending: function() {
      return this.extend;
    },
    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i2 = 0; i2 < hist.done.length; i2++) {
        if (!hist.done[i2].ranges) {
          ++done;
        }
      }
      for (var i\$12 = 0; i\$12 < hist.undone.length; i\$12++) {
        if (!hist.undone[i\$12].ranges) {
          ++undone;
        }
      }
      return { undo: done, redo: undone };
    },
    clearHistory: function() {
      var this\$1\$1 = this;
      this.history = new History(this.history);
      linkedDocs(this, function(doc2) {
        return doc2.history = this\$1\$1.history;
      }, true);
    },
    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit) {
        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
      }
      return this.history.generation;
    },
    isClean: function(gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },
    getHistory: function() {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },
    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function(line2) {
        var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) {
          line2.gutterMarkers = null;
        }
        return true;
      });
    }),
    clearGutter: docMethodOp(function(gutterID) {
      var this\$1\$1 = this;
      this.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this\$1\$1, line, "gutter", function() {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) {
              line.gutterMarkers = null;
            }
            return true;
          });
        }
      });
    }),
    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) {
          return null;
        }
        n = line;
        line = getLine(this, line);
        if (!line) {
          return null;
        }
      } else {
        n = lineNo(line);
        if (n == null) {
          return null;
        }
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop2]) {
          line[prop2] = cls;
        } else if (classTest(cls).test(line[prop2])) {
          return false;
        } else {
          line[prop2] += " " + cls;
        }
        return true;
      });
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
        var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop2];
        if (!cur) {
          return false;
        } else if (cls == null) {
          line[prop2] = null;
        } else {
          var found = cur.match(classTest(cls));
          if (!found) {
            return false;
          }
          var end = found.index + found[0].length;
          line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),
    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function(widget) {
      widget.clear();
    },
    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {
        replacedWith: options && (options.nodeType == null ? options.widget : options),
        insertLeft: options && options.insertLeft,
        clearWhenEmpty: false,
        shared: options && options.shared,
        handleMouseEvents: options && options.handleMouseEvents
      };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
            markers.push(span.marker.parent || span.marker);
          }
        }
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from);
      to = clipPos(this, to);
      var found = [], lineNo2 = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) {
          for (var i2 = 0; i2 < spans.length; i2++) {
            var span = spans[i2];
            if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
              found.push(span.marker.parent || span.marker);
            }
          }
        }
        ++lineNo2;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            if (sps[i2].from != null) {
              markers.push(sps[i2].marker);
            }
          }
        }
      });
      return markers;
    },
    posFromIndex: function(off2) {
      var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
      this.iter(function(line) {
        var sz = line.text.length + sepSize;
        if (sz > off2) {
          ch = off2;
          return true;
        }
        off2 -= sz;
        ++lineNo2;
      });
      return clipPos(this, Pos(lineNo2, ch));
    },
    indexFromPos: function(coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) {
        return 0;
      }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function(line) {
        index += line.text.length + sepSize;
      });
      return index;
    },
    copy: function(copyHistory) {
      var doc2 = new Doc(
        getLines(this, this.first, this.first + this.size),
        this.modeOption,
        this.first,
        this.lineSep,
        this.direction
      );
      doc2.scrollTop = this.scrollTop;
      doc2.scrollLeft = this.scrollLeft;
      doc2.sel = this.sel;
      doc2.extend = false;
      if (copyHistory) {
        doc2.history.undoDepth = this.history.undoDepth;
        doc2.setHistory(this.getHistory());
      }
      return doc2;
    },
    linkedDoc: function(options) {
      if (!options) {
        options = {};
      }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) {
        from = options.from;
      }
      if (options.to != null && options.to < to) {
        to = options.to;
      }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) {
        copy.history = this.history;
      }
      (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
      copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror2) {
        other = other.doc;
      }
      if (this.linked) {
        for (var i2 = 0; i2 < this.linked.length; ++i2) {
          var link = this.linked[i2];
          if (link.doc != other) {
            continue;
          }
          this.linked.splice(i2, 1);
          other.unlinkDoc(this);
          detachSharedMarkers(findSharedMarkers(this));
          break;
        }
      }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc2) {
          return splitIds.push(doc2.id);
        }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {
      linkedDocs(this, f);
    },
    getMode: function() {
      return this.mode;
    },
    getEditor: function() {
      return this.cm;
    },
    splitLines: function(str) {
      if (this.lineSep) {
        return str.split(this.lineSep);
      }
      return splitLinesAuto(str);
    },
    lineSeparator: function() {
      return this.lineSep || "\\n";
    },
    setDirection: docMethodOp(function(dir) {
      if (dir != "rtl") {
        dir = "ltr";
      }
      if (dir == this.direction) {
        return;
      }
      this.direction = dir;
      this.iter(function(line) {
        return line.order = null;
      });
      if (this.cm) {
        directionChanged(this.cm);
      }
    })
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var lastDrop = 0;
  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e_preventDefault(e);
    if (ie) {
      lastDrop = +/* @__PURE__ */ new Date();
    }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) {
      return;
    }
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function() {
        if (++read == n) {
          operation(cm, function() {
            pos = clipPos(cm.doc, pos);
            var change = {
              from: pos,
              to: pos,
              text: cm.doc.splitLines(
                text.filter(function(t) {
                  return t != null;
                }).join(cm.doc.lineSeparator())
              ),
              origin: "paste"
            };
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function(file, i3) {
        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return;
        }
        var reader = new FileReader();
        reader.onerror = function() {
          return markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.onload = function() {
          var content = reader.result;
          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          text[i3] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i2 = 0; i2 < files.length; i2++) {
        readTextFromFile(files[i2], i2);
      }
    } else {
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        setTimeout(function() {
          return cm.display.input.focus();
        }, 20);
        return;
      }
      try {
        var text\$1 = e.dataTransfer.getData("Text");
        if (text\$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy) {
            selected = cm.listSelections();
          }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) {
            for (var i\$12 = 0; i\$12 < selected.length; ++i\$12) {
              replaceRange(cm.doc, "", selected[i\$12].anchor, selected[i\$12].head, "drag");
            }
          }
          cm.replaceSelection(text\$1, "around", "paste");
          cm.display.input.focus();
        }
      } catch (e\$1) {
      }
    }
  }
  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +/* @__PURE__ */ new Date() - lastDrop < 100)) {
      e_stop(e);
      return;
    }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
      return;
    }
    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) {
        img.parentNode.removeChild(img);
      }
    }
  }
  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) {
      return;
    }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }
  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }
  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) {
      return;
    }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i2 = 0; i2 < byClass.length; i2++) {
      var cm = byClass[i2].CodeMirror;
      if (cm) {
        editors.push(cm);
      }
    }
    if (editors.length) {
      editors[0].operation(function() {
        for (var i3 = 0; i3 < editors.length; i3++) {
          f(editors[i3]);
        }
      });
    }
  }
  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) {
      return;
    }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    var resizeTimer;
    on(window, "resize", function() {
      if (resizeTimer == null) {
        resizeTimer = setTimeout(function() {
          resizeTimer = null;
          forEachCodeMirror(onResize);
        }, 100);
      }
    });
    on(window, "blur", function() {
      return forEachCodeMirror(onBlur);
    });
  }
  function onResize(cm) {
    var d = cm.display;
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }
  var keyNames = {
    3: "Pause",
    8: "Backspace",
    9: "Tab",
    13: "Enter",
    16: "Shift",
    17: "Ctrl",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Esc",
    32: "Space",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "Left",
    38: "Up",
    39: "Right",
    40: "Down",
    44: "PrintScrn",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Mod",
    92: "Mod",
    93: "Mod",
    106: "*",
    107: "=",
    109: "-",
    110: ".",
    111: "/",
    145: "ScrollLock",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "\`",
    219: "[",
    220: "\\\\",
    221: "]",
    222: "'",
    224: "Mod",
    63232: "Up",
    63233: "Down",
    63234: "Left",
    63235: "Right",
    63272: "Delete",
    63273: "Home",
    63275: "End",
    63276: "PageUp",
    63277: "PageDown",
    63302: "Insert"
  };
  for (var i = 0; i < 10; i++) {
    keyNames[i + 48] = keyNames[i + 96] = String(i);
  }
  for (var i\$1 = 65; i\$1 <= 90; i\$1++) {
    keyNames[i\$1] = String.fromCharCode(i\$1);
  }
  for (var i\$2 = 1; i\$2 <= 12; i\$2++) {
    keyNames[i\$2 + 111] = keyNames[i\$2 + 63235] = "F" + i\$2;
  }
  var keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft",
    "Right": "goCharRight",
    "Up": "goLineUp",
    "Down": "goLineDown",
    "End": "goLineEnd",
    "Home": "goLineStartSmart",
    "PageUp": "goPageUp",
    "PageDown": "goPageDown",
    "Delete": "delCharAfter",
    "Backspace": "delCharBefore",
    "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab",
    "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent",
    "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll",
    "Ctrl-D": "deleteLine",
    "Ctrl-Z": "undo",
    "Shift-Ctrl-Z": "redo",
    "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart",
    "Ctrl-End": "goDocEnd",
    "Ctrl-Up": "goLineUp",
    "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft",
    "Ctrl-Right": "goGroupRight",
    "Alt-Left": "goLineStart",
    "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore",
    "Ctrl-Delete": "delGroupAfter",
    "Ctrl-S": "save",
    "Ctrl-F": "find",
    "Ctrl-G": "findNext",
    "Shift-Ctrl-G": "findPrev",
    "Shift-Ctrl-F": "replace",
    "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess",
    "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection",
    "Shift-Ctrl-U": "redoSelection",
    "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight",
    "Ctrl-B": "goCharLeft",
    "Ctrl-P": "goLineUp",
    "Ctrl-N": "goLineDown",
    "Ctrl-A": "goLineStart",
    "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown",
    "Shift-Ctrl-V": "goPageUp",
    "Ctrl-D": "delCharAfter",
    "Ctrl-H": "delCharBefore",
    "Alt-Backspace": "delWordBefore",
    "Ctrl-K": "killLine",
    "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll",
    "Cmd-D": "deleteLine",
    "Cmd-Z": "undo",
    "Shift-Cmd-Z": "redo",
    "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart",
    "Cmd-Up": "goDocStart",
    "Cmd-End": "goDocEnd",
    "Cmd-Down": "goDocEnd",
    "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight",
    "Cmd-Left": "goLineLeft",
    "Cmd-Right": "goLineRight",
    "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter",
    "Alt-Delete": "delGroupAfter",
    "Cmd-S": "save",
    "Cmd-F": "find",
    "Cmd-G": "findNext",
    "Shift-Cmd-G": "findPrev",
    "Cmd-Alt-F": "replace",
    "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess",
    "Cmd-]": "indentMore",
    "Cmd-Backspace": "delWrappedLineLeft",
    "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection",
    "Shift-Cmd-U": "redoSelection",
    "Ctrl-Up": "goDocStart",
    "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
  function normalizeKeyName(name) {
    var parts = name.split(/-(?!\$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i2 = 0; i2 < parts.length - 1; i2++) {
      var mod = parts[i2];
      if (/^(cmd|meta|m)\$/i.test(mod)) {
        cmd = true;
      } else if (/^a(lt)?\$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)\$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?\$/i.test(mod)) {
        shift = true;
      } else {
        throw new Error("Unrecognized modifier name: " + mod);
      }
    }
    if (alt) {
      name = "Alt-" + name;
    }
    if (ctrl) {
      name = "Ctrl-" + name;
    }
    if (cmd) {
      name = "Cmd-" + name;
    }
    if (shift) {
      name = "Shift-" + name;
    }
    return name;
  }
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) {
      if (keymap.hasOwnProperty(keyname)) {
        var value = keymap[keyname];
        if (/^(name|fallthrough|(de|at)tach)\$/.test(keyname)) {
          continue;
        }
        if (value == "...") {
          delete keymap[keyname];
          continue;
        }
        var keys = map(keyname.split(" "), normalizeKeyName);
        for (var i2 = 0; i2 < keys.length; i2++) {
          var val = void 0, name = void 0;
          if (i2 == keys.length - 1) {
            name = keys.join(" ");
            val = value;
          } else {
            name = keys.slice(0, i2 + 1).join(" ");
            val = "...";
          }
          var prev = copy[name];
          if (!prev) {
            copy[name] = val;
          } else if (prev != val) {
            throw new Error("Inconsistent bindings for " + name);
          }
        }
        delete keymap[keyname];
      }
    }
    for (var prop2 in copy) {
      keymap[prop2] = copy[prop2];
    }
    return keymap;
  }
  function lookupKey(key, map2, handle, context) {
    map2 = getKeyMap(map2);
    var found = map2.call ? map2.call(key, context) : map2[key];
    if (found === false) {
      return "nothing";
    }
    if (found === "...") {
      return "multi";
    }
    if (found != null && handle(found)) {
      return "handled";
    }
    if (map2.fallthrough) {
      if (Object.prototype.toString.call(map2.fallthrough) != "[object Array]") {
        return lookupKey(key, map2.fallthrough, handle, context);
      }
      for (var i2 = 0; i2 < map2.fallthrough.length; i2++) {
        var result = lookupKey(key, map2.fallthrough[i2], handle, context);
        if (result) {
          return result;
        }
      }
    }
  }
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  }
  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") {
      name = "Alt-" + name;
    }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
      name = "Ctrl-" + name;
    }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") {
      name = "Cmd-" + name;
    }
    if (!noShift && event.shiftKey && base != "Shift") {
      name = "Shift-" + name;
    }
    return name;
  }
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) {
      return false;
    }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) {
      return false;
    }
    if (event.keyCode == 3 && event.code) {
      name = event.code;
    }
    return addModifierNames(name, event, noShift);
  }
  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val;
  }
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    for (var i2 = 0; i2 < ranges.length; i2++) {
      var toKill = compute(ranges[i2]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    runInOp(cm, function() {
      for (var i3 = kill.length - 1; i3 >= 0; i3--) {
        replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
      }
      ensureCursorVisible(cm);
    });
  }
  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
  }
  function endOfLine(visually, cm, lineObj, lineNo2, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") {
        dir = -dir;
      }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = dir < 0 == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function(ch2) {
            return measureCharPrepared(cm, prep, ch2).top == targetTop;
          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") {
            ch = moveCharLogically(lineObj, ch, 1);
          }
        } else {
          ch = dir < 0 ? part.to : part.from;
        }
        return new Pos(lineNo2, ch, sticky);
      }
    }
    return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
  }
  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) {
      return moveLogically(line, start, dir);
    }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      return moveLogically(line, start, dir);
    }
    var mv = function(pos, dir2) {
      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
    };
    var prep;
    var getWrappedLineExtent = function(ch2) {
      if (!cm.options.lineWrapping) {
        return { begin: 0, end: line.text.length };
      }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch2);
    };
    var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = part.level == 1 == dir < 0;
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky);
      }
    }
    var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
      var getRes = function(ch3, moveInStorageOrder3) {
        return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
      };
      for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
        var part2 = bidi[partPos2];
        var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
        var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
        if (part2.from <= ch2 && ch2 < part2.to) {
          return getRes(ch2, moveInStorageOrder2);
        }
        ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
        if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
          return getRes(ch2, moveInStorageOrder2);
        }
      }
    };
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
    if (res) {
      return res;
    }
    var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) {
        return res;
      }
    }
    return null;
  }
  var commands = {
    selectAll,
    singleSelection: function(cm) {
      return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        if (range2.empty()) {
          var len = getLine(cm.doc, range2.head.line).text.length;
          if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
            return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
          } else {
            return { from: range2.head, to: Pos(range2.head.line, len) };
          }
        } else {
          return { from: range2.from(), to: range2.to() };
        }
      });
    },
    deleteLine: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        return {
          from: Pos(range2.from().line, 0),
          to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
        };
      });
    },
    delLineLeft: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        return {
          from: Pos(range2.from().line, 0),
          to: range2.from()
        };
      });
    },
    delWrappedLineLeft: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        var top = cm.charCoords(range2.head, "div").top + 5;
        var leftPos = cm.coordsChar({ left: 0, top }, "div");
        return { from: leftPos, to: range2.from() };
      });
    },
    delWrappedLineRight: function(cm) {
      return deleteNearSelection(cm, function(range2) {
        var top = cm.charCoords(range2.head, "div").top + 5;
        var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
        return { from: range2.from(), to: rightPos };
      });
    },
    undo: function(cm) {
      return cm.undo();
    },
    redo: function(cm) {
      return cm.redo();
    },
    undoSelection: function(cm) {
      return cm.undoSelection();
    },
    redoSelection: function(cm) {
      return cm.redoSelection();
    },
    goDocStart: function(cm) {
      return cm.extendSelection(Pos(cm.firstLine(), 0));
    },
    goDocEnd: function(cm) {
      return cm.extendSelection(Pos(cm.lastLine()));
    },
    goLineStart: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineStart(cm, range2.head.line);
        },
        { origin: "+move", bias: 1 }
      );
    },
    goLineStartSmart: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineStartSmart(cm, range2.head);
        },
        { origin: "+move", bias: 1 }
      );
    },
    goLineEnd: function(cm) {
      return cm.extendSelectionsBy(
        function(range2) {
          return lineEnd(cm, range2.head.line);
        },
        { origin: "+move", bias: -1 }
      );
    },
    goLineRight: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        return cm.coordsChar({ left: 0, top }, "div");
      }, sel_move);
    },
    goLineLeftSmart: function(cm) {
      return cm.extendSelectionsBy(function(range2) {
        var top = cm.cursorCoords(range2.head, "div").top + 5;
        var pos = cm.coordsChar({ left: 0, top }, "div");
        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {
          return lineStartSmart(cm, range2.head);
        }
        return pos;
      }, sel_move);
    },
    goLineUp: function(cm) {
      return cm.moveV(-1, "line");
    },
    goLineDown: function(cm) {
      return cm.moveV(1, "line");
    },
    goPageUp: function(cm) {
      return cm.moveV(-1, "page");
    },
    goPageDown: function(cm) {
      return cm.moveV(1, "page");
    },
    goCharLeft: function(cm) {
      return cm.moveH(-1, "char");
    },
    goCharRight: function(cm) {
      return cm.moveH(1, "char");
    },
    goColumnLeft: function(cm) {
      return cm.moveH(-1, "column");
    },
    goColumnRight: function(cm) {
      return cm.moveH(1, "column");
    },
    goWordLeft: function(cm) {
      return cm.moveH(-1, "word");
    },
    goGroupRight: function(cm) {
      return cm.moveH(1, "group");
    },
    goGroupLeft: function(cm) {
      return cm.moveH(-1, "group");
    },
    goWordRight: function(cm) {
      return cm.moveH(1, "word");
    },
    delCharBefore: function(cm) {
      return cm.deleteH(-1, "codepoint");
    },
    delCharAfter: function(cm) {
      return cm.deleteH(1, "char");
    },
    delWordBefore: function(cm) {
      return cm.deleteH(-1, "word");
    },
    delWordAfter: function(cm) {
      return cm.deleteH(1, "word");
    },
    delGroupBefore: function(cm) {
      return cm.deleteH(-1, "group");
    },
    delGroupAfter: function(cm) {
      return cm.deleteH(1, "group");
    },
    indentAuto: function(cm) {
      return cm.indentSelection("smart");
    },
    indentMore: function(cm) {
      return cm.indentSelection("add");
    },
    indentLess: function(cm) {
      return cm.indentSelection("subtract");
    },
    insertTab: function(cm) {
      return cm.replaceSelection("	");
    },
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var pos = ranges[i2].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) {
        cm.indentSelection("add");
      } else {
        cm.execCommand("insertTab");
      }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function(cm) {
      return runInOp(cm, function() {
        var ranges = cm.listSelections(), newSel = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          if (!ranges[i2].empty()) {
            continue;
          }
          var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
          if (line) {
            if (cur.ch == line.length) {
              cur = new Pos(cur.line, cur.ch - 1);
            }
            if (cur.ch > 0) {
              cur = new Pos(cur.line, cur.ch + 1);
              cm.replaceRange(
                line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                Pos(cur.line, cur.ch - 2),
                cur,
                "+transpose"
              );
            } else if (cur.line > cm.doc.first) {
              var prev = getLine(cm.doc, cur.line - 1).text;
              if (prev) {
                cur = new Pos(cur.line, 1);
                cm.replaceRange(
                  line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1),
                  Pos(cur.line - 1, prev.length - 1),
                  cur,
                  "+transpose"
                );
              }
            }
          }
          newSel.push(new Range(cur, cur));
        }
        cm.setSelections(newSel);
      });
    },
    newlineAndIndent: function(cm) {
      return runInOp(cm, function() {
        var sels = cm.listSelections();
        for (var i2 = sels.length - 1; i2 >= 0; i2--) {
          cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
        }
        sels = cm.listSelections();
        for (var i\$12 = 0; i\$12 < sels.length; i\$12++) {
          cm.indentLine(sels[i\$12].from().line, null, true);
        }
        ensureCursorVisible(cm);
      });
    },
    openLine: function(cm) {
      return cm.replaceSelection("\\n", "start");
    },
    toggleOverwrite: function(cm) {
      return cm.toggleOverwrite();
    }
  };
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, visual, lineN, 1);
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) {
      lineN = lineNo(visual);
    }
    return endOfLine(true, cm, line, lineN, -1);
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
    }
    return start;
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) {
        return false;
      }
    }
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) {
        cm.state.suppressEdits = true;
      }
      if (dropShift) {
        cm.display.shift = false;
      }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function lookupKeyForEditor(cm, name, handle) {
    for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
      var result = lookupKey(name, cm.state.keyMaps[i2], handle, cm);
      if (result) {
        return result;
      }
    }
    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
  }
  var stopSeq = new Delayed();
  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) {
        return "handled";
      }
      if (/\\'\$/.test(name)) {
        cm.state.keySeq = null;
      } else {
        stopSeq.set(50, function() {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        });
      }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
        return true;
      }
    }
    return dispatchKeyInner(cm, name, e, handle);
  }
  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);
    if (result == "multi") {
      cm.state.keySeq = name;
    }
    if (result == "handled") {
      signalLater(cm, "keyHandled", cm, name, e);
    }
    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return !!result;
  }
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) {
      return false;
    }
    if (e.shiftKey && !cm.state.keySeq) {
      return dispatchKey(cm, "Shift-" + name, e, function(b) {
        return doHandleBinding(cm, b, true);
      }) || dispatchKey(cm, name, e, function(b) {
        if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
          return doHandleBinding(cm, b);
        }
      });
    } else {
      return dispatchKey(cm, name, e, function(b) {
        return doHandleBinding(cm, b);
      });
    }
  }
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function(b) {
      return doHandleBinding(cm, b, true);
    });
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) {
      return;
    }
    cm.curOp.focus = activeElt(doc(cm));
    if (signalDOMEvent(cm, e)) {
      return;
    }
    if (ie && ie_version < 11 && e.keyCode == 27) {
      e.returnValue = false;
    }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
        cm.replaceSelection("", null, "cut");
      }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
      document.execCommand("cut");
    }
    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {
      showCrossHair(cm);
    }
  }
  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");
    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }
  function onKeyUp(e) {
    if (e.keyCode == 16) {
      this.doc.sel.shift = false;
    }
    signalDOMEvent(this, e);
  }
  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) {
      return;
    }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
      return;
    }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
      return;
    }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (ch == "\\b") {
      return;
    }
    if (handleCharBinding(cm, e, ch)) {
      return;
    }
    cm.display.input.onKeyPress(e);
  }
  var DOUBLECLICK_DELAY = 400;
  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };
  PastClick.prototype.compare = function(time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
  };
  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +/* @__PURE__ */ new Date();
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple";
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double";
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single";
    }
  }
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
      return;
    }
    display.input.ensurePolled();
    display.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function() {
          return display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) {
      return;
    }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat2 = pos ? clickRepeat(pos, button) : "single";
    win(cm).focus();
    if (button == 1 && cm.state.selectingText) {
      cm.state.selectingText(e);
    }
    if (pos && handleMappedButton(cm, button, pos, repeat2, e)) {
      return;
    }
    if (button == 1) {
      if (pos) {
        leftButtonDown(cm, pos, repeat2, e);
      } else if (e_target(e) == display.scroller) {
        e_preventDefault(e);
      }
    } else if (button == 2) {
      if (pos) {
        extendSelection(cm.doc, pos);
      }
      setTimeout(function() {
        return display.input.focus();
      }, 20);
    } else if (button == 3) {
      if (captureRightClick) {
        cm.display.input.onContextMenu(e);
      } else {
        delayBlurEvent(cm);
      }
    }
  }
  function handleMappedButton(cm, button, pos, repeat2, event) {
    var name = "Click";
    if (repeat2 == "double") {
      name = "Double" + name;
    } else if (repeat2 == "triple") {
      name = "Triple" + name;
    }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
    return dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
      if (typeof bound == "string") {
        bound = commands[bound];
      }
      if (!bound) {
        return false;
      }
      var done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done;
    });
  }
  function configureMouse(cm, repeat2, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat2, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat2 == "single" ? "char" : repeat2 == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) {
      value.extend = cm.doc.extend || event.shiftKey;
    }
    if (value.addNew == null) {
      value.addNew = mac ? event.metaKey : event.ctrlKey;
    }
    if (value.moveOnDrag == null) {
      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
    }
    return value;
  }
  function leftButtonDown(cm, pos, repeat2, event) {
    if (ie) {
      setTimeout(bind(ensureFocus, cm), 0);
    } else {
      cm.curOp.focus = activeElt(doc(cm));
    }
    var behavior = configureMouse(cm, repeat2, event);
    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat2 == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
      leftButtonStartDrag(cm, event, pos, behavior);
    } else {
      leftButtonSelect(cm, event, pos, behavior);
    }
  }
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function(e) {
      if (webkit) {
        display.scroller.draggable = false;
      }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) {
          cm.state.delayingBlurEvent = false;
        } else {
          delayBlurEvent(cm);
        }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew) {
          extendSelection(cm.doc, pos, null, null, behavior.extend);
        }
        if (webkit && !safari || ie && ie_version == 9) {
          setTimeout(function() {
            display.wrapper.ownerDocument.body.focus({ preventScroll: true });
            display.input.focus();
          }, 20);
        } else {
          display.input.focus();
        }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function() {
      return moved = true;
    };
    if (webkit) {
      display.scroller.draggable = true;
    }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);
    cm.state.delayingBlurEvent = true;
    setTimeout(function() {
      return display.input.focus();
    }, 20);
    if (display.scroller.dragDrop) {
      display.scroller.dragDrop();
    }
  }
  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") {
      return new Range(pos, pos);
    }
    if (unit == "word") {
      return cm.findWordAt(pos);
    }
    if (unit == "line") {
      return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
    }
    var result = unit(cm, pos);
    return new Range(result.from, result.to);
  }
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) {
      delayBlurEvent(cm);
    }
    var display = cm.display, doc\$1 = cm.doc;
    e_preventDefault(event);
    var ourRange, ourIndex, startSel = doc\$1.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc\$1.sel.contains(start);
      if (ourIndex > -1) {
        ourRange = ranges[ourIndex];
      } else {
        ourRange = new Range(start, start);
      }
    } else {
      ourRange = doc\$1.sel.primary();
      ourIndex = doc\$1.sel.primIndex;
    }
    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) {
        ourRange = new Range(start, start);
      }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range2 = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend) {
        ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
      } else {
        ourRange = range2;
      }
    }
    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc\$1, new Selection([ourRange], 0), sel_mouse);
      startSel = doc\$1.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(
        doc\$1,
        normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
        { scroll: false, origin: "*mouse" }
      );
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(
        doc\$1,
        normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
        { scroll: false, origin: "*mouse" }
      );
      startSel = doc\$1.sel;
    } else {
      replaceOneSelection(doc\$1, ourIndex, ourRange, sel_mouse);
    }
    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) {
        return;
      }
      lastPos = pos;
      if (behavior.unit == "rectangle") {
        var ranges2 = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc\$1, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc\$1, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
          var text = getLine(doc\$1, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right) {
            ranges2.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          } else if (text.length > leftPos) {
            ranges2.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
          }
        }
        if (!ranges2.length) {
          ranges2.push(new Range(start, start));
        }
        setSelection(
          doc\$1,
          normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex),
          { origin: "*mouse", scroll: false }
        );
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range3 = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range3.anchor, anchor) > 0) {
          head = range3.head;
          anchor = minPos(oldRange.from(), range3.anchor);
        } else {
          head = range3.anchor;
          anchor = maxPos(oldRange.to(), range3.head);
        }
        var ranges\$1 = startSel.ranges.slice(0);
        ranges\$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc\$1, anchor), head));
        setSelection(doc\$1, normalizeSelection(cm, ranges\$1, ourIndex), sel_mouse);
      }
    }
    var editorSize = display.wrapper.getBoundingClientRect();
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) {
        return;
      }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt(doc(cm));
        extendTo(cur);
        var visible = visibleLines(display, doc\$1);
        if (cur.line >= visible.to || cur.line < visible.from) {
          setTimeout(operation(cm, function() {
            if (counter == curCount) {
              extend(e);
            }
          }), 150);
        }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) {
          setTimeout(operation(cm, function() {
            if (counter != curCount) {
              return;
            }
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
        }
      }
    }
    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc\$1.history.lastSelOrigin = null;
    }
    var move = operation(cm, function(e) {
      if (e.buttons === 0 || !e_button(e)) {
        done(e);
      } else {
        extend(e);
      }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }
  function bidiSimplify(cm, range2) {
    var anchor = range2.anchor;
    var head = range2.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
      return range2;
    }
    var order = getOrder(anchorLine);
    if (!order) {
      return range2;
    }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) {
      return range2;
    }
    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) {
      return range2;
    }
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary) {
        leftSide = dir < 0;
      } else {
        leftSide = dir > 0;
      }
    }
    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range(new Pos(anchor.line, ch, sticky), head);
  }
  function gutterEvent(cm, e, type2, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try {
        mX = e.clientX;
        mY = e.clientY;
      } catch (e\$1) {
        return false;
      }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
      return false;
    }
    if (prevent) {
      e_preventDefault(e);
    }
    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();
    if (mY > lineBox.bottom || !hasHandler(cm, type2)) {
      return e_defaultPrevented(e);
    }
    mY -= lineBox.top - display.viewOffset;
    for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
      var g = display.gutters.childNodes[i2];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i2];
        signal(cm, type2, cm, line, gutter.className, e);
        return e_defaultPrevented(e);
      }
    }
  }
  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true);
  }
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
      return;
    }
    if (signalDOMEvent(cm, e, "contextmenu")) {
      return;
    }
    if (!captureRightClick) {
      cm.display.input.onContextMenu(e);
    }
  }
  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) {
      return false;
    }
    return gutterEvent(cm, e, "gutterContextMenu", false);
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") + cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");
    clearCaches(cm);
  }
  var Init = { toString: function() {
    return "CodeMirror.Init";
  } };
  var defaults = {};
  var optionHandlers = {};
  function defineOptions(CodeMirror3) {
    var optionHandlers2 = CodeMirror3.optionHandlers;
    function option(name, deflt, handle, notOnInit) {
      CodeMirror3.defaults[name] = deflt;
      if (handle) {
        optionHandlers2[name] = notOnInit ? function(cm, val, old) {
          if (old != Init) {
            handle(cm, val, old);
          }
        } : handle;
      }
    }
    CodeMirror3.defineOption = option;
    CodeMirror3.Init = Init;
    option("value", "", function(cm, val) {
      return cm.setValue(val);
    }, true);
    option("mode", null, function(cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);
    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function(cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);
    option("lineSeparator", null, function(cm, val) {
      cm.doc.lineSep = val;
      if (!val) {
        return;
      }
      var newBreaks = [], lineNo2 = cm.doc.first;
      cm.doc.iter(function(line) {
        for (var pos = 0; ; ) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) {
            break;
          }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo2, found));
        }
        lineNo2++;
      });
      for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
        replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
      }
    });
    option("specialChars", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function(cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
      if (old != Init) {
        cm.refresh();
      }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
      return cm.refresh();
    }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
      throw new Error("inputStyle can not (yet) be changed in a running editor");
    }, true);
    option("spellcheck", false, function(cm, val) {
      return cm.getInputField().spellcheck = val;
    }, true);
    option("autocorrect", false, function(cm, val) {
      return cm.getInputField().autocorrect = val;
    }, true);
    option("autocapitalize", false, function(cm, val) {
      return cm.getInputField().autocapitalize = val;
    }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);
    option("theme", "default", function(cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function(cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) {
        prev.detach(cm, next);
      }
      if (next.attach) {
        next.attach(cm, prev || null);
      }
    });
    option("extraKeys", null);
    option("configureMouse", null);
    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function(cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function(cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function(cm) {
      return updateScrollbars(cm);
    }, true);
    option("scrollbarStyle", "native", function(cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function(cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function(integer) {
      return integer;
    }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);
    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);
    option("readOnly", false, function(cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });
    option("screenReaderLabel", null, function(cm, val) {
      val = val === "" ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });
    option("disableInput", false, function(cm, val) {
      if (!val) {
        cm.display.input.reset();
      }
    }, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);
    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function(cm, val) {
      return cm.doc.history.undoDepth = val;
    });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function(cm) {
      return cm.refresh();
    }, true);
    option("maxHighlightLength", 1e4, resetModeState, true);
    option("moveInputWithCursor", true, function(cm, val) {
      if (!val) {
        cm.display.input.resetPosition();
      }
    });
    option("tabindex", null, function(cm, val) {
      return cm.display.input.getField().tabIndex = val || "";
    });
    option("autofocus", null);
    option("direction", "ltr", function(cm, val) {
      return cm.doc.setDirection(val);
    }, true);
    option("phrases", null);
  }
  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function() {
      return updateScrollbars(cm);
    }, 100);
  }
  function CodeMirror2(place, options) {
    var this\$1\$1 = this;
    if (!(this instanceof CodeMirror2)) {
      return new CodeMirror2(place, options);
    }
    this.options = options = options ? copyObj(options) : {};
    copyObj(defaults, options, false);
    var doc2 = options.value;
    if (typeof doc2 == "string") {
      doc2 = new Doc(doc2, options.mode, null, options.lineSeparator, options.direction);
    } else if (options.mode) {
      doc2.modeOption = options.mode;
    }
    this.doc = doc2;
    var input = new CodeMirror2.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc2, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping) {
      this.display.wrapper.className += " CodeMirror-wrap";
    }
    initScrollbars(this);
    this.state = {
      keyMaps: [],
      // stores maps added by addKeyMap
      overlays: [],
      // highlighting overlays, as added by addOverlay
      modeGen: 0,
      // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false,
      // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1,
      cutIncoming: -1,
      // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(),
      // stores highlight worker timeout
      keySeq: null,
      // Unfinished key sequence
      specialChars: null
    };
    if (options.autofocus && !mobile) {
      display.input.focus();
    }
    if (ie && ie_version < 11) {
      setTimeout(function() {
        return this\$1\$1.display.input.reset(true);
      }, 20);
    }
    registerEventHandlers(this);
    ensureGlobalHandlers();
    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc2);
    if (options.autofocus && !mobile || this.hasFocus()) {
      setTimeout(function() {
        if (this\$1\$1.hasFocus() && !this\$1\$1.state.focused) {
          onFocus(this\$1\$1);
        }
      }, 20);
    } else {
      onBlur(this);
    }
    for (var opt in optionHandlers) {
      if (optionHandlers.hasOwnProperty(opt)) {
        optionHandlers[opt](this, options[opt], Init);
      }
    }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) {
      options.finishInit(this);
    }
    for (var i2 = 0; i2 < initHooks.length; ++i2) {
      initHooks[i2](this);
    }
    endOperation(this);
    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
      display.lineDiv.style.textRendering = "auto";
    }
  }
  CodeMirror2.defaults = defaults;
  CodeMirror2.optionHandlers = optionHandlers;
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    if (ie && ie_version < 11) {
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    } else {
      on(d.scroller, "dblclick", function(e) {
        return signalDOMEvent(cm, e) || e_preventDefault(e);
      });
    }
    on(d.scroller, "contextmenu", function(e) {
      return onContextMenu(cm, e);
    });
    on(d.input.getField(), "contextmenu", function(e) {
      if (!d.scroller.contains(e.target)) {
        onContextMenu(cm, e);
      }
    });
    var touchFinished, prevTouch = { end: 0 };
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function() {
          return d.activeTouch = null;
        }, 1e3);
        prevTouch = d.activeTouch;
        prevTouch.end = +/* @__PURE__ */ new Date();
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) {
        return false;
      }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1;
    }
    function farAway(touch, other) {
      if (other.left == null) {
        return true;
      }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20;
    }
    on(d.scroller, "touchstart", function(e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +/* @__PURE__ */ new Date();
        d.activeTouch = {
          start: now,
          moved: false,
          prev: now - prevTouch.end <= 300 ? prevTouch : null
        };
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function() {
      if (d.activeTouch) {
        d.activeTouch.moved = true;
      }
    });
    on(d.scroller, "touchend", function(e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && /* @__PURE__ */ new Date() - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range2;
        if (!touch.prev || farAway(touch, touch.prev)) {
          range2 = new Range(pos, pos);
        } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
          range2 = cm.findWordAt(pos);
        } else {
          range2 = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        cm.setSelection(range2.anchor, range2.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scroller, "mousewheel", function(e) {
      return onScrollWheel(cm, e);
    });
    on(d.scroller, "DOMMouseScroll", function(e) {
      return onScrollWheel(cm, e);
    });
    on(d.wrapper, "scroll", function() {
      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    d.dragFunctions = {
      enter: function(e) {
        if (!signalDOMEvent(cm, e)) {
          e_stop(e);
        }
      },
      over: function(e) {
        if (!signalDOMEvent(cm, e)) {
          onDragOver(cm, e);
          e_stop(e);
        }
      },
      start: function(e) {
        return onDragStart(cm, e);
      },
      drop: operation(cm, onDrop),
      leave: function(e) {
        if (!signalDOMEvent(cm, e)) {
          clearDragCursor(cm);
        }
      }
    };
    var inp = d.input.getField();
    on(inp, "keyup", function(e) {
      return onKeyUp.call(cm, e);
    });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function(e) {
      return onFocus(cm, e);
    });
    on(inp, "blur", function(e) {
      return onBlur(cm, e);
    });
  }
  var initHooks = [];
  CodeMirror2.defineInitHook = function(f) {
    return initHooks.push(f);
  };
  function indentLine(cm, n, how, aggressive) {
    var doc2 = cm.doc, state;
    if (how == null) {
      how = "add";
    }
    if (how == "smart") {
      if (!doc2.mode.indent) {
        how = "prev";
      } else {
        state = getContextBefore(cm, n).state;
      }
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc2, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) {
      line.stateAfter = null;
    }
    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;
    if (!aggressive && !/\\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc2.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) {
          return;
        }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc2.first) {
        indentation = countColumn(getLine(doc2, n - 1).text, null, tabSize);
      } else {
        indentation = 0;
      }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);
    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs) {
      for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
        pos += tabSize;
        indentString += "	";
      }
    }
    if (pos < indentation) {
      indentString += spaceStr(indentation - pos);
    }
    if (indentString != curSpaceString) {
      replaceRange(doc2, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true;
    } else {
      for (var i\$12 = 0; i\$12 < doc2.sel.ranges.length; i\$12++) {
        var range2 = doc2.sel.ranges[i\$12];
        if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
          var pos\$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc2, i\$12, new Range(pos\$1, pos\$1));
          break;
        }
      }
    }
  }
  var lastCopied = null;
  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }
  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc2 = cm.doc;
    cm.display.shift = false;
    if (!sel) {
      sel = doc2.sel;
    }
    var recent = +/* @__PURE__ */ new Date() - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
            multiPaste.push(doc2.splitLines(lastCopied.text[i2]));
          }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function(l) {
          return [l];
        });
      }
    }
    var updateInput = cm.curOp.updateInput;
    for (var i\$12 = sel.ranges.length - 1; i\$12 >= 0; i\$12--) {
      var range2 = sel.ranges[i\$12];
      var from = range2.from(), to = range2.to();
      if (range2.empty()) {
        if (deleted && deleted > 0) {
          from = Pos(from.line, from.ch - deleted);
        } else if (cm.state.overwrite && !paste) {
          to = Pos(to.line, Math.min(getLine(doc2, to.line).text.length, to.ch + lst(textLines).length));
        } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\\n") == textLines.join("\\n")) {
          from = to = Pos(from.line, 0);
        }
      }
      var changeEvent = {
        from,
        to,
        text: multiPaste ? multiPaste[i\$12 % multiPaste.length] : textLines,
        origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
      };
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste) {
      triggerElectric(cm, inserted);
    }
    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) {
      cm.curOp.updateInput = updateInput;
    }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }
  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {
        runInOp(cm, function() {
          return applyTextInput(cm, pasted, 0, null, "paste");
        });
      }
      return true;
    }
  }
  function triggerElectric(cm, inserted) {
    if (!cm.options.electricChars || !cm.options.smartIndent) {
      return;
    }
    var sel = cm.doc.sel;
    for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
      var range2 = sel.ranges[i2];
      if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
        continue;
      }
      var mode = cm.getModeAt(range2.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++) {
          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range2.head.line, "smart");
            break;
          }
        }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
          indented = indentLine(cm, range2.head.line, "smart");
        }
      }
      if (indented) {
        signalLater(cm, "electricInput", cm, range2.head.line);
      }
    }
  }
  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
      var line = cm.doc.sel.ranges[i2].head.line;
      var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return { text, ranges };
  }
  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "on" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "on" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }
  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    if (webkit) {
      te.style.width = "1000px";
    } else {
      te.setAttribute("wrap", "off");
    }
    if (ios) {
      te.style.border = "1px solid black";
    }
    return div;
  }
  function addEditorMethods(CodeMirror3) {
    var optionHandlers2 = CodeMirror3.optionHandlers;
    var helpers = CodeMirror3.helpers = {};
    CodeMirror3.prototype = {
      constructor: CodeMirror3,
      focus: function() {
        win(this).focus();
        this.display.input.focus();
      },
      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") {
          return;
        }
        options[option] = value;
        if (optionHandlers2.hasOwnProperty(option)) {
          operation(this, optionHandlers2[option])(this, value, old);
        }
        signal(this, "optionChange", this, option);
      },
      getOption: function(option) {
        return this.options[option];
      },
      getDoc: function() {
        return this.doc;
      },
      addKeyMap: function(map2, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map2));
      },
      removeKeyMap: function(map2) {
        var maps = this.state.keyMaps;
        for (var i2 = 0; i2 < maps.length; ++i2) {
          if (maps[i2] == map2 || maps[i2].name == map2) {
            maps.splice(i2, 1);
            return true;
          }
        }
      },
      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
        if (mode.startState) {
          throw new Error("Overlays may not be stateful.");
        }
        insertSorted(
          this.state.overlays,
          {
            mode,
            modeSpec: spec,
            opaque: options && options.opaque,
            priority: options && options.priority || 0
          },
          function(overlay) {
            return overlay.priority;
          }
        );
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i2 = 0; i2 < overlays.length; ++i2) {
          var cur = overlays[i2].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i2, 1);
            this.state.modeGen++;
            regChange(this);
            return;
          }
        }
      }),
      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) {
            dir = this.options.smartIndent ? "smart" : "prev";
          } else {
            dir = dir ? "add" : "subtract";
          }
        }
        if (isLine(this.doc, n)) {
          indentLine(this, n, dir, aggressive);
        }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var range2 = ranges[i2];
          if (!range2.empty()) {
            var from = range2.from(), to = range2.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j) {
              indentLine(this, j, how);
            }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
              replaceOneSelection(this.doc, i2, new Range(from, newRanges[i2].to()), sel_dontScroll);
            }
          } else if (range2.head.line > end) {
            indentLine(this, range2.head.line, how, true);
            end = range2.head.line;
            if (i2 == this.doc.sel.primIndex) {
              ensureCursorVisible(this);
            }
          }
        }
      }),
      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise);
      },
      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true);
      },
      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type2;
        if (ch == 0) {
          type2 = styles[2];
        } else {
          for (; ; ) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
              after = mid;
            } else if (styles[mid * 2 + 1] < ch) {
              before = mid + 1;
            } else {
              type2 = styles[mid * 2 + 2];
              break;
            }
          }
        }
        var cut = type2 ? type2.indexOf("overlay ") : -1;
        return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
      },
      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) {
          return mode;
        }
        return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
      },
      getHelper: function(pos, type2) {
        return this.getHelpers(pos, type2)[0];
      },
      getHelpers: function(pos, type2) {
        var found = [];
        if (!helpers.hasOwnProperty(type2)) {
          return found;
        }
        var help = helpers[type2], mode = this.getModeAt(pos);
        if (typeof mode[type2] == "string") {
          if (help[mode[type2]]) {
            found.push(help[mode[type2]]);
          }
        } else if (mode[type2]) {
          for (var i2 = 0; i2 < mode[type2].length; i2++) {
            var val = help[mode[type2][i2]];
            if (val) {
              found.push(val);
            }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i\$12 = 0; i\$12 < help._global.length; i\$12++) {
          var cur = help._global[i\$12];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
            found.push(cur.val);
          }
        }
        return found;
      },
      getStateAfter: function(line, precise) {
        var doc2 = this.doc;
        line = clipLine(doc2, line == null ? doc2.first + doc2.size - 1 : line);
        return getContextBefore(this, line + 1, precise).state;
      },
      cursorCoords: function(start, mode) {
        var pos, range2 = this.doc.sel.primary();
        if (start == null) {
          pos = range2.head;
        } else if (typeof start == "object") {
          pos = clipPos(this.doc, start);
        } else {
          pos = start ? range2.from() : range2.to();
        }
        return cursorCoords(this, pos, mode || "page");
      },
      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page");
      },
      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top);
      },
      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset);
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) {
            line = this.doc.first;
          } else if (line > last) {
            line = last;
            end = true;
          }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
      },
      defaultTextHeight: function() {
        return textHeight(this.display);
      },
      defaultCharWidth: function() {
        return charWidth(this.display);
      },
      getViewport: function() {
        return { from: this.display.viewFrom, to: this.display.viewTo };
      },
      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
            top = pos.top - node.offsetHeight;
          } else if (pos.bottom + node.offsetHeight <= vspace) {
            top = pos.bottom;
          }
          if (left + node.offsetWidth > hspace) {
            left = hspace - node.offsetWidth;
          }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") {
            left = 0;
          } else if (horiz == "middle") {
            left = (display.sizer.clientWidth - node.offsetWidth) / 2;
          }
          node.style.left = left + "px";
        }
        if (scroll) {
          scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
        }
      },
      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),
      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd)) {
          return commands[cmd].call(null, this);
        }
      },
      triggerElectric: methodOp(function(text) {
        triggerElectric(this, text);
      }),
      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i2 = 0; i2 < amount; ++i2) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveH: methodOp(function(dir, unit) {
        var this\$1\$1 = this;
        this.extendSelectionsBy(function(range2) {
          if (this\$1\$1.display.shift || this\$1\$1.doc.extend || range2.empty()) {
            return findPosH(this\$1\$1.doc, range2.head, dir, unit, this\$1\$1.options.rtlMoveVisually);
          } else {
            return dir < 0 ? range2.from() : range2.to();
          }
        }, sel_move);
      }),
      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc2 = this.doc;
        if (sel.somethingSelected()) {
          doc2.replaceSelection("", null, "+delete");
        } else {
          deleteNearSelection(this, function(range2) {
            var other = findPosH(doc2, range2.head, dir, unit, false);
            return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
          });
        }
      }),
      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) {
          dir = -1;
          amount = -amount;
        }
        var cur = clipPos(this.doc, from);
        for (var i2 = 0; i2 < amount; ++i2) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) {
            x = coords.left;
          } else {
            coords.left = x;
          }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) {
            break;
          }
        }
        return cur;
      },
      moveV: methodOp(function(dir, unit) {
        var this\$1\$1 = this;
        var doc2 = this.doc, goals = [];
        var collapse = !this.display.shift && !doc2.extend && doc2.sel.somethingSelected();
        doc2.extendSelectionsBy(function(range2) {
          if (collapse) {
            return dir < 0 ? range2.from() : range2.to();
          }
          var headPos = cursorCoords(this\$1\$1, range2.head, "div");
          if (range2.goalColumn != null) {
            headPos.left = range2.goalColumn;
          }
          goals.push(headPos.left);
          var pos = findPosV(this\$1\$1, headPos, dir, unit);
          if (unit == "page" && range2 == doc2.sel.primary()) {
            addToScrollTop(this\$1\$1, charCoords(this\$1\$1, pos, "div").top - headPos.top);
          }
          return pos;
        }, sel_move);
        if (goals.length) {
          for (var i2 = 0; i2 < doc2.sel.ranges.length; i2++) {
            doc2.sel.ranges[i2].goalColumn = goals[i2];
          }
        }
      }),
      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc2 = this.doc, line = getLine(doc2, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) {
            --start;
          } else {
            ++end;
          }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper) ? function(ch) {
            return isWordChar(ch, helper);
          } : /\\s/.test(startChar) ? function(ch) {
            return /\\s/.test(ch);
          } : function(ch) {
            return !/\\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) {
            --start;
          }
          while (end < line.length && check(line.charAt(end))) {
            ++end;
          }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end));
      },
      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) {
          return;
        }
        if (this.state.overwrite = !this.state.overwrite) {
          addClass(this.display.cursorDiv, "CodeMirror-overwrite");
        } else {
          rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
        }
        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() {
        return this.display.input.getField() == activeElt(doc(this));
      },
      isReadOnly: function() {
        return !!(this.options.readOnly || this.doc.cantEdit);
      },
      scrollTo: methodOp(function(x, y) {
        scrollToCoords(this, x, y);
      }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {
          left: scroller.scrollLeft,
          top: scroller.scrollTop,
          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
          clientHeight: displayHeight(this),
          clientWidth: displayWidth(this)
        };
      },
      scrollIntoView: methodOp(function(range2, margin) {
        if (range2 == null) {
          range2 = { from: this.doc.sel.primary().head, to: null };
          if (margin == null) {
            margin = this.options.cursorScrollMargin;
          }
        } else if (typeof range2 == "number") {
          range2 = { from: Pos(range2, 0), to: null };
        } else if (range2.from == null) {
          range2 = { from: range2, to: null };
        }
        if (!range2.to) {
          range2.to = range2.from;
        }
        range2.margin = margin || 0;
        if (range2.from.line != null) {
          scrollToRange(this, range2);
        } else {
          scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
        }
      }),
      setSize: methodOp(function(width, height) {
        var this\$1\$1 = this;
        var interpret = function(val) {
          return typeof val == "number" || /^\\d+\$/.test(String(val)) ? val + "px" : val;
        };
        if (width != null) {
          this.display.wrapper.style.width = interpret(width);
        }
        if (height != null) {
          this.display.wrapper.style.height = interpret(height);
        }
        if (this.options.lineWrapping) {
          clearLineMeasurementCache(this);
        }
        var lineNo2 = this.display.viewFrom;
        this.doc.iter(lineNo2, this.display.viewTo, function(line) {
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; i2++) {
              if (line.widgets[i2].noHScroll) {
                regLineChange(this\$1\$1, lineNo2, "widget");
                break;
              }
            }
          }
          ++lineNo2;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),
      operation: function(f) {
        return runInOp(this, f);
      },
      startOperation: function() {
        return startOperation(this);
      },
      endOperation: function() {
        return endOperation(this);
      },
      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
          estimateLineHeights(this);
        }
        signal(this, "refresh", this);
      }),
      swapDoc: methodOp(function(doc2) {
        var old = this.doc;
        old.cm = null;
        if (this.state.selectingText) {
          this.state.selectingText();
        }
        attachDoc(this, doc2);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc2.scrollLeft, doc2.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old;
      }),
      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
      },
      getInputField: function() {
        return this.display.input.getField();
      },
      getWrapperElement: function() {
        return this.display.wrapper;
      },
      getScrollerElement: function() {
        return this.display.scroller;
      },
      getGutterElement: function() {
        return this.display.gutters;
      }
    };
    eventMixin(CodeMirror3);
    CodeMirror3.registerHelper = function(type2, name, value) {
      if (!helpers.hasOwnProperty(type2)) {
        helpers[type2] = CodeMirror3[type2] = { _global: [] };
      }
      helpers[type2][name] = value;
    };
    CodeMirror3.registerGlobalHelper = function(type2, name, predicate, value) {
      CodeMirror3.registerHelper(type2, name, value);
      helpers[type2]._global.push({ pred: predicate, val: value });
    };
  }
  function findPosH(doc2, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc2, pos.line);
    var lineDir = visually && doc2.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc2.first || l >= doc2.first + doc2.size) {
        return false;
      }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc2, l);
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc2.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          pos = endOfLine(visually, doc2.cm, lineObj, pos.line, lineDir);
        } else {
          return false;
        }
      } else {
        pos = next;
      }
      return true;
    }
    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc2.cm && doc2.cm.getHelper(pos, "wordChars");
      for (var first = true; ; first = false) {
        if (dir < 0 && !moveOnce(!first)) {
          break;
        }
        var cur = lineObj.text.charAt(pos.ch) || "\\n";
        var type2 = isWordChar(cur, helper) ? "w" : group && cur == "\\n" ? "n" : !group || /\\s/.test(cur) ? null : "p";
        if (group && !first && !type2) {
          type2 = "s";
        }
        if (sawType && sawType != type2) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
            pos.sticky = "after";
          }
          break;
        }
        if (type2) {
          sawType = type2;
        }
        if (dir > 0 && !moveOnce(!first)) {
          break;
        }
      }
    }
    var result = skipAtomic(doc2, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) {
      result.hitSide = true;
    }
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc2 = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc2(cm).documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (; ; ) {
      target = coordsChar(cm, x, y);
      if (!target.outside) {
        break;
      }
      if (dir < 0 ? y <= 0 : y >= doc2.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };
  ContentEditableInput.prototype.init = function(display) {
    var this\$1\$1 = this;
    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    div.contentEditable = true;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) {
          return true;
        }
        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {
          break;
        }
      }
      return false;
    }
    on(div, "paste", function(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      if (ie_version <= 11) {
        setTimeout(operation(cm, function() {
          return this\$1\$1.updateFromDOM();
        }), 20);
      }
    });
    on(div, "compositionstart", function(e) {
      this\$1\$1.composing = { data: e.data, done: false };
    });
    on(div, "compositionupdate", function(e) {
      if (!this\$1\$1.composing) {
        this\$1\$1.composing = { data: e.data, done: false };
      }
    });
    on(div, "compositionend", function(e) {
      if (this\$1\$1.composing) {
        if (e.data != this\$1\$1.composing.data) {
          this\$1\$1.readFromDOMSoon();
        }
        this\$1\$1.composing.done = true;
      }
    });
    on(div, "touchstart", function() {
      return input.forceCompositionEnd();
    });
    on(div, "input", function() {
      if (!this\$1\$1.composing) {
        this\$1\$1.readFromDOMSoon();
      }
    });
    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
        if (e.type == "cut") {
          cm.replaceSelection("", null, "cut");
        }
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.operation(function() {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\\n");
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return;
        }
      }
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      disableBrowserMagic(te);
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\\n");
      var hadFocus = activeElt(div.ownerDocument);
      selectInput(te);
      setTimeout(function() {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) {
          input.showPrimarySelection();
        }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };
  ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
    if (label) {
      this.div.setAttribute("aria-label", label);
    } else {
      this.div.removeAttribute("aria-label");
    }
  };
  ContentEditableInput.prototype.prepareSelection = function() {
    var result = prepareSelection(this.cm, false);
    result.focus = activeElt(this.div.ownerDocument) == this.div;
    return result;
  };
  ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
    if (!info || !this.cm.display.view.length) {
      return;
    }
    if (info.focus || takeFocus) {
      this.showPrimarySelection();
    }
    this.showMultipleSelections(info);
  };
  ContentEditableInput.prototype.getSelection = function() {
    return this.cm.display.wrapper.ownerDocument.getSelection();
  };
  ContentEditableInput.prototype.showPrimarySelection = function() {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();
    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return;
    }
    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
      return;
    }
    var view = cm.display.view;
    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map2 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = { node: map2[map2.length - 1], offset: map2[map2.length - 2] - map2[map2.length - 3] };
    }
    if (!start || !end) {
      sel.removeAllRanges();
      return;
    }
    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try {
      rng = range(start.node, start.offset, end.offset, end.node);
    } catch (e) {
    }
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) {
        sel.addRange(old);
      } else if (gecko) {
        this.startGracePeriod();
      }
    }
    this.rememberSelection();
  };
  ContentEditableInput.prototype.startGracePeriod = function() {
    var this\$1\$1 = this;
    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function() {
      this\$1\$1.gracePeriod = false;
      if (this\$1\$1.selectionChanged()) {
        this\$1\$1.cm.operation(function() {
          return this\$1\$1.cm.curOp.selectionChanged = true;
        });
      }
    }, 20);
  };
  ContentEditableInput.prototype.showMultipleSelections = function(info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };
  ContentEditableInput.prototype.rememberSelection = function() {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode;
    this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode;
    this.lastFocusOffset = sel.focusOffset;
  };
  ContentEditableInput.prototype.selectionInEditor = function() {
    var sel = this.getSelection();
    if (!sel.rangeCount) {
      return false;
    }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains2(this.div, node);
  };
  ContentEditableInput.prototype.focus = function() {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || activeElt(this.div.ownerDocument) != this.div) {
        this.showSelection(this.prepareSelection(), true);
      }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function() {
    this.div.blur();
  };
  ContentEditableInput.prototype.getField = function() {
    return this.div;
  };
  ContentEditableInput.prototype.supportsTouch = function() {
    return true;
  };
  ContentEditableInput.prototype.receivedFocus = function() {
    var this\$1\$1 = this;
    var input = this;
    if (this.selectionInEditor()) {
      setTimeout(function() {
        return this\$1\$1.pollSelection();
      }, 20);
    } else {
      runInOp(this.cm, function() {
        return input.cm.curOp.selectionChanged = true;
      });
    }
    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };
  ContentEditableInput.prototype.selectionChanged = function() {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
  };
  ContentEditableInput.prototype.pollSelection = function() {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
      return;
    }
    var sel = this.getSelection(), cm = this.cm;
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
      this.blur();
      this.focus();
      return;
    }
    if (this.composing) {
      return;
    }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) {
      runInOp(cm, function() {
        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
        if (anchor.bad || head.bad) {
          cm.curOp.selectionChanged = true;
        }
      });
    }
  };
  ContentEditableInput.prototype.pollContent = function() {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }
    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine()) {
      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
    }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
      to = Pos(to.line + 1, 0);
    }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
      return false;
    }
    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }
    if (!fromNode) {
      return false;
    }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) {
        newText.pop();
        oldText.pop();
        toLine--;
      } else if (newText[0] == oldText[0]) {
        newText.shift();
        oldText.shift();
        fromLine++;
      } else {
        break;
      }
    }
    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
      ++cutFront;
    }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(
      newBot.length - (newText.length == 1 ? cutFront : 0),
      oldBot.length - (oldText.length == 1 ? cutFront : 0)
    );
    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      ++cutEnd;
    }
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }
    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+\$/, "");
    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true;
    }
  };
  ContentEditableInput.prototype.ensurePolled = function() {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function() {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function() {
    if (!this.composing) {
      return;
    }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function() {
    var this\$1\$1 = this;
    if (this.readDOMTimeout != null) {
      return;
    }
    this.readDOMTimeout = setTimeout(function() {
      this\$1\$1.readDOMTimeout = null;
      if (this\$1\$1.composing) {
        if (this\$1\$1.composing.done) {
          this\$1\$1.composing = null;
        } else {
          return;
        }
      }
      this\$1\$1.updateFromDOM();
    }, 80);
  };
  ContentEditableInput.prototype.updateFromDOM = function() {
    var this\$1\$1 = this;
    if (this.cm.isReadOnly() || !this.pollContent()) {
      runInOp(this.cm, function() {
        return regChange(this\$1\$1.cm);
      });
    }
  };
  ContentEditableInput.prototype.setUneditable = function(node) {
    node.contentEditable = "false";
  };
  ContentEditableInput.prototype.onKeyPress = function(e) {
    if (e.charCode == 0 || this.composing) {
      return;
    }
    e.preventDefault();
    if (!this.cm.isReadOnly()) {
      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
    }
  };
  ContentEditableInput.prototype.readOnlyChanged = function(val) {
    this.div.contentEditable = String(val != "nocursor");
  };
  ContentEditableInput.prototype.onContextMenu = function() {
  };
  ContentEditableInput.prototype.resetPosition = function() {
  };
  ContentEditableInput.prototype.needsContentAttribute = true;
  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) {
      return null;
    }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);
    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result;
  }
  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode) {
      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
        return true;
      }
    }
    return false;
  }
  function badPos(pos, bad) {
    if (bad) {
      pos.bad = true;
    }
    return pos;
  }
  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id2) {
      return function(marker) {
        return marker.id == id2;
      };
    }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) {
          text += lineSep;
        }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return;
        }
        var markerID = node.getAttribute("cm-marker"), range2;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range2 = found[0].find(0))) {
            addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
          }
          return;
        }
        if (node.getAttribute("contenteditable") == "false") {
          return;
        }
        var isBlock = /^(pre|div|p|li|table|br)\$/i.test(node.nodeName);
        if (!/^br\$/i.test(node.nodeName) && node.textContent.length == 0) {
          return;
        }
        if (isBlock) {
          close();
        }
        for (var i2 = 0; i2 < node.childNodes.length; i2++) {
          walk(node.childNodes[i2]);
        }
        if (/^(pre|p)\$/i.test(node.nodeName)) {
          extraLinebreak = true;
        }
        if (isBlock) {
          closing = true;
        }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\\u200b/g, "").replace(/\\u00a0/g, " "));
      }
    }
    for (; ; ) {
      walk(from);
      if (from == to) {
        break;
      }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text;
  }
  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) {
        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
      }
      node = null;
      offset = 0;
    } else {
      for (lineNode = node; ; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) {
          return null;
        }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
          break;
        }
      }
    }
    for (var i2 = 0; i2 < cm.display.view.length; i2++) {
      var lineView = cm.display.view[i2];
      if (lineView.node == lineNode) {
        return locateNodeInLineView(lineView, node, offset);
      }
    }
  }
  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains2(wrapper, node)) {
      return badPos(Pos(lineNo(lineView.line), 0), true);
    }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad);
      }
    }
    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) {
        offset = textNode.nodeValue.length;
      }
    }
    while (topNode.parentNode != wrapper) {
      topNode = topNode.parentNode;
    }
    var measure = lineView.measure, maps = measure.maps;
    function find(textNode2, topNode2, offset2) {
      for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
        var map2 = i2 < 0 ? measure.map : maps[i2];
        for (var j = 0; j < map2.length; j += 3) {
          var curNode = map2[j + 2];
          if (curNode == textNode2 || curNode == topNode2) {
            var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
            var ch = map2[j] + offset2;
            if (offset2 < 0 || curNode != textNode2) {
              ch = map2[j + (offset2 ? 1 : 0)];
            }
            return Pos(line2, ch);
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) {
      return badPos(found, bad);
    }
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found) {
        return badPos(Pos(found.line, found.ch - dist), bad);
      } else {
        dist += after.textContent.length;
      }
    }
    for (var before = topNode.previousSibling, dist\$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found) {
        return badPos(Pos(found.line, found.ch + dist\$1), bad);
      } else {
        dist\$1 += before.textContent.length;
      }
    }
  }
  var TextareaInput = function(cm) {
    this.cm = cm;
    this.prevInput = "";
    this.pollingFast = false;
    this.polling = new Delayed();
    this.hasSelection = false;
    this.composing = null;
    this.resetting = false;
  };
  TextareaInput.prototype.init = function(display) {
    var this\$1\$1 = this;
    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;
    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
    if (ios) {
      te.style.width = "0px";
    }
    on(te, "input", function() {
      if (ie && ie_version >= 9 && this\$1\$1.hasSelection) {
        this\$1\$1.hasSelection = null;
      }
      input.poll();
    });
    on(te, "paste", function(e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
        return;
      }
      cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
      input.fastPoll();
    });
    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (cm.somethingSelected()) {
        setLastCopied({ lineWise: false, text: cm.getSelections() });
      } else if (!cm.options.lineWiseCopyCut) {
        return;
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({ lineWise: true, text: ranges.text });
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") {
        cm.state.cutIncoming = +/* @__PURE__ */ new Date();
      }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);
    on(display.scroller, "paste", function(e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
        return;
      }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +/* @__PURE__ */ new Date();
        input.focus();
        return;
      }
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });
    on(display.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(display, e)) {
        e_preventDefault(e);
      }
    });
    on(te, "compositionstart", function() {
      var start = cm.getCursor("from");
      if (input.composing) {
        input.composing.range.clear();
      }
      input.composing = {
        start,
        range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
      };
    });
    on(te, "compositionend", function() {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };
  TextareaInput.prototype.createField = function(_display) {
    this.wrapper = hiddenTextarea();
    this.textarea = this.wrapper.firstChild;
    var opts2 = this.cm.options;
    disableBrowserMagic(this.textarea, opts2.spellcheck, opts2.autocorrect, opts2.autocapitalize);
  };
  TextareaInput.prototype.screenReaderLabelChanged = function(label) {
    if (label) {
      this.textarea.setAttribute("aria-label", label);
    } else {
      this.textarea.removeAttribute("aria-label");
    }
  };
  TextareaInput.prototype.prepareSelection = function() {
    var cm = this.cm, display = cm.display, doc2 = cm.doc;
    var result = prepareSelection(cm);
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc2.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(
        display.wrapper.clientHeight - 10,
        headPos.top + lineOff.top - wrapOff.top
      ));
      result.teLeft = Math.max(0, Math.min(
        display.wrapper.clientWidth - 10,
        headPos.left + lineOff.left - wrapOff.left
      ));
    }
    return result;
  };
  TextareaInput.prototype.showSelection = function(drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };
  TextareaInput.prototype.reset = function(typing) {
    if (this.contextMenuPending || this.composing && typing) {
      return;
    }
    var cm = this.cm;
    this.resetting = true;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) {
        selectInput(this.textarea);
      }
      if (ie && ie_version >= 9) {
        this.hasSelection = content;
      }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) {
        this.hasSelection = null;
      }
    }
    this.resetting = false;
  };
  TextareaInput.prototype.getField = function() {
    return this.textarea;
  };
  TextareaInput.prototype.supportsTouch = function() {
    return false;
  };
  TextareaInput.prototype.focus = function() {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt(this.textarea.ownerDocument) != this.textarea)) {
      try {
        this.textarea.focus();
      } catch (e) {
      }
    }
  };
  TextareaInput.prototype.blur = function() {
    this.textarea.blur();
  };
  TextareaInput.prototype.resetPosition = function() {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };
  TextareaInput.prototype.receivedFocus = function() {
    this.slowPoll();
  };
  TextareaInput.prototype.slowPoll = function() {
    var this\$1\$1 = this;
    if (this.pollingFast) {
      return;
    }
    this.polling.set(this.cm.options.pollInterval, function() {
      this\$1\$1.poll();
      if (this\$1\$1.cm.state.focused) {
        this\$1\$1.slowPoll();
      }
    });
  };
  TextareaInput.prototype.fastPoll = function() {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {
        missed = true;
        input.polling.set(60, p);
      } else {
        input.pollingFast = false;
        input.slowPoll();
      }
    }
    input.polling.set(20, p);
  };
  TextareaInput.prototype.poll = function() {
    var this\$1\$1 = this;
    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
      return false;
    }
    var text = input.value;
    if (text == prevInput && !cm.somethingSelected()) {
      return false;
    }
    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false;
    }
    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 8203 && !prevInput) {
        prevInput = "​";
      }
      if (first == 8666) {
        this.reset();
        return this.cm.execCommand("undo");
      }
    }
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
      ++same;
    }
    runInOp(cm, function() {
      applyTextInput(
        cm,
        text.slice(same),
        prevInput.length - same,
        null,
        this\$1\$1.composing ? "*compose" : null
      );
      if (text.length > 1e3 || text.indexOf("\\n") > -1) {
        input.value = this\$1\$1.prevInput = "";
      } else {
        this\$1\$1.prevInput = text;
      }
      if (this\$1\$1.composing) {
        this\$1\$1.composing.range.clear();
        this\$1\$1.composing.range = cm.markText(
          this\$1\$1.composing.start,
          cm.getCursor("to"),
          { className: "CodeMirror-composing" }
        );
      }
    });
    return true;
  };
  TextareaInput.prototype.ensurePolled = function() {
    if (this.pollingFast && this.poll()) {
      this.pollingFast = false;
    }
  };
  TextareaInput.prototype.onKeyPress = function() {
    if (ie && ie_version >= 9) {
      this.hasSelection = null;
    }
    this.fastPoll();
  };
  TextareaInput.prototype.onContextMenu = function(e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) {
      input.contextMenuPending();
    }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) {
      return;
    }
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1) {
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
    }
    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) {
      oldScrollY = te.ownerDocument.defaultView.scrollY;
    }
    display.input.focus();
    if (webkit) {
      te.ownerDocument.defaultView.scrollTo(null, oldScrollY);
    }
    display.input.reset();
    if (!cm.somethingSelected()) {
      te.value = input.prevInput = " ";
    }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "​" + (selected ? te.value : "");
        te.value = "⇚";
        te.value = extval;
        input.prevInput = selected ? "" : "​";
        te.selectionStart = 1;
        te.selectionEnd = extval.length;
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) {
        return;
      }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) {
        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
      }
      if (te.selectionStart != null) {
        if (!ie || ie && ie_version < 9) {
          prepareSelectAllHack();
        }
        var i2 = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "​") {
            operation(cm, selectAll)(cm);
          } else if (i2++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (ie && ie_version >= 9) {
      prepareSelectAllHack();
    }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };
  TextareaInput.prototype.readOnlyChanged = function(val) {
    if (!val) {
      this.reset();
    }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };
  TextareaInput.prototype.setUneditable = function() {
  };
  TextareaInput.prototype.needsContentAttribute = false;
  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex) {
      options.tabindex = textarea.tabIndex;
    }
    if (!options.placeholder && textarea.placeholder) {
      options.placeholder = textarea.placeholder;
    }
    if (options.autofocus == null) {
      var hasFocus = activeElt(textarea.ownerDocument);
      options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch (e) {
        }
      }
    }
    options.finishInit = function(cm2) {
      cm2.save = save;
      cm2.getTextArea = function() {
        return textarea;
      };
      cm2.toTextArea = function() {
        cm2.toTextArea = isNaN;
        save();
        textarea.parentNode.removeChild(cm2.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
            textarea.form.submit = realSubmit;
          }
        }
      };
    };
    textarea.style.display = "none";
    var cm = CodeMirror2(
      function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      },
      options
    );
    return cm;
  }
  function addLegacyProps(CodeMirror3) {
    CodeMirror3.off = off;
    CodeMirror3.on = on;
    CodeMirror3.wheelEventPixels = wheelEventPixels;
    CodeMirror3.Doc = Doc;
    CodeMirror3.splitLines = splitLinesAuto;
    CodeMirror3.countColumn = countColumn;
    CodeMirror3.findColumn = findColumn;
    CodeMirror3.isWordChar = isWordCharBasic;
    CodeMirror3.Pass = Pass;
    CodeMirror3.signal = signal;
    CodeMirror3.Line = Line;
    CodeMirror3.changeEnd = changeEnd;
    CodeMirror3.scrollbarModel = scrollbarModel;
    CodeMirror3.Pos = Pos;
    CodeMirror3.cmpPos = cmp;
    CodeMirror3.modes = modes;
    CodeMirror3.mimeModes = mimeModes;
    CodeMirror3.resolveMode = resolveMode;
    CodeMirror3.getMode = getMode;
    CodeMirror3.modeExtensions = modeExtensions;
    CodeMirror3.extendMode = extendMode;
    CodeMirror3.copyState = copyState;
    CodeMirror3.startState = startState;
    CodeMirror3.innerMode = innerMode;
    CodeMirror3.commands = commands;
    CodeMirror3.keyMap = keyMap;
    CodeMirror3.keyName = keyName;
    CodeMirror3.isModifierKey = isModifierKey;
    CodeMirror3.lookupKey = lookupKey;
    CodeMirror3.normalizeKeyMap = normalizeKeyMap;
    CodeMirror3.StringStream = StringStream;
    CodeMirror3.SharedTextMarker = SharedTextMarker;
    CodeMirror3.TextMarker = TextMarker;
    CodeMirror3.LineWidget = LineWidget;
    CodeMirror3.e_preventDefault = e_preventDefault;
    CodeMirror3.e_stopPropagation = e_stopPropagation;
    CodeMirror3.e_stop = e_stop;
    CodeMirror3.addClass = addClass;
    CodeMirror3.contains = contains2;
    CodeMirror3.rmClass = rmClass;
    CodeMirror3.keyNames = keyNames;
  }
  defineOptions(CodeMirror2);
  addEditorMethods(CodeMirror2);
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) {
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
      CodeMirror2.prototype[prop] = /* @__PURE__ */ function(method) {
        return function() {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
    }
  }
  eventMixin(Doc);
  CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
  CodeMirror2.defineMode = function(name) {
    if (!CodeMirror2.defaults.mode && name != "null") {
      CodeMirror2.defaults.mode = name;
    }
    defineMode.apply(this, arguments);
  };
  CodeMirror2.defineMIME = defineMIME;
  CodeMirror2.defineMode("null", function() {
    return { token: function(stream) {
      return stream.skipToEnd();
    } };
  });
  CodeMirror2.defineMIME("text/plain", "null");
  CodeMirror2.defineExtension = function(name, func) {
    CodeMirror2.prototype[name] = func;
  };
  CodeMirror2.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror2.fromTextArea = fromTextArea;
  addLegacyProps(CodeMirror2);
  CodeMirror2.version = "5.65.12";
  return CodeMirror2;
});
const AR_CONTEXT_CHARS = {
  "الف": {
    general: { char: "ا", code: "ا" },
    isolated: { char: "ﺍ", code: "ﺍ" },
    end: { char: "ﺎ", code: "ﺎ" }
  },
  "باء": {
    general: { char: "ب", code: "ب" },
    isolated: { char: "ﺏ", code: "ﺏ" },
    end: { char: "ﺐ", code: "ﺐ" },
    middle: { char: "ﺒ", code: "ﺒ" },
    beginning: { char: "ﺑ", code: "ﺑ" }
  },
  "تاء": {
    general: { char: "ت", code: "ت" },
    isolated: { char: "ﺕ", code: "ﺕ" },
    end: { char: "ﺖ", code: "ﺖ" },
    middle: { char: "ﺘ", code: "ﺘ" },
    beginning: { char: "ﺗ", code: "ﺗ" }
  },
  "ثاء": {
    general: { char: "ث", code: "ث" },
    isolated: { char: "ﺙ", code: "ﺙ" },
    end: { char: "ﺚ", code: "ﺚ" },
    middle: { char: "ﺜ", code: "ﺜ" },
    beginning: { char: "ﺛ", code: "ﺛ" }
  },
  "جيم": {
    general: { char: "ج", code: "ج" },
    isolated: { char: "ﺝ", code: "ﺝ" },
    end: { char: "ﺞ", code: "ﺞ" },
    middle: { char: "ﺠ", code: "ﺠ" },
    beginning: { char: "ﺟ", code: "ﺟ" }
  },
  "حاء": {
    general: { char: "ح", code: "ح" },
    isolated: { char: "ﺡ", code: "ﺡ" },
    end: { char: "ﺢ", code: "ﺢ" },
    middle: { char: "ﺤ", code: "ﺤ" },
    beginning: { char: "ﺣ", code: "ﺣ" }
  },
  "خاء": {
    general: { char: "خ", code: "خ" },
    isolated: { char: "ﺥ", code: "ﺥ" },
    end: { char: "ﺦ", code: "ﺦ" },
    middle: { char: "ﺨ", code: "ﺨ" },
    beginning: { char: "ﺧ", code: "ﺧ" }
  },
  "دال": {
    general: { char: "د", code: "د" },
    isolated: { char: "ﺩ", code: "ﺩ" },
    end: { char: "ﺪ", code: "ﺪ" }
  },
  "ذال": {
    general: { char: "ذ", code: "ذ" },
    isolated: { char: "ﺫ", code: "ﺫ" },
    end: { char: "ﺬ", code: "ﺬ" }
  },
  "راء": {
    general: { char: "ر", code: "ر" },
    isolated: { char: "ﺭ", code: "ﺭ" },
    end: { char: "ﺮ", code: "ﺮ" }
  },
  "زين": {
    general: { char: "ز", code: "ز" },
    isolated: { char: "ﺯ", code: "ﺯ" },
    end: { char: "ﺰ", code: "ﺰ" }
  },
  "سين": {
    general: { char: "س", code: "س" },
    isolated: { char: "ﺱ", code: "ﺱ" },
    end: { char: "ﺲ", code: "ﺲ" },
    middle: { char: "ﺴ", code: "ﺴ" },
    beginning: { char: "ﺳ", code: "ﺳ" }
  },
  "شين": {
    general: { char: "ش", code: "ش" },
    isolated: { char: "ﺵ", code: "ﺵ" },
    end: { char: "ﺶ", code: "ﺶ" },
    middle: { char: "ﺸ", code: "ﺸ" },
    beginning: { char: "ﺷ", code: "ﺷ" }
  },
  "صاد": {
    general: { char: "ص", code: "ص" },
    isolated: { char: "ﺹ", code: "ﺹ" },
    end: { char: "ﺺ", code: "ﺺ" },
    middle: { char: "ﺼ", code: "ﺼ" },
    beginning: { char: "ﺻ", code: "ﺻ" }
  },
  "ضاض": {
    general: { char: "ض", code: "ض" },
    isolated: { char: "ﺽ", code: "ﺽ" },
    end: { char: "ﺾ", code: "ﺾ" },
    middle: { char: "ﻀ", code: "ﻀ" },
    beginning: { char: "ﺿ", code: "ﺿ" }
  },
  "طاء": {
    general: { char: "ط", code: "ط" },
    isolated: { char: "ﻁ", code: "ﻁ" },
    end: { char: "ﻂ", code: "ﻂ" },
    middle: { char: "ﻄ", code: "ﻄ" },
    beginning: { char: "ﻃ", code: "ﻃ" }
  },
  "ظاء": {
    general: { char: "ظ", code: "ظ" },
    isolated: { char: "ﻅ", code: "ﻅ" },
    end: { char: "ﻆ", code: "ﻆ" },
    middle: { char: "ﻈ", code: "ﻈ" },
    beginning: { char: "ﻇ", code: "ﻇ" }
  },
  "عين": {
    general: { char: "ع", code: "ع" },
    isolated: { char: "ﻉ", code: "ﻉ" },
    end: { char: "ﻊ", code: "ﻊ" },
    middle: { char: "ﻌ", code: "ﻌ" },
    beginning: { char: "ﻋ", code: "ﻋ" }
  },
  "غين": {
    general: { char: "غ", code: "غ" },
    isolated: { char: "ﻍ", code: "ﻍ" },
    end: { char: "ﻎ", code: "ﻎ" },
    middle: { char: "ﻐ", code: "ﻐ" },
    beginning: { char: "ﻏ", code: "ﻏ" }
  },
  "فاء": {
    general: { char: "ف", code: "ف" },
    isolated: { char: "ﻑ", code: "ﻑ" },
    end: { char: "ﻒ", code: "ﻒ" },
    middle: { char: "ﻔ", code: "ﻔ" },
    beginning: { char: "ﻓ", code: "ﻓ" }
  },
  "قاف": {
    general: { char: "ق", code: "ق" },
    isolated: { char: "ﻕ", code: "ﻕ" },
    end: { char: "ﻖ", code: "ﻖ" },
    middle: { char: "ﻘ", code: "ﻘ" },
    beginning: { char: "ﻗ", code: "ﻗ" }
  },
  "كاف": {
    general: { char: "ك", code: "ك" },
    isolated: { char: "ﻙ", code: "ﻙ" },
    end: { char: "ﻚ", code: "ﻚ" },
    middle: { char: "ﻜ", code: "ﻜ" },
    beginning: { char: "ﻛ", code: "ﻛ" }
  },
  "لام": {
    general: { char: "ل", code: "ل" },
    isolated: { char: "ﻝ", code: "ﻝ" },
    end: { char: "ﻞ", code: "ﻞ" },
    middle: { char: "ﻠ", code: "ﻠ" },
    beginning: { char: "ﻟ", code: "ﻟ" }
  },
  "ميم": {
    general: { char: "م", code: "م" },
    isolated: { char: "ﻡ", code: "ﻡ" },
    end: { char: "ﻢ", code: "ﻢ" },
    middle: { char: "ﻤ", code: "ﻤ" },
    beginning: { char: "ﻣ", code: "ﻣ" }
  },
  "نون": {
    general: { char: "ن", code: "ن" },
    isolated: { char: "ﻥ", code: "ﻥ" },
    end: { char: "ﻦ", code: "ﻦ" },
    middle: { char: "ﻨ", code: "ﻨ" },
    beginning: { char: "ﻧ", code: "ﻧ" }
  },
  "هاء": {
    general: { char: "ه", code: "ه" },
    isolated: { char: "ﻩ", code: "ﻩ" },
    end: { char: "ﻪ", code: "ﻪ" },
    middle: { char: "ﻬ", code: "ﻬ" },
    beginning: { char: "ﻫ", code: "ﻫ" }
  },
  "واو": {
    general: { char: "و", code: "و" },
    isolated: { char: "ﻭ", code: "ﻭ" },
    end: { char: "ﻮ", code: "ﻮ" }
  },
  "ياء": {
    general: { char: "ي", code: "ي" },
    isolated: { char: "ﻱ", code: "ﻱ" },
    end: { char: "ﻲ", code: "ﻲ" },
    middle: { char: "ﻴ", code: "ﻴ" },
    beginning: { char: "ﻳ", code: "ﻳ" }
  },
  "الف_مد": {
    general: { char: "آ", code: "آ" },
    isolated: { char: "ﺁ", code: "ﺁ" },
    end: { char: "ﺂ", code: "ﺂ" }
  },
  "تاء_مربوطة": {
    general: { char: "ة", code: "ة" },
    isolated: { char: "ﺓ", code: "ﺓ" },
    end: { char: "ﺔ", code: "ﺔ" }
  },
  "الف_مقصورة": {
    general: { char: "ى", code: "ى" },
    isolated: { char: "ﻯ", code: "ﻯ" },
    end: { char: "ﻰ", code: "ﻰ" }
  },
  // Arabic Presentation Forms-B
  // https://en.wikipedia.org/wiki/Arabic_Presentation_Forms-B 
  "همزة_ياء": {
    general: { char: "ئ", code: "ئ" },
    isolated: { char: "ﺉ", code: "ﺉ" },
    end: { char: "ﺊ", code: "ﺊ" },
    middle: { char: "ﺌ", code: "ﺌ" },
    beginning: { char: "ﺋ", code: "ﺋ" }
  }
};
const EXTENDABLE_CHARS = (() => {
  let chars = [];
  Object.values(AR_CONTEXT_CHARS).forEach((v2) => {
    if (v2.middle) {
      chars.push(v2.general.code);
      chars.push(v2.middle.code);
      chars.push(v2.beginning.code);
    }
  });
  return chars;
})();
function tatweelRegex(id2) {
  let res = [];
  id2.split("").forEach((c) => {
    if (EXTENDABLE_CHARS.includes(c)) {
      res.push(\`\${c}ـ*\`);
    } else if (c === "ـ") ;
    else {
      res.push(c);
    }
  });
  return res.join("");
}
function toEasternDigits(n) {
  let chars = ("" + n).split("");
  let ar = chars.map((d) => {
    switch (d) {
      case "0":
        return "٠";
      case "1":
        return "١";
      case "2":
        return "٢";
      case "3":
        return "٣";
      case "4":
        return "٤";
      case "5":
        return "٥";
      case "6":
        return "٦";
      case "7":
        return "٧";
      case "8":
        return "٨";
      case "9":
        return "٩";
    }
  });
  return ar.join("");
}
const OPERATORS = [
  "!",
  "?",
  "؟",
  "_",
  "[",
  "(",
  ".",
  "*",
  "×",
  "/",
  "÷",
  "+",
  "-",
  "<",
  "<=",
  "≤",
  ">",
  ">=",
  "≥",
  "==",
  "!=",
  "≠",
  "<<",
  ">>",
  "&",
  "ࢱ",
  "|و|",
  "^",
  "⊕",
  "|",
  "|ء|",
  "&&",
  "ࢱࢱ",
  "|وو|",
  "||",
  "|ءء|",
  ":>",
  "|>",
  "||>",
  "=",
  "+=",
  "-=",
  "*=",
  "×=",
  "/=",
  "÷=",
  "&=",
  "ࢱ=",
  "|=",
  "^=",
  ">>=",
  "<<=",
  ":+",
  "::",
  // separators and other symbols:
  "\$",
  "%",
  "٪",
  "#",
  "⎔",
  "~",
  "]",
  "{",
  "}",
  "\\\\)",
  "'",
  '"',
  "»",
  "«",
  "‹",
  "›"
];
const KEYWORDS = {
  use: { ar: "احضر", en: "use" },
  where: { ar: "حيث", en: "where" },
  when: { ar: "عندما", en: "when" },
  ret: { ar: "اعد", en: "return" },
  _let: { ar: "عرف", en: "let" },
  _const: { ar: "ثابت", en: "const" },
  _var: { ar: "متغير", en: "var" },
  fn: { ar: "دل", en: "fn" },
  struct: { ar: "نوع", en: "type" },
  impl: { ar: "اضافة", en: "impl" },
  trait: { ar: "سمة", en: "trait" },
  // not keywords but for highlighting purposes:
  methods: { ar: "@", en: "@" },
  res: { ar: "𞹍", en: "𞹍" },
  ok: { ar: "✓", en: "✓" },
  err: { ar: "✗", en: "✗" }
};
const ATOMS = {
  float: { ar: "عائم", en: "float" },
  int: { ar: "صحيح", en: "int" },
  str: { ar: "سلسلة", en: "str" },
  bool: { ar: "منطقي", en: "bool" },
  char: { ar: "محرف", en: "char" }
};
const BUILTINS = {
  _true: { ar: "صحيح", en: "true" },
  _false: { ar: "غير_صحيح", en: "false" },
  void: { ar: "لا_شيء", en: "void" }
};
const RESERVED = {
  ...KEYWORDS,
  ...ATOMS,
  ...BUILTINS
};
const idStart = "[\\\\p{L}_]";
const idPart = "[\\\\p{L}\\\\p{N}_]";
const id = \`(?:\${idStart}\${idPart}*)\`;
const notIdPart = "[^\\\\p{L}\\\\p{N}_]";
const easternDigit = "[٠-٩]";
const easternDecimal = \`(?:,\${easternDigit}+)\`;
const easternFloat = \`\${easternDigit}+\${easternDecimal}?\`;
const westernDigit = "[0-9]";
const westernDecimal = \`(?:\\\\.\${westernDigit}+)\`;
const westernFloat = \`\${westernDigit}+\${westernDecimal}?\`;
const backslash = \`\\\\\\\\\`;
const slash = \`\\\\/\`;
const dash = \`\\\\-\`;
const openCurly = \`\\\\{\`;
const closeCurly = \`\\\\}\`;
const openParen = \`\\\\(\`;
const closeParen = \`\\\\)\`;
const space = \`\\\\s\`;
const params = \`\${openParen}?\${space}*\${closeParen}?\`;
const attrRegex = () => RegExp(\`(?:(?:#|#)\${id})\`, "u");
const fnRegex = () => RegExp(\`(?:~\${id}?\${space}*\${params}\${space}*->)\`, "u");
const commonStartRules = [
  { regex: attrRegex(), token: "meta" },
  { regex: fnRegex(), token: ["def", null, "operator", null, "operator", null, "operator", "operator"] },
  { regex: RegExp(\`[\${OPERATORS.join("")}]+\`), token: "operator" },
  { regex: /[\\{\\[\\(]>/, indent: true },
  { regex: /[\\}\\]\\)]/, dedent: true }
];
const meta = {
  dontIndentStates: ["comment"],
  electricInput: /^\\s-\\}\$/,
  fold: "brace"
};
!function() {
  !function() {
    var n = [function(t3, e2, i) {
      var n2 = i(1).Beautifier, u2 = i(5).Options;
      t3.exports = function(t4, e3) {
        return new n2(t4, e3).beautify();
      }, t3.exports.defaultOptions = function() {
        return new u2();
      };
    }, function(t3, e2, i) {
      var n2 = i(2).Output, u2 = i(3).Token, o = i(4), _ = i(5).Options, s = i(7).Tokenizer, r = i(7).line_starters, h = i(7).positionable_operators, p = i(7).TOKEN;
      function l(t4, e3) {
        return -1 !== e3.indexOf(t4);
      }
      function a(t4, e3) {
        return t4 && t4.type === p.RESERVED && t4.text === e3;
      }
      function f(t4, e3) {
        return t4 && t4.type === p.RESERVED && l(t4.text, e3);
      }
      var c = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"], d = function(t4) {
        for (var e3 = {}, i2 = 0; i2 < t4.length; i2++) e3[t4[i2].replace(/-/g, "_")] = t4[i2];
        return e3;
      }(["before-newline", "after-newline", "preserve-newline"]), b = [d.before_newline, d.preserve_newline], g = "BlockStatement", k = "Statement", m = "ObjectLiteral", w = "ArrayLiteral", y = "ForInitializer", x = "Conditional", v2 = "Expression";
      function E(t4, e3) {
        e3.multiline_frame || e3.mode === y || e3.mode === x || t4.remove_indent(e3.start_line_index);
      }
      function R(t4) {
        return t4 === w;
      }
      function O(t4) {
        return l(t4, [v2, y, x]);
      }
      function T(t4, e3) {
        e3 = e3 || {}, this._source_text = t4 || "", this._output = null, this._tokens = null, this._last_last_text = null, this._flags = null, this._previous_flags = null, this._flag_store = null, this._options = new _(e3);
      }
      T.prototype.create_flags = function(t4, e3) {
        var i2 = 0;
        return t4 && (i2 = t4.indentation_level, !this._output.just_added_newline() && t4.line_indent_level > i2 && (i2 = t4.line_indent_level)), { mode: e3, parent: t4, last_token: t4 ? t4.last_token : new u2(p.START_BLOCK, ""), last_word: t4 ? t4.last_word : "", declaration_statement: false, declaration_assignment: false, multiline_frame: false, inline_frame: false, if_block: false, else_block: false, class_start_block: false, do_block: false, do_while: false, import_block: false, in_case_statement: false, in_case: false, case_body: false, case_block: false, indentation_level: i2, alignment: 0, line_indent_level: t4 ? t4.line_indent_level : i2, start_line_index: this._output.get_line_number(), ternary_depth: 0 };
      }, T.prototype._reset = function(t4) {
        var e3 = t4.match(/^[\\t ]*/)[0], e3 = (this._last_last_text = "", this._output = new n2(this._options, e3), this._output.raw = this._options.test_output_raw, this._flag_store = [], this.set_mode(g), new s(t4, this._options));
        return this._tokens = e3.tokenize(), t4;
      }, T.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t4 = this._reset(this._source_text), e3 = this._options.eol, i2 = ("auto" === this._options.eol && (e3 = "\\n", t4 && o.lineBreak.test(t4 || "") && (e3 = t4.match(o.lineBreak)[0])), this._tokens.next()); i2; ) this.handle_token(i2), this._last_last_text = this._flags.last_token.text, this._flags.last_token = i2, i2 = this._tokens.next();
        return this._output.get_code(e3);
      }, T.prototype.handle_token = function(t4, e3) {
        t4.type === p.START_EXPR ? this.handle_start_expr(t4) : t4.type === p.END_EXPR ? this.handle_end_expr(t4) : t4.type === p.START_BLOCK ? this.handle_start_block(t4) : t4.type === p.END_BLOCK ? this.handle_end_block(t4) : t4.type === p.WORD || t4.type === p.RESERVED ? this.handle_word(t4) : t4.type === p.SEMICOLON ? this.handle_semicolon(t4) : t4.type === p.STRING ? this.handle_string(t4) : t4.type === p.EQUALS ? this.handle_equals(t4) : t4.type === p.OPERATOR ? this.handle_operator(t4) : t4.type === p.COMMA ? this.handle_comma(t4) : t4.type === p.BLOCK_COMMENT ? this.handle_block_comment(t4, e3) : t4.type === p.COMMENT ? this.handle_comment(t4, e3) : t4.type === p.DOT ? this.handle_dot(t4) : t4.type === p.EOF ? this.handle_eof(t4) : (t4.type, p.UNKNOWN, this.handle_unknown(t4, e3));
      }, T.prototype.handle_whitespace_and_comments = function(t4, e3) {
        var i2 = t4.newlines, n3 = this._options.keep_array_indentation && R(this._flags.mode);
        if (t4.comments_before) for (var u3 = t4.comments_before.next(); u3; ) this.handle_whitespace_and_comments(u3, e3), this.handle_token(u3, e3), u3 = t4.comments_before.next();
        if (n3) for (var _2 = 0; _2 < i2; _2 += 1) this.print_newline(0 < _2, e3);
        else if (this._options.max_preserve_newlines && i2 > this._options.max_preserve_newlines && (i2 = this._options.max_preserve_newlines), this._options.preserve_newlines && 1 < i2) {
          this.print_newline(false, e3);
          for (var s2 = 1; s2 < i2; s2 += 1) this.print_newline(true, e3);
        }
      };
      var A = ["async", "break", "continue", "return", "throw", "yield"];
      T.prototype.allow_wrap_or_preserved_newline = function(t4, e3) {
        e3 = void 0 !== e3 && e3, this._output.just_added_newline() || (e3 = this._options.preserve_newlines && t4.newlines || e3, (l(this._flags.last_token.text, h) || l(t4.text, h)) && (t4 = l(this._flags.last_token.text, h) && l(this._options.operator_position, b) || l(t4.text, h), e3 = e3 && t4), e3 ? this.print_newline(false, true) : this._options.wrap_line_length && !f(this._flags.last_token, A) && this._output.set_wrap_point());
      }, T.prototype.print_newline = function(t4, e3) {
        if (!e3 && ";" !== this._flags.last_token.text && "," !== this._flags.last_token.text && "=" !== this._flags.last_token.text && (this._flags.last_token.type !== p.OPERATOR || "--" === this._flags.last_token.text || "++" === this._flags.last_token.text)) for (var i2 = this._tokens.peek(); !(this._flags.mode !== k || this._flags.if_block && a(i2, "else") || this._flags.do_block); ) this.restore_mode();
        this._output.add_new_line(t4) && (this._flags.multiline_frame = true);
      }, T.prototype.print_token_line_indentation = function(t4) {
        this._output.just_added_newline() && (this._options.keep_array_indentation && t4.newlines && ("[" === t4.text || R(this._flags.mode)) ? (this._output.current_line.set_indent(-1), this._output.current_line.push(t4.whitespace_before), this._output.space_before_token = false) : this._output.set_indent(this._flags.indentation_level, this._flags.alignment) && (this._flags.line_indent_level = this._flags.indentation_level));
      }, T.prototype.print_token = function(t4) {
        var e3;
        this._output.raw ? this._output.add_raw_token(t4) : (this._options.comma_first && t4.previous && t4.previous.type === p.COMMA && this._output.just_added_newline() && "," === this._output.previous_line.last() && (e3 = this._output.previous_line.pop(), this._output.previous_line.is_empty() && (this._output.previous_line.push(e3), this._output.trim(true), this._output.current_line.pop(), this._output.trim()), this.print_token_line_indentation(t4), this._output.add_token(","), this._output.space_before_token = true), this.print_token_line_indentation(t4), this._output.non_breaking_space = true, this._output.add_token(t4.text), this._output.previous_token_wrapped && (this._flags.multiline_frame = true));
      }, T.prototype.indent = function() {
        this._flags.indentation_level += 1, this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }, T.prototype.deindent = function() {
        0 < this._flags.indentation_level && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level) && (--this._flags.indentation_level, this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
      }, T.prototype.set_mode = function(t4) {
        this._flags ? (this._flag_store.push(this._flags), this._previous_flags = this._flags) : this._previous_flags = this.create_flags(null, t4), this._flags = this.create_flags(this._previous_flags, t4), this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      }, T.prototype.restore_mode = function() {
        0 < this._flag_store.length && (this._previous_flags = this._flags, this._flags = this._flag_store.pop(), this._previous_flags.mode === k && E(this._output, this._previous_flags), this._output.set_indent(this._flags.indentation_level, this._flags.alignment));
      }, T.prototype.start_of_object_property = function() {
        return this._flags.parent.mode === m && this._flags.mode === k && (":" === this._flags.last_token.text && 0 === this._flags.ternary_depth || f(this._flags.last_token, ["get", "set"]));
      }, T.prototype.start_of_statement = function(t4) {
        return !!(f(this._flags.last_token, ["var", "let", "const"]) && t4.type === p.WORD || a(this._flags.last_token, "do") || !(this._flags.parent.mode === m && this._flags.mode === k) && f(this._flags.last_token, A) && !t4.newlines || a(this._flags.last_token, "else") && !(a(t4, "if") && !t4.comments_before) || this._flags.last_token.type === p.END_EXPR && (this._previous_flags.mode === y || this._previous_flags.mode === x) || this._flags.last_token.type === p.WORD && this._flags.mode === g && !this._flags.in_case && !("--" === t4.text || "++" === t4.text) && "function" !== this._last_last_text && t4.type !== p.WORD && t4.type !== p.RESERVED || this._flags.mode === m && (":" === this._flags.last_token.text && 0 === this._flags.ternary_depth || f(this._flags.last_token, ["get", "set"]))) && (this.set_mode(k), this.indent(), this.handle_whitespace_and_comments(t4, true), this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4, f(t4, ["do", "for", "if", "while"])), true);
      }, T.prototype.handle_start_expr = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4);
        var e3, i2, n3 = v2;
        if ("[" === t4.text) {
          if (this._flags.last_token.type === p.WORD || ")" === this._flags.last_token.text) return f(this._flags.last_token, r) && (this._output.space_before_token = true), this.print_token(t4), this.set_mode(n3), this.indent(), void (this._options.space_in_paren && (this._output.space_before_token = true));
          n3 = w, !R(this._flags.mode) || "[" !== this._flags.last_token.text && ("," !== this._flags.last_token.text || "]" !== this._last_last_text && "}" !== this._last_last_text) || this._options.keep_array_indentation || this.print_newline(), l(this._flags.last_token.type, [p.START_EXPR, p.END_EXPR, p.WORD, p.OPERATOR, p.DOT]) || (this._output.space_before_token = true);
        } else this._flags.last_token.type === p.RESERVED ? "for" === this._flags.last_token.text ? (this._output.space_before_token = this._options.space_before_conditional, n3 = y) : l(this._flags.last_token.text, ["if", "while", "switch"]) ? (this._output.space_before_token = this._options.space_before_conditional, n3 = x) : l(this._flags.last_word, ["await", "async"]) ? this._output.space_before_token = true : "import" === this._flags.last_token.text && "" === t4.whitespace_before ? this._output.space_before_token = false : !l(this._flags.last_token.text, r) && "catch" !== this._flags.last_token.text || (this._output.space_before_token = true) : this._flags.last_token.type === p.EQUALS || this._flags.last_token.type === p.OPERATOR ? this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4) : this._flags.last_token.type === p.WORD ? (this._output.space_before_token = false, e3 = this._tokens.peek(-3), this._options.space_after_named_function && e3 && (i2 = this._tokens.peek(-4), f(e3, ["async", "function"]) || "*" === e3.text && f(i2, ["async", "function"]) ? this._output.space_before_token = true : this._flags.mode === m ? "{" !== e3.text && "," !== e3.text && ("*" !== e3.text || "{" !== i2.text && "," !== i2.text) || (this._output.space_before_token = true) : this._flags.parent && this._flags.parent.class_start_block && (this._output.space_before_token = true))) : this.allow_wrap_or_preserved_newline(t4), (this._flags.last_token.type === p.RESERVED && ("function" === this._flags.last_word || "typeof" === this._flags.last_word) || "*" === this._flags.last_token.text && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === m && l(this._last_last_text, ["{", ","]))) && (this._output.space_before_token = this._options.space_after_anon_function);
        ";" === this._flags.last_token.text || this._flags.last_token.type === p.START_BLOCK ? this.print_newline() : this._flags.last_token.type !== p.END_EXPR && this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.END_BLOCK && "." !== this._flags.last_token.text && this._flags.last_token.type !== p.COMMA || this.allow_wrap_or_preserved_newline(t4, t4.newlines), this.print_token(t4), this.set_mode(n3), this._options.space_in_paren && (this._output.space_before_token = true), this.indent();
      }, T.prototype.handle_end_expr = function(t4) {
        for (; this._flags.mode === k; ) this.restore_mode();
        this.handle_whitespace_and_comments(t4), this._flags.multiline_frame && this.allow_wrap_or_preserved_newline(t4, "]" === t4.text && R(this._flags.mode) && !this._options.keep_array_indentation), this._options.space_in_paren && (this._flags.last_token.type !== p.START_EXPR || this._options.space_in_empty_paren ? this._output.space_before_token = true : (this._output.trim(), this._output.space_before_token = false)), this.deindent(), this.print_token(t4), this.restore_mode(), E(this._output, this._previous_flags), this._flags.do_while && this._previous_flags.mode === x && (this._previous_flags.mode = v2, this._flags.do_block = false, this._flags.do_while = false);
      }, T.prototype.handle_start_block = function(t4) {
        this.handle_whitespace_and_comments(t4);
        var e3 = this._tokens.peek(), i2 = this._tokens.peek(1), i2 = ("switch" === this._flags.last_word && this._flags.last_token.type === p.END_EXPR ? (this.set_mode(g), this._flags.in_case_statement = true) : this._flags.case_body ? this.set_mode(g) : i2 && (l(i2.text, [":", ","]) && l(e3.type, [p.STRING, p.WORD, p.RESERVED]) || l(e3.text, ["get", "set", "..."]) && l(i2.type, [p.WORD, p.RESERVED])) ? l(this._last_last_text, ["class", "interface"]) && !l(i2.text, [":", ","]) ? this.set_mode(g) : this.set_mode(m) : (this._flags.last_token.type !== p.OPERATOR || "=>" !== this._flags.last_token.text) && (l(this._flags.last_token.type, [p.EQUALS, p.START_EXPR, p.COMMA, p.OPERATOR]) || f(this._flags.last_token, ["return", "throw", "import", "default"])) ? this.set_mode(m) : this.set_mode(g), this._flags.last_token && f(this._flags.last_token.previous, ["class", "extends"]) && (this._flags.class_start_block = true), !e3.comments_before && "}" === e3.text), e3 = i2 && "function" === this._flags.last_word && this._flags.last_token.type === p.END_EXPR;
        if (this._options.brace_preserve_inline) {
          var n3 = 0, u3 = null;
          this._flags.inline_frame = true;
          do {
            if ((u3 = this._tokens.peek((n3 += 1) - 1)).newlines) {
              this._flags.inline_frame = false;
              break;
            }
          } while (u3.type !== p.EOF && (u3.type !== p.END_BLOCK || u3.opened !== t4));
        }
        ("expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines) && !this._flags.inline_frame ? this._flags.last_token.type !== p.OPERATOR && (e3 || this._flags.last_token.type === p.EQUALS || f(this._flags.last_token, c) && "else" !== this._flags.last_token.text) ? this._output.space_before_token = true : this.print_newline(false, true) : (!R(this._previous_flags.mode) || this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.COMMA || (this._flags.last_token.type !== p.COMMA && !this._options.space_in_paren || (this._output.space_before_token = true), (this._flags.last_token.type === p.COMMA || this._flags.last_token.type === p.START_EXPR && this._flags.inline_frame) && (this.allow_wrap_or_preserved_newline(t4), this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame, this._flags.multiline_frame = false)), this._flags.last_token.type !== p.OPERATOR && this._flags.last_token.type !== p.START_EXPR && (l(this._flags.last_token.type, [p.START_BLOCK, p.SEMICOLON]) && !this._flags.inline_frame ? this.print_newline() : this._output.space_before_token = true)), this.print_token(t4), this.indent(), i2 || this._options.brace_preserve_inline && this._flags.inline_frame || this.print_newline();
      }, T.prototype.handle_end_block = function(t4) {
        for (this.handle_whitespace_and_comments(t4); this._flags.mode === k; ) this.restore_mode();
        var e3 = this._flags.last_token.type === p.START_BLOCK;
        this._flags.inline_frame && !e3 ? this._output.space_before_token = true : "expand" === this._options.brace_style ? e3 || this.print_newline() : e3 || (R(this._flags.mode) && this._options.keep_array_indentation ? (this._options.keep_array_indentation = false, this.print_newline(), this._options.keep_array_indentation = true) : this.print_newline()), this.restore_mode(), this.print_token(t4);
      }, T.prototype.handle_word = function(t4) {
        if (t4.type === p.RESERVED && (l(t4.text, ["set", "get"]) && this._flags.mode !== m || "import" === t4.text && l(this._tokens.peek().text, ["(", "."]) || l(t4.text, ["as", "from"]) && !this._flags.import_block || this._flags.mode === m && ":" === this._tokens.peek().text) && (t4.type = p.WORD), this.start_of_statement(t4) ? f(this._flags.last_token, ["var", "let", "const"]) && t4.type === p.WORD && (this._flags.declaration_statement = true) : !t4.newlines || O(this._flags.mode) || this._flags.last_token.type === p.OPERATOR && "--" !== this._flags.last_token.text && "++" !== this._flags.last_token.text || this._flags.last_token.type === p.EQUALS || !this._options.preserve_newlines && f(this._flags.last_token, ["var", "let", "const", "set", "get"]) ? this.handle_whitespace_and_comments(t4) : (this.handle_whitespace_and_comments(t4), this.print_newline()), this._flags.do_block && !this._flags.do_while) {
          if (a(t4, "while")) return this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true, void (this._flags.do_while = true);
          this.print_newline(), this._flags.do_block = false;
        }
        if (this._flags.if_block) if (!this._flags.else_block && a(t4, "else")) this._flags.else_block = true;
        else {
          for (; this._flags.mode === k; ) this.restore_mode();
          this._flags.if_block = false, this._flags.else_block = false;
        }
        if (this._flags.in_case_statement && f(t4, ["case", "default"])) return this.print_newline(), this._flags.case_block || !this._flags.case_body && !this._options.jslint_happy || this.deindent(), this._flags.case_body = false, this.print_token(t4), void (this._flags.in_case = true);
        if (this._flags.last_token.type !== p.COMMA && this._flags.last_token.type !== p.START_EXPR && this._flags.last_token.type !== p.EQUALS && this._flags.last_token.type !== p.OPERATOR || this.start_of_object_property() || l(this._flags.last_token.text, ["+", "-"]) && ":" === this._last_last_text && this._flags.parent.mode === m || this.allow_wrap_or_preserved_newline(t4), a(t4, "function")) return !(l(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !l(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) && this._flags.last_token.type !== p.OPERATOR) || this._output.just_added_blankline() || t4.comments_before || (this.print_newline(), this.print_newline(true)), this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD ? f(this._flags.last_token, ["get", "set", "new", "export"]) || f(this._flags.last_token, A) || a(this._flags.last_token, "default") && "export" === this._last_last_text || "declare" === this._flags.last_token.text ? this._output.space_before_token = true : this.print_newline() : this._flags.last_token.type === p.OPERATOR || "=" === this._flags.last_token.text ? this._output.space_before_token = true : !this._flags.multiline_frame && (O(this._flags.mode) || R(this._flags.mode)) || this.print_newline(), this.print_token(t4), void (this._flags.last_word = t4.text);
        var e3 = "NONE";
        this._flags.last_token.type === p.END_BLOCK ? this._previous_flags.inline_frame ? e3 = "SPACE" : !f(t4, ["else", "catch", "finally", "from"]) || "expand" === this._options.brace_style || "end-expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines ? e3 = "NEWLINE" : (e3 = "SPACE", this._output.space_before_token = true) : this._flags.last_token.type === p.SEMICOLON && this._flags.mode === g ? e3 = "NEWLINE" : this._flags.last_token.type === p.SEMICOLON && O(this._flags.mode) ? e3 = "SPACE" : this._flags.last_token.type === p.STRING ? e3 = "NEWLINE" : this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD || "*" === this._flags.last_token.text && (l(this._last_last_text, ["function", "yield"]) || this._flags.mode === m && l(this._last_last_text, ["{", ","])) ? e3 = "SPACE" : this._flags.last_token.type === p.START_BLOCK ? e3 = this._flags.inline_frame ? "SPACE" : "NEWLINE" : this._flags.last_token.type === p.END_EXPR && (this._output.space_before_token = true, e3 = "NEWLINE"), f(t4, r) && ")" !== this._flags.last_token.text && (e3 = this._flags.inline_frame || "else" === this._flags.last_token.text || "export" === this._flags.last_token.text ? "SPACE" : "NEWLINE"), f(t4, ["else", "catch", "finally"]) ? (this._flags.last_token.type !== p.END_BLOCK || this._previous_flags.mode !== g || "expand" === this._options.brace_style || "end-expand" === this._options.brace_style || "none" === this._options.brace_style && t4.newlines) && !this._flags.inline_frame ? this.print_newline() : (this._output.trim(true), "}" !== this._output.current_line.last() && this.print_newline(), this._output.space_before_token = true) : "NEWLINE" === e3 ? f(this._flags.last_token, c) || "declare" === this._flags.last_token.text && f(t4, ["var", "let", "const"]) ? this._output.space_before_token = true : this._flags.last_token.type !== p.END_EXPR ? this._flags.last_token.type === p.START_EXPR && f(t4, ["var", "let", "const"]) || ":" === this._flags.last_token.text || (a(t4, "if") && a(t4.previous, "else") ? this._output.space_before_token = true : this.print_newline()) : f(t4, r) && ")" !== this._flags.last_token.text && this.print_newline() : this._flags.multiline_frame && R(this._flags.mode) && "," === this._flags.last_token.text && "}" === this._last_last_text ? this.print_newline() : "SPACE" === e3 && (this._output.space_before_token = true), !t4.previous || t4.previous.type !== p.WORD && t4.previous.type !== p.RESERVED || (this._output.space_before_token = true), this.print_token(t4), this._flags.last_word = t4.text, t4.type === p.RESERVED && ("do" === t4.text ? this._flags.do_block = true : "if" === t4.text ? this._flags.if_block = true : "import" === t4.text ? this._flags.import_block = true : this._flags.import_block && a(t4, "from") && (this._flags.import_block = false));
      }, T.prototype.handle_semicolon = function(t4) {
        this.start_of_statement(t4) ? this._output.space_before_token = false : this.handle_whitespace_and_comments(t4);
        for (var e3 = this._tokens.peek(); !(this._flags.mode !== k || this._flags.if_block && a(e3, "else") || this._flags.do_block); ) this.restore_mode();
        this._flags.import_block && (this._flags.import_block = false), this.print_token(t4);
      }, T.prototype.handle_string = function(t4) {
        t4.text.startsWith("\`") && 0 === t4.newlines && "" === t4.whitespace_before && (")" === t4.previous.text || this._flags.last_token.type === p.WORD) || (this.start_of_statement(t4) ? this._output.space_before_token = true : (this.handle_whitespace_and_comments(t4), this._flags.last_token.type === p.RESERVED || this._flags.last_token.type === p.WORD || this._flags.inline_frame ? this._output.space_before_token = true : this._flags.last_token.type === p.COMMA || this._flags.last_token.type === p.START_EXPR || this._flags.last_token.type === p.EQUALS || this._flags.last_token.type === p.OPERATOR ? this.start_of_object_property() || this.allow_wrap_or_preserved_newline(t4) : !t4.text.startsWith("\`") || this._flags.last_token.type !== p.END_EXPR || "]" !== t4.previous.text && ")" !== t4.previous.text || 0 !== t4.newlines ? this.print_newline() : this._output.space_before_token = true)), this.print_token(t4);
      }, T.prototype.handle_equals = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4), this._flags.declaration_statement && (this._flags.declaration_assignment = true), this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true;
      }, T.prototype.handle_comma = function(t4) {
        this.handle_whitespace_and_comments(t4, true), this.print_token(t4), this._output.space_before_token = true, this._flags.declaration_statement ? (O(this._flags.parent.mode) && (this._flags.declaration_assignment = false), this._flags.declaration_assignment ? (this._flags.declaration_assignment = false, this.print_newline(false, true)) : this._options.comma_first && this.allow_wrap_or_preserved_newline(t4)) : this._flags.mode === m || this._flags.mode === k && this._flags.parent.mode === m ? (this._flags.mode === k && this.restore_mode(), this._flags.inline_frame || this.print_newline()) : this._options.comma_first && this.allow_wrap_or_preserved_newline(t4);
      }, T.prototype.handle_operator = function(t4) {
        var e3 = "*" === t4.text && (f(this._flags.last_token, ["function", "yield"]) || l(this._flags.last_token.type, [p.START_BLOCK, p.COMMA, p.END_BLOCK, p.SEMICOLON])), i2 = l(t4.text, ["-", "+"]) && (l(this._flags.last_token.type, [p.START_BLOCK, p.START_EXPR, p.EQUALS, p.OPERATOR]) || l(this._flags.last_token.text, r) || "," === this._flags.last_token.text);
        if (this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4, !e3), "*" === t4.text && this._flags.last_token.type === p.DOT) this.print_token(t4);
        else if ("::" === t4.text) this.print_token(t4);
        else if (l(t4.text, ["-", "+"]) && this.start_of_object_property()) this.print_token(t4);
        else {
          if (this._flags.last_token.type === p.OPERATOR && l(this._options.operator_position, b) && this.allow_wrap_or_preserved_newline(t4), ":" === t4.text && this._flags.in_case) return this.print_token(t4), this._flags.in_case = false, this._flags.case_body = true, void (this._tokens.peek().type !== p.START_BLOCK ? (this.indent(), this.print_newline(), this._flags.case_block = false) : (this._flags.case_block = true, this._output.space_before_token = true));
          var n3 = true, u3 = true, _2 = false;
          if (":" === t4.text ? 0 === this._flags.ternary_depth ? n3 = false : (--this._flags.ternary_depth, _2 = true) : "?" === t4.text && (this._flags.ternary_depth += 1), !i2 && !e3 && this._options.preserve_newlines && l(t4.text, h)) {
            var s2 = ":" === t4.text, a2 = s2 && _2, o2 = s2 && !_2;
            switch (this._options.operator_position) {
              case d.before_newline:
                return this._output.space_before_token = !o2, this.print_token(t4), s2 && !a2 || this.allow_wrap_or_preserved_newline(t4), void (this._output.space_before_token = true);
              case d.after_newline:
                return this._output.space_before_token = true, !s2 || a2 ? this._tokens.peek().newlines ? this.print_newline(false, true) : this.allow_wrap_or_preserved_newline(t4) : this._output.space_before_token = false, this.print_token(t4), void (this._output.space_before_token = true);
              case d.preserve_newline:
                return o2 || this.allow_wrap_or_preserved_newline(t4), n3 = !(this._output.just_added_newline() || o2), this._output.space_before_token = n3, this.print_token(t4), void (this._output.space_before_token = true);
            }
          }
          e3 ? (this.allow_wrap_or_preserved_newline(t4), n3 = false, u3 = (_2 = this._tokens.peek()) && l(_2.type, [p.WORD, p.RESERVED])) : "..." === t4.text ? (this.allow_wrap_or_preserved_newline(t4), n3 = this._flags.last_token.type === p.START_BLOCK, u3 = false) : (l(t4.text, ["--", "++", "!", "~"]) || i2) && (this._flags.last_token.type !== p.COMMA && this._flags.last_token.type !== p.START_EXPR || this.allow_wrap_or_preserved_newline(t4), u3 = n3 = false, !t4.newlines || "--" !== t4.text && "++" !== t4.text && "~" !== t4.text || ((e3 = f(this._flags.last_token, c) && t4.newlines) && (this._previous_flags.if_block || this._previous_flags.else_block) && this.restore_mode(), this.print_newline(e3, true)), ";" === this._flags.last_token.text && O(this._flags.mode) && (n3 = true), this._flags.last_token.type === p.RESERVED ? n3 = true : this._flags.last_token.type === p.END_EXPR ? n3 = !("]" === this._flags.last_token.text && ("--" === t4.text || "++" === t4.text)) : this._flags.last_token.type === p.OPERATOR && (n3 = l(t4.text, ["--", "-", "++", "+"]) && l(this._flags.last_token.text, ["--", "-", "++", "+"]), l(t4.text, ["+", "-"]) && l(this._flags.last_token.text, ["--", "++"]) && (u3 = true)), (this._flags.mode !== g || this._flags.inline_frame) && this._flags.mode !== k || "{" !== this._flags.last_token.text && ";" !== this._flags.last_token.text || this.print_newline()), this._output.space_before_token = this._output.space_before_token || n3, this.print_token(t4), this._output.space_before_token = u3;
        }
      }, T.prototype.handle_block_comment = function(t4, e3) {
        return this._output.raw ? (this._output.add_raw_token(t4), void (t4.directives && "end" === t4.directives.preserve && (this._output.raw = this._options.test_output_raw))) : t4.directives ? (this.print_newline(false, e3), this.print_token(t4), "start" === t4.directives.preserve && (this._output.raw = true), void this.print_newline(false, true)) : void (o.newline.test(t4.text) || t4.newlines ? this.print_block_commment(t4, e3) : (this._output.space_before_token = true, this.print_token(t4), this._output.space_before_token = true));
      }, T.prototype.print_block_commment = function(t4, e3) {
        var i2, n3, u3, _2 = function(t5) {
          for (var e4 = [], i3 = (t5 = t5.replace(o.allLineBreaks, "\\n")).indexOf("\\n"); -1 !== i3; ) e4.push(t5.substring(0, i3)), i3 = (t5 = t5.substring(i3 + 1)).indexOf("\\n");
          return t5.length && e4.push(t5), e4;
        }(t4.text), s2 = t4.whitespace_before, a2 = s2.length;
        if (this.print_newline(false, e3), this.print_token_line_indentation(t4), this._output.add_token(_2[0]), this.print_newline(false, e3), 1 < _2.length) {
          for (n3 = function(t5, e4) {
            for (var i3 = 0; i3 < t5.length; i3++) if (t5[i3].trim().charAt(0) !== e4) return false;
            return true;
          }(_2 = _2.slice(1), "*"), u3 = function(t5, e4) {
            for (var i3, n4 = 0, u4 = t5.length; n4 < u4; n4++) if ((i3 = t5[n4]) && 0 !== i3.indexOf(e4)) return false;
            return true;
          }(_2, s2), n3 && (this._flags.alignment = 1), i2 = 0; i2 < _2.length; i2++) n3 ? (this.print_token_line_indentation(t4), this._output.add_token(_2[i2].replace(/^\\s+/g, ""))) : u3 && _2[i2] ? (this.print_token_line_indentation(t4), this._output.add_token(_2[i2].substring(a2))) : (this._output.current_line.set_indent(-1), this._output.add_token(_2[i2])), this.print_newline(false, e3);
          this._flags.alignment = 0;
        }
      }, T.prototype.handle_comment = function(t4, e3) {
        t4.newlines ? this.print_newline(false, e3) : this._output.trim(true), this._output.space_before_token = true, this.print_token(t4), this.print_newline(false, e3);
      }, T.prototype.handle_dot = function(t4) {
        this.start_of_statement(t4) || this.handle_whitespace_and_comments(t4, true), this._flags.last_token.text.match("^[0-9]+\$") && (this._output.space_before_token = true), f(this._flags.last_token, c) ? this._output.space_before_token = false : this.allow_wrap_or_preserved_newline(t4, ")" === this._flags.last_token.text && this._options.break_chained_methods), this._options.unindent_chained_methods && this._output.just_added_newline() && this.deindent(), this.print_token(t4);
      }, T.prototype.handle_unknown = function(t4, e3) {
        this.print_token(t4), "\\n" === t4.text[t4.text.length - 1] && this.print_newline(false, e3);
      }, T.prototype.handle_eof = function(t4) {
        for (; this._flags.mode === k; ) this.restore_mode();
        this.handle_whitespace_and_comments(t4);
      }, t3.exports.Beautifier = T;
    }, function(t3) {
      function u2(t4) {
        this.__parent = t4, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function i(t4, e3) {
        this.__cache = [""], this.__indent_size = t4.indent_size, this.__indent_string = t4.indent_char, t4.indent_with_tabs || (this.__indent_string = new Array(t4.indent_size + 1).join(t4.indent_char)), e3 = e3 || "", 0 < t4.indent_level && (e3 = new Array(t4.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t4, e3) {
        this.__indent_cache = new i(t4, e3), this.raw = false, this._end_with_newline = t4.end_with_newline, this.indent_size = t4.indent_size, this.wrap_line_length = t4.wrap_line_length, this.indent_empty_lines = t4.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new u2(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      u2.prototype.clone_empty = function() {
        var t4 = new u2(this.__parent);
        return t4.set_indent(this.__indent_count, this.__alignment_count), t4;
      }, u2.prototype.item = function(t4) {
        return t4 < 0 ? this.__items[this.__items.length + t4] : this.__items[t4];
      }, u2.prototype.has_match = function(t4) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t4)) return true;
        return false;
      }, u2.prototype.set_indent = function(t4, e3) {
        this.is_empty() && (this.__indent_count = t4 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, u2.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, u2.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, u2.prototype._allow_wrap = function() {
        var t4;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t4 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t4.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t4.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t4.__items[0] && (t4.__items.splice(0, 1), --t4.__character_count), true);
      }, u2.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, u2.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, u2.prototype.push = function(t4) {
        this.__items.push(t4);
        var e3 = t4.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t4.length - e3 : this.__character_count += t4.length;
      }, u2.prototype.pop = function() {
        var t4 = null;
        return this.is_empty() || (t4 = this.__items.pop(), this.__character_count -= t4.length), t4;
      }, u2.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, u2.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, u2.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, u2.prototype.toString = function() {
        var t4 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t4 = this.__parent.get_indent_string(this.__indent_count)) : (t4 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t4 += this.__items.join("")), t4;
      }, i.prototype.get_indent_size = function(t4, e3) {
        var i2 = this.__base_string_length;
        return i2 = (i2 = t4 < 0 ? 0 : i2) + t4 * this.__indent_size + (e3 = e3 || 0);
      }, i.prototype.get_indent_string = function(t4, e3) {
        var i2 = this.__base_string;
        return e3 = e3 || 0, t4 < 0 && (t4 = 0, i2 = ""), e3 += t4 * this.__indent_size, this.__ensure_cache(e3), i2 += this.__cache[e3];
      }, i.prototype.__ensure_cache = function(t4) {
        for (; t4 >= this.__cache.length; ) this.__add_column();
      }, i.prototype.__add_column = function() {
        var t4, e3 = this.__cache.length, i2 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t4 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, i2 = new Array(t4 + 1).join(this.__indent_string)), e3 && (i2 += new Array(e3 + 1).join(" ")), this.__cache.push(i2);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t4, e3) {
        return this.__indent_cache.get_indent_string(t4, e3);
      }, e2.prototype.get_indent_size = function(t4, e3) {
        return this.__indent_cache.get_indent_size(t4, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t4) {
        return !(this.is_empty() || !t4 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t4) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t4 ? e3.replace(/[\\n]/g, t4) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t4, e3) {
        return this.next_line.set_indent(t4 = t4 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t4, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t4) {
        for (var e3 = 0; e3 < t4.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t4.whitespace_before), this.current_line.push(t4.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t4) {
        this.__add_space_before_token(), this.current_line.push(t4), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t4) {
        for (var e3 = this.__lines.length; t4 < e3; ) this.__lines[t4]._remove_indent(), t4++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t4) {
        for (t4 = void 0 !== t4 && t4, this.current_line.trim(); t4 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t4, e3) {
        for (var i2 = this.__lines.length - 2; 0 <= i2; ) {
          var n2 = this.__lines[i2];
          if (n2.is_empty()) break;
          if (0 !== n2.item(0).indexOf(t4) && n2.item(-1) !== e3) {
            this.__lines.splice(i2 + 1, 0, new u2(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          i2--;
        }
      }, t3.exports.Output = e2;
    }, function(t3) {
      t3.exports.Token = function(t4, e2, i, n2) {
        this.type = t4, this.text = e2, this.comments_before = null, this.newlines = i || 0, this.whitespace_before = n2 || "", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this.directives = null;
      };
    }, function(t3, e2) {
      var i = "\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a", n2 = "\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc", u2 = "\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f", _ = "\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}", s = "(?:" + _ + "|[\\\\x23\\\\x24\\\\x40\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a" + n2 + "])";
      e2.identifier = new RegExp(s + "(?:\\\\\\\\u[0-9a-fA-F]{4}|\\\\\\\\u\\\\{[0-9a-fA-F]+\\\\}|[\\\\x24\\\\x30-\\\\x39\\\\x41-\\\\x5a\\\\x5f\\\\x61-\\\\x7a\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u0527\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05d0-\\\\u05ea\\\\u05f0-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u08a0\\\\u08a2-\\\\u08ac\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0977\\\\u0979-\\\\u097f\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c33\\\\u0c35-\\\\u0c39\\\\u0c3d\\\\u0c58\\\\u0c59\\\\u0c60\\\\u0c61\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d60\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e87\\\\u0e88\\\\u0e8a\\\\u0e8d\\\\u0e94-\\\\u0e97\\\\u0e99-\\\\u0e9f\\\\u0ea1-\\\\u0ea3\\\\u0ea5\\\\u0ea7\\\\u0eaa\\\\u0eab\\\\u0ead-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f4\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f0\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1877\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191c\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19c1-\\\\u19c7\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf1\\\\u1cf5\\\\u1cf6\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2119-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u212d\\\\u212f-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u2e2f\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309d-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312d\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua697\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua78e\\\\ua790-\\\\ua793\\\\ua7a0-\\\\ua7aa\\\\ua7f8-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa80-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uabc0-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\\\\u0300-\\\\u036f\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u0620-\\\\u0649\\\\u0672-\\\\u06d3\\\\u06e7-\\\\u06e8\\\\u06fb-\\\\u06fc\\\\u0730-\\\\u074a\\\\u0800-\\\\u0814\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0840-\\\\u0857\\\\u08e4-\\\\u08fe\\\\u0900-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962-\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09d7\\\\u09df-\\\\u09e0\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2-\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b5f-\\\\u0b60\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c01-\\\\u0c03\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62-\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c82\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2-\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d02\\\\u0d03\\\\u0d46-\\\\u0d48\\\\u0d57\\\\u0d62-\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0df2\\\\u0df3\\\\u0e34-\\\\u0e3a\\\\u0e40-\\\\u0e45\\\\u0e50-\\\\u0e59\\\\u0eb4-\\\\u0eb9\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f41-\\\\u0f47\\\\u0f71-\\\\u0f84\\\\u0f86-\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u1000-\\\\u1029\\\\u1040-\\\\u1049\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u170e-\\\\u1710\\\\u1720-\\\\u1730\\\\u1740-\\\\u1750\\\\u1772\\\\u1773\\\\u1780-\\\\u17b2\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1951-\\\\u196d\\\\u19b0-\\\\u19c0\\\\u19c8-\\\\u19c9\\\\u19d0-\\\\u19d9\\\\u1a00-\\\\u1a15\\\\u1a20-\\\\u1a53\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1b46-\\\\u1b4b\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c00-\\\\u1c22\\\\u1c40-\\\\u1c49\\\\u1c5b-\\\\u1c7d\\\\u1cd0-\\\\u1cd2\\\\u1d00-\\\\u1dbe\\\\u1e01-\\\\u1f15\\\\u200c\\\\u200d\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2d81-\\\\u2d96\\\\u2de0-\\\\u2dff\\\\u3021-\\\\u3028\\\\u3099\\\\u309a\\\\ua640-\\\\ua66d\\\\ua674-\\\\ua67d\\\\ua69f\\\\ua6f0-\\\\ua6f1\\\\ua7f8-\\\\ua800\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880-\\\\ua881\\\\ua8b4-\\\\ua8c4\\\\ua8d0-\\\\ua8d9\\\\ua8f3-\\\\ua8f7\\\\ua900-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua930-\\\\ua945\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\uaa00-\\\\uaa27\\\\uaa40-\\\\uaa41\\\\uaa4c-\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b\\\\uaae0-\\\\uaae9\\\\uaaf2-\\\\uaaf3\\\\uabc0-\\\\uabe1\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb20-\\\\ufb28\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f])*", "g"), e2.identifierStart = new RegExp(s), e2.identifierMatch = new RegExp("(?:" + _ + "|[" + i + n2 + u2 + "])+");
      e2.newline = /[\\n\\r\\u2028\\u2029]/, e2.lineBreak = new RegExp("\\r\\n|" + e2.newline.source), e2.allLineBreaks = new RegExp(e2.lineBreak.source, "g");
    }, function(t3, e2, i) {
      var n2 = i(6).Options, u2 = ["before-newline", "after-newline", "preserve-newline"];
      function _(t4) {
        n2.call(this, t4, "js");
        var t4 = this.raw_options.brace_style || null, e3 = ("expand-strict" === t4 ? this.raw_options.brace_style = "expand" : "collapse-preserve-inline" === t4 ? this.raw_options.brace_style = "collapse,preserve-inline" : void 0 !== this.raw_options.braces_on_own_line && (this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse"), this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]));
        this.brace_preserve_inline = false, this.brace_style = "collapse";
        for (var i2 = 0; i2 < e3.length; i2++) "preserve-inline" === e3[i2] ? this.brace_preserve_inline = true : this.brace_style = e3[i2];
        this.unindent_chained_methods = this._get_boolean("unindent_chained_methods"), this.break_chained_methods = this._get_boolean("break_chained_methods"), this.space_in_paren = this._get_boolean("space_in_paren"), this.space_in_empty_paren = this._get_boolean("space_in_empty_paren"), this.jslint_happy = this._get_boolean("jslint_happy"), this.space_after_anon_function = this._get_boolean("space_after_anon_function"), this.space_after_named_function = this._get_boolean("space_after_named_function"), this.keep_array_indentation = this._get_boolean("keep_array_indentation"), this.space_before_conditional = this._get_boolean("space_before_conditional", true), this.unescape_strings = this._get_boolean("unescape_strings"), this.e4x = this._get_boolean("e4x"), this.comma_first = this._get_boolean("comma_first"), this.operator_position = this._get_selection("operator_position", u2), this.test_output_raw = this._get_boolean("test_output_raw"), this.jslint_happy && (this.space_after_anon_function = true);
      }
      _.prototype = new n2(), t3.exports.Options = _;
    }, function(t3) {
      function e2(t4, e3) {
        this.raw_options = i(t4, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function i(t4, e3) {
        var i2, n2 = {};
        for (i2 in t4 = u2(t4)) i2 !== e3 && (n2[i2] = t4[i2]);
        if (e3 && t4[e3]) for (i2 in t4[e3]) n2[i2] = t4[e3][i2];
        return n2;
      }
      function u2(t4) {
        var e3, i2 = {};
        for (e3 in t4) i2[e3.replace(/-/g, "_")] = t4[e3];
        return i2;
      }
      e2.prototype._get_array = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || [];
        return "object" == typeof t4 ? null !== t4 && "function" == typeof t4.concat && (e3 = t4.concat()) : "string" == typeof t4 && (e3 = t4.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t4, e3) {
        t4 = this.raw_options[t4];
        return void 0 === t4 ? !!e3 : !!t4;
      }, e2.prototype._get_characters = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || "";
        return e3 = "string" == typeof t4 ? t4.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t4 = parseInt(t4, 10);
        return t4 = isNaN(t4) ? e3 : t4;
      }, e2.prototype._get_selection = function(t4, e3, i2) {
        i2 = this._get_selection_list(t4, e3, i2);
        if (1 !== i2.length) throw new Error("Invalid Option Value: The option '" + t4 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
        return i2[0];
      }, e2.prototype._get_selection_list = function(t4, e3, i2) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (i2 = i2 || [e3[0]], !this._is_valid_selection(i2, e3)) throw new Error("Invalid Default Value!");
        i2 = this._get_array(t4, i2);
        if (this._is_valid_selection(i2, e3)) return i2;
        throw new Error("Invalid Option Value: The option '" + t4 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
      }, e2.prototype._is_valid_selection = function(t4, e3) {
        return t4.length && e3.length && !t4.some(function(t5) {
          return -1 === e3.indexOf(t5);
        });
      }, t3.exports.Options = e2, t3.exports.normalizeOpts = u2, t3.exports.mergeOpts = i;
    }, function(t3, e2, i) {
      var _ = i(8).InputScanner, n2 = i(9).Tokenizer, u2 = i(9).TOKEN, s = i(13).Directives, r = i(4), a = i(12).Pattern, o = i(14).TemplatablePattern;
      function h(t4, e3) {
        return -1 !== e3.indexOf(t4);
      }
      function p(t4, e3) {
        n2.call(this, t4, e3), this._patterns.whitespace = this._patterns.whitespace.matching(/\\u00A0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff/.source, /\\u2028\\u2029/.source), t4 = new a(this._input), e3 = new o(this._input).read_options(this._options), this.__patterns = { template: e3, identifier: e3.starting_with(r.identifier).matching(r.identifierMatch), number: t4.matching(d), punct: t4.matching(k), comment: t4.starting_with(/\\/\\//).until(/[\\n\\r\\u2028\\u2029]/), block_comment: t4.starting_with(/\\/\\*/).until_after(/\\*\\//), html_comment_start: t4.matching(/<!--/), html_comment_end: t4.matching(/-->/), include: t4.starting_with(/#include/).until_after(r.lineBreak), shebang: t4.starting_with(/#!/).until_after(r.lineBreak), xml: t4.matching(/[\\s\\S]*?<(\\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\\[CDATA\\[[^\\]]*?\\]\\]|)(\\s*{[^}]+?}|\\s+[-a-zA-Z:0-9_.]+|\\s+[-a-zA-Z:0-9_.]+\\s*=\\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\\s*(\\/?)\\s*>/), single_quote: e3.until(/['\\\\\\n\\r\\u2028\\u2029]/), double_quote: e3.until(/["\\\\\\n\\r\\u2028\\u2029]/), template_text: e3.until(/[\`\\\\\$]/), template_expression: e3.until(/[\`}\\\\]/) };
      }
      var l, f = { START_EXPR: "TK_START_EXPR", END_EXPR: "TK_END_EXPR", START_BLOCK: "TK_START_BLOCK", END_BLOCK: "TK_END_BLOCK", WORD: "TK_WORD", RESERVED: "TK_RESERVED", SEMICOLON: "TK_SEMICOLON", STRING: "TK_STRING", EQUALS: "TK_EQUALS", OPERATOR: "TK_OPERATOR", COMMA: "TK_COMMA", BLOCK_COMMENT: "TK_BLOCK_COMMENT", COMMENT: "TK_COMMENT", DOT: "TK_DOT", UNKNOWN: "TK_UNKNOWN", START: u2.START, RAW: u2.RAW, EOF: u2.EOF }, c = new s(/\\/\\*/, /\\*\\//), d = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\\d[\\d_]*n|(?:\\.\\d[\\d_]*|\\d[\\d_]*\\.?[\\d_]*)(?:[eE][+-]?[\\d_]+)?/, b = /[0-9]/, g = /[^\\d\\.]/, i = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" "), u2 = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |", k = (u2 = (u2 = "\\\\?\\\\.(?!\\\\d) " + (u2 = u2.replace(/[-[\\]{}()*+?.,\\\\^\$|#]/g, "\\\\\$&"))).replace(/ /g, "|"), new RegExp(u2)), s = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(","), u2 = s.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]), m = new RegExp("^(?:" + u2.join("|") + ")\$");
      (p.prototype = new n2())._is_comment = function(t4) {
        return t4.type === f.COMMENT || t4.type === f.BLOCK_COMMENT || t4.type === f.UNKNOWN;
      }, p.prototype._is_opening = function(t4) {
        return t4.type === f.START_BLOCK || t4.type === f.START_EXPR;
      }, p.prototype._is_closing = function(t4, e3) {
        return (t4.type === f.END_BLOCK || t4.type === f.END_EXPR) && e3 && ("]" === t4.text && "[" === e3.text || ")" === t4.text && "(" === e3.text || "}" === t4.text && "{" === e3.text);
      }, p.prototype._reset = function() {
        l = false;
      }, p.prototype._get_next_token = function(t4, e3) {
        this._readWhitespace();
        var i2 = this._input.peek();
        return null === i2 ? this._create_token(f.EOF, "") : this._read_non_javascript(i2) || this._read_string(i2) || this._read_pair(i2, this._input.peek(1)) || this._read_word(t4) || this._read_singles(i2) || this._read_comment(i2) || this._read_regexp(i2, t4) || this._read_xml(i2, t4) || this._read_punctuation() || this._create_token(f.UNKNOWN, this._input.next());
      }, p.prototype._read_word = function(t4) {
        var e3 = this.__patterns.identifier.read();
        return "" !== e3 ? (e3 = e3.replace(r.allLineBreaks, "\\n"), t4.type !== f.DOT && (t4.type !== f.RESERVED || "set" !== t4.text && "get" !== t4.text) && m.test(e3) ? "in" !== e3 && "of" !== e3 || t4.type !== f.WORD && t4.type !== f.STRING ? this._create_token(f.RESERVED, e3) : this._create_token(f.OPERATOR, e3) : this._create_token(f.WORD, e3)) : "" !== (e3 = this.__patterns.number.read()) ? this._create_token(f.WORD, e3) : void 0;
      }, p.prototype._read_singles = function(t4) {
        var e3 = null;
        return "(" === t4 || "[" === t4 ? e3 = this._create_token(f.START_EXPR, t4) : ")" === t4 || "]" === t4 ? e3 = this._create_token(f.END_EXPR, t4) : "{" === t4 ? e3 = this._create_token(f.START_BLOCK, t4) : "}" === t4 ? e3 = this._create_token(f.END_BLOCK, t4) : ";" === t4 ? e3 = this._create_token(f.SEMICOLON, t4) : "." === t4 && g.test(this._input.peek(1)) ? e3 = this._create_token(f.DOT, t4) : "," === t4 && (e3 = this._create_token(f.COMMA, t4)), e3 && this._input.next(), e3;
      }, p.prototype._read_pair = function(t4, e3) {
        var i2 = null;
        return (i2 = "#" === t4 && "{" === e3 ? this._create_token(f.START_BLOCK, t4 + e3) : i2) && (this._input.next(), this._input.next()), i2;
      }, p.prototype._read_punctuation = function() {
        var t4 = this.__patterns.punct.read();
        if ("" !== t4) return "=" === t4 ? this._create_token(f.EQUALS, t4) : "?." === t4 ? this._create_token(f.DOT, t4) : this._create_token(f.OPERATOR, t4);
      }, p.prototype._read_non_javascript = function(t4) {
        var e3 = "";
        if ("#" === t4) {
          if (this._is_first_token() && (e3 = this.__patterns.shebang.read())) return this._create_token(f.UNKNOWN, e3.trim() + "\\n");
          if (e3 = this.__patterns.include.read()) return this._create_token(f.UNKNOWN, e3.trim() + "\\n");
          t4 = this._input.next();
          var i2 = "#";
          if (this._input.hasNext() && this._input.testChar(b)) {
            for (; i2 += t4 = this._input.next(), this._input.hasNext() && "#" !== t4 && "=" !== t4; ) ;
            return "#" !== t4 && ("[" === this._input.peek() && "]" === this._input.peek(1) ? (i2 += "[]", this._input.next(), this._input.next()) : "{" === this._input.peek() && "}" === this._input.peek(1) && (i2 += "{}", this._input.next(), this._input.next())), this._create_token(f.WORD, i2);
          }
          this._input.back();
        } else if ("<" === t4 && this._is_first_token()) {
          if (e3 = this.__patterns.html_comment_start.read()) {
            for (; this._input.hasNext() && !this._input.testChar(r.newline); ) e3 += this._input.next();
            return l = true, this._create_token(f.COMMENT, e3);
          }
        } else if (l && "-" === t4 && (e3 = this.__patterns.html_comment_end.read())) return l = false, this._create_token(f.COMMENT, e3);
        return null;
      }, p.prototype._read_comment = function(t4) {
        var e3, i2 = null;
        return "/" === t4 && (t4 = "", "*" === this._input.peek(1) ? (t4 = this.__patterns.block_comment.read(), (e3 = c.get_directives(t4)) && "start" === e3.ignore && (t4 += c.readIgnored(this._input)), t4 = t4.replace(r.allLineBreaks, "\\n"), (i2 = this._create_token(f.BLOCK_COMMENT, t4)).directives = e3) : "/" === this._input.peek(1) && (t4 = this.__patterns.comment.read(), i2 = this._create_token(f.COMMENT, t4))), i2;
      }, p.prototype._read_string = function(t4) {
        var e3;
        return "\`" === t4 || "'" === t4 || '"' === t4 ? (e3 = this._input.next(), this.has_char_escapes = false, e3 += "\`" === t4 ? this._read_string_recursive("\`", true, "\${") : this._read_string_recursive(t4), this.has_char_escapes && this._options.unescape_strings && (e3 = function(t5) {
          var e4 = "", i2 = 0, n3 = new _(t5), u3 = null;
          for (; n3.hasNext(); ) if ((u3 = n3.match(/([\\s]|[^\\\\]|\\\\\\\\)+/g)) && (e4 += u3[0]), "\\\\" === n3.peek()) {
            if (n3.next(), "x" === n3.peek()) u3 = n3.match(/x([0-9A-Fa-f]{2})/g);
            else {
              if ("u" !== n3.peek()) {
                e4 += "\\\\", n3.hasNext() && (e4 += n3.next());
                continue;
              }
              u3 = (u3 = n3.match(/u([0-9A-Fa-f]{4})/g)) || n3.match(/u\\{([0-9A-Fa-f]+)\\}/g);
            }
            if (!u3) return t5;
            if (126 < (i2 = parseInt(u3[1], 16)) && i2 <= 255 && 0 === u3[0].indexOf("x")) return t5;
            e4 += 0 <= i2 && i2 < 32 || 1114111 < i2 ? "\\\\" + u3[0] : 34 === i2 || 39 === i2 || 92 === i2 ? "\\\\" + String.fromCharCode(i2) : String.fromCharCode(i2);
          }
          return e4;
        }(e3)), this._input.peek() === t4 && (e3 += this._input.next()), e3 = e3.replace(r.allLineBreaks, "\\n"), this._create_token(f.STRING, e3)) : null;
      }, p.prototype._allow_regexp_or_xml = function(t4) {
        return t4.type === f.RESERVED && h(t4.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || t4.type === f.END_EXPR && ")" === t4.text && t4.opened.previous.type === f.RESERVED && h(t4.opened.previous.text, ["if", "while", "for"]) || h(t4.type, [f.COMMENT, f.START_EXPR, f.START_BLOCK, f.START, f.END_BLOCK, f.OPERATOR, f.EQUALS, f.EOF, f.SEMICOLON, f.COMMA]);
      }, p.prototype._read_regexp = function(t4, e3) {
        if ("/" === t4 && this._allow_regexp_or_xml(e3)) {
          for (var i2 = this._input.next(), n3 = false, u3 = false; this._input.hasNext() && (n3 || u3 || this._input.peek() !== t4) && !this._input.testChar(r.newline); ) i2 += this._input.peek(), n3 ? n3 = false : (n3 = "\\\\" === this._input.peek(), "[" === this._input.peek() ? u3 = true : "]" === this._input.peek() && (u3 = false)), this._input.next();
          return this._input.peek() === t4 && (i2 = (i2 += this._input.next()) + this._input.read(r.identifier)), this._create_token(f.STRING, i2);
        }
        return null;
      }, p.prototype._read_xml = function(t4, e3) {
        if (this._options.e4x && "<" === t4 && this._allow_regexp_or_xml(e3)) {
          var i2 = "", n3 = this.__patterns.xml.read_match();
          if (n3) {
            for (var u3 = n3[2].replace(/^{\\s+/, "{").replace(/\\s+}\$/, "}"), _2 = 0 === u3.indexOf("{"), s2 = 0; n3; ) {
              var a2 = !!n3[1], o2 = n3[2];
              if (!(!!n3[n3.length - 1] || "![CDATA[" === o2.slice(0, 8)) && (o2 === u3 || _2 && o2.replace(/^{\\s+/, "{").replace(/\\s+}\$/, "}")) && (a2 ? --s2 : ++s2), i2 += n3[0], s2 <= 0) break;
              n3 = this.__patterns.xml.read_match();
            }
            return n3 || (i2 += this._input.match(/[\\s\\S]*/g)[0]), i2 = i2.replace(r.allLineBreaks, "\\n"), this._create_token(f.STRING, i2);
          }
        }
        return null;
      }, p.prototype._read_string_recursive = function(t4, e3, i2) {
        "'" === t4 ? u3 = this.__patterns.single_quote : '"' === t4 ? u3 = this.__patterns.double_quote : "\`" === t4 ? u3 = this.__patterns.template_text : "}" === t4 && (u3 = this.__patterns.template_expression);
        for (var n3, u3, _2 = u3.read(), s2 = ""; this._input.hasNext(); ) {
          if ((s2 = this._input.next()) === t4 || !e3 && r.newline.test(s2)) {
            this._input.back();
            break;
          }
          "\\\\" === s2 && this._input.hasNext() ? ("x" === (n3 = this._input.peek()) || "u" === n3 ? this.has_char_escapes = true : "\\r" === n3 && "\\n" === this._input.peek(1) && this._input.next(), s2 += this._input.next()) : i2 && ("\${" === i2 && "\$" === s2 && "{" === this._input.peek() && (s2 += this._input.next()), i2 === s2 && (s2 += "\`" === t4 ? this._read_string_recursive("}", e3, "\`") : this._read_string_recursive("\`", e3, "\${"), this._input.hasNext() && (s2 += this._input.next()))), _2 += s2 += u3.read();
        }
        return _2;
      }, t3.exports.Tokenizer = p, t3.exports.TOKEN = f, t3.exports.positionable_operators = i.slice(), t3.exports.line_starters = s.slice();
    }, function(t3) {
      var n2 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t4) {
        this.__input = t4 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__input.charAt(this.__position), this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__input_length ? this.__input.charAt(t4) : e3;
      }, e2.prototype.__match = function(t4, e3) {
        t4.lastIndex = e3;
        var i = t4.exec(this.__input);
        return !i || n2 && t4.sticky || i.index !== e3 && (i = null), i;
      }, e2.prototype.test = function(t4, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t4, e3);
      }, e2.prototype.testChar = function(t4, e3) {
        e3 = this.peek(e3);
        return t4.lastIndex = 0, null !== e3 && t4.test(e3);
      }, e2.prototype.match = function(t4) {
        t4 = this.__match(t4, this.__position);
        return t4 ? this.__position += t4[0].length : t4 = null, t4;
      }, e2.prototype.read = function(t4, e3, i) {
        var n3, u2 = "";
        return t4 && (n3 = this.match(t4)) && (u2 += n3[0]), !e3 || !n3 && t4 || (u2 += this.readUntil(e3, i)), u2;
      }, e2.prototype.readUntil = function(t4, e3) {
        var i = this.__position, t4 = (t4.lastIndex = this.__position, t4.exec(this.__input));
        return t4 ? (i = t4.index, e3 && (i += t4[0].length)) : i = this.__input_length, e3 = this.__input.substring(this.__position, i), this.__position = i, e3;
      }, e2.prototype.readUntilAfter = function(t4) {
        return this.readUntil(t4, true);
      }, e2.prototype.get_regexp = function(t4, e3) {
        var i = null, e3 = e3 && n2 ? "y" : "g";
        return "string" == typeof t4 && "" !== t4 ? i = new RegExp(t4, e3) : t4 && (i = new RegExp(t4.source, e3)), i;
      }, e2.prototype.get_literal_regexp = function(t4) {
        return RegExp(t4.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t4) {
        var e3 = this.__position, t4 = this.readUntilAfter(t4);
        return this.__position = e3, t4;
      }, e2.prototype.lookBack = function(t4) {
        var e3 = this.__position - 1;
        return e3 >= t4.length && this.__input.substring(e3 - t4.length, e3).toLowerCase() === t4;
      }, t3.exports.InputScanner = e2;
    }, function(t3, e2, i) {
      function n2(t4, e3) {
        this._input = new u2(t4), this._options = e3 || {}, this.__tokens = null, this._patterns = {}, this._patterns.whitespace = new a(this._input);
      }
      var u2 = i(8).InputScanner, _ = i(3).Token, s = i(10).TokenStream, a = i(11).WhitespacePattern, o = { START: "TK_START", RAW: "TK_RAW", EOF: "TK_EOF" };
      n2.prototype.tokenize = function() {
        this._input.restart(), this.__tokens = new s(), this._reset();
        for (var t4, e3 = new _(o.START, ""), i2 = null, n3 = [], u3 = new s(); e3.type !== o.EOF; ) {
          for (t4 = this._get_next_token(e3, i2); this._is_comment(t4); ) u3.add(t4), t4 = this._get_next_token(e3, i2);
          u3.isEmpty() || (t4.comments_before = u3, u3 = new s()), t4.parent = i2, this._is_opening(t4) ? (n3.push(i2), i2 = t4) : i2 && this._is_closing(t4, i2) && ((t4.opened = i2).closed = t4, i2 = n3.pop(), t4.parent = i2), (t4.previous = e3).next = t4, this.__tokens.add(t4), e3 = t4;
        }
        return this.__tokens;
      }, n2.prototype._is_first_token = function() {
        return this.__tokens.isEmpty();
      }, n2.prototype._reset = function() {
      }, n2.prototype._get_next_token = function(t4, e3) {
        this._readWhitespace();
        var i2 = this._input.read(/.+/g);
        return i2 ? this._create_token(o.RAW, i2) : this._create_token(o.EOF, "");
      }, n2.prototype._is_comment = function(t4) {
        return false;
      }, n2.prototype._is_opening = function(t4) {
        return false;
      }, n2.prototype._is_closing = function(t4, e3) {
        return false;
      }, n2.prototype._create_token = function(t4, e3) {
        return new _(t4, e3, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
      }, n2.prototype._readWhitespace = function() {
        return this._patterns.whitespace.read();
      }, t3.exports.Tokenizer = n2, t3.exports.TOKEN = o;
    }, function(t3) {
      function e2(t4) {
        this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = t4;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.isEmpty = function() {
        return 0 === this.__tokens_length;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__tokens_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__tokens[this.__position], this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__tokens_length ? this.__tokens[t4] : e3;
      }, e2.prototype.add = function(t4) {
        this.__parent_token && (t4.parent = this.__parent_token), this.__tokens.push(t4), this.__tokens_length += 1;
      }, t3.exports.TokenStream = e2;
    }, function(t3, e2, i) {
      var n2 = i(12).Pattern;
      function u2(t4, e3) {
        n2.call(this, t4, e3), e3 ? this._line_regexp = this._input.get_regexp(e3._line_regexp) : this.__set_whitespace_patterns("", ""), this.newline_count = 0, this.whitespace_before_token = "";
      }
      (u2.prototype = new n2()).__set_whitespace_patterns = function(t4, e3) {
        this._match_pattern = this._input.get_regexp("[" + (t4 += "\\\\t ") + (e3 += "\\\\n\\\\r") + "]+", true), this._newline_regexp = this._input.get_regexp("\\\\r\\\\n|[" + e3 + "]");
      }, u2.prototype.read = function() {
        this.newline_count = 0, this.whitespace_before_token = "";
        var t4, e3 = this._input.read(this._match_pattern);
        return " " === e3 ? this.whitespace_before_token = " " : e3 && (t4 = this.__split(this._newline_regexp, e3), this.newline_count = t4.length - 1, this.whitespace_before_token = t4[this.newline_count]), e3;
      }, u2.prototype.matching = function(t4, e3) {
        var i2 = this._create();
        return i2.__set_whitespace_patterns(t4, e3), i2._update(), i2;
      }, u2.prototype._create = function() {
        return new u2(this._input, this);
      }, u2.prototype.__split = function(t4, e3) {
        for (var i2 = t4.lastIndex = 0, n3 = [], u3 = t4.exec(e3); u3; ) n3.push(e3.substring(i2, u3.index)), i2 = u3.index + u3[0].length, u3 = t4.exec(e3);
        return i2 < e3.length ? n3.push(e3.substring(i2, e3.length)) : n3.push(""), n3;
      }, t3.exports.WhitespacePattern = u2;
    }, function(t3) {
      function e2(t4, e3) {
        this._input = t4, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this._until_after = false, e3 && (this._starting_pattern = this._input.get_regexp(e3._starting_pattern, true), this._match_pattern = this._input.get_regexp(e3._match_pattern, true), this._until_pattern = this._input.get_regexp(e3._until_pattern), this._until_after = e3._until_after);
      }
      e2.prototype.read = function() {
        var t4 = this._input.read(this._starting_pattern);
        return this._starting_pattern && !t4 || (t4 += this._input.read(this._match_pattern, this._until_pattern, this._until_after)), t4;
      }, e2.prototype.read_match = function() {
        return this._input.match(this._match_pattern);
      }, e2.prototype.until_after = function(t4) {
        var e3 = this._create();
        return e3._until_after = true, e3._until_pattern = this._input.get_regexp(t4), e3._update(), e3;
      }, e2.prototype.until = function(t4) {
        var e3 = this._create();
        return e3._until_after = false, e3._until_pattern = this._input.get_regexp(t4), e3._update(), e3;
      }, e2.prototype.starting_with = function(t4) {
        var e3 = this._create();
        return e3._starting_pattern = this._input.get_regexp(t4, true), e3._update(), e3;
      }, e2.prototype.matching = function(t4) {
        var e3 = this._create();
        return e3._match_pattern = this._input.get_regexp(t4, true), e3._update(), e3;
      }, e2.prototype._create = function() {
        return new e2(this._input, this);
      }, e2.prototype._update = function() {
      }, t3.exports.Pattern = e2;
    }, function(t3) {
      function e2(t4, e3) {
        t4 = "string" == typeof t4 ? t4 : t4.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t4 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t4 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t4) {
        if (!t4.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, i = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t4)); i; ) e3[i[1]] = i[2], i = this.__directive_pattern.exec(t4);
        return e3;
      }, e2.prototype.readIgnored = function(t4) {
        return t4.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t3.exports.Directives = e2;
    }, function(t3, e2, i) {
      var n2 = i(12).Pattern, u2 = { django: false, erb: false, handlebars: false, php: false, smarty: false };
      function _(t4, e3) {
        n2.call(this, t4, e3), this.__template_pattern = null, this._disabled = Object.assign({}, u2), this._excluded = Object.assign({}, u2), e3 && (this.__template_pattern = this._input.get_regexp(e3.__template_pattern), this._excluded = Object.assign(this._excluded, e3._excluded), this._disabled = Object.assign(this._disabled, e3._disabled));
        e3 = new n2(t4);
        this.__patterns = { handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars_unescaped: e3.starting_with(/{{{/).until_after(/}}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), php: e3.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/), erb: e3.starting_with(/<%[^%]/).until_after(/[^%]%>/), django: e3.starting_with(/{%/).until_after(/%}/), django_value: e3.starting_with(/{{/).until_after(/}}/), django_comment: e3.starting_with(/{#/).until_after(/#}/), smarty: e3.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/), smarty_comment: e3.starting_with(/{\\*/).until_after(/\\*}/), smarty_literal: e3.starting_with(/{literal}/).until_after(/{\\/literal}/) };
      }
      (_.prototype = new n2())._create = function() {
        return new _(this._input, this);
      }, _.prototype._update = function() {
        this.__set_templated_pattern();
      }, _.prototype.disable = function(t4) {
        var e3 = this._create();
        return e3._disabled[t4] = true, e3._update(), e3;
      }, _.prototype.read_options = function(t4) {
        var e3, i2 = this._create();
        for (e3 in u2) i2._disabled[e3] = -1 === t4.templating.indexOf(e3);
        return i2._update(), i2;
      }, _.prototype.exclude = function(t4) {
        var e3 = this._create();
        return e3._excluded[t4] = true, e3._update(), e3;
      }, _.prototype.read = function() {
        for (var t4 = "", t4 = this._match_pattern ? this._input.read(this._starting_pattern) : this._input.read(this._starting_pattern, this.__template_pattern), e3 = this._read_template(); e3; ) this._match_pattern ? e3 += this._input.read(this._match_pattern) : e3 += this._input.readUntil(this.__template_pattern), t4 += e3, e3 = this._read_template();
        return this._until_after && (t4 += this._input.readUntilAfter(this._until_pattern)), t4;
      }, _.prototype.__set_templated_pattern = function() {
        var t4 = [];
        this._disabled.php || t4.push(this.__patterns.php._starting_pattern.source), this._disabled.handlebars || t4.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.erb || t4.push(this.__patterns.erb._starting_pattern.source), this._disabled.django || (t4.push(this.__patterns.django._starting_pattern.source), t4.push(this.__patterns.django_value._starting_pattern.source), t4.push(this.__patterns.django_comment._starting_pattern.source)), this._disabled.smarty || t4.push(this.__patterns.smarty._starting_pattern.source), this._until_pattern && t4.push(this._until_pattern.source), this.__template_pattern = this._input.get_regexp("(?:" + t4.join("|") + ")");
      }, _.prototype._read_template = function() {
        var t4, e3 = "", i2 = this._input.peek();
        return "<" === i2 ? (t4 = this._input.peek(1), this._disabled.php || this._excluded.php || "?" !== t4 || (e3 = e3 || this.__patterns.php.read()), this._disabled.erb || this._excluded.erb || "%" !== t4 || (e3 = e3 || this.__patterns.erb.read())) : "{" === i2 && (this._disabled.handlebars || this._excluded.handlebars || (e3 = (e3 = (e3 = e3 || this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars_unescaped.read()) || this.__patterns.handlebars.read()), this._disabled.django || (this._excluded.django || this._excluded.handlebars || (e3 = e3 || this.__patterns.django_value.read()), this._excluded.django || (e3 = (e3 = e3 || this.__patterns.django_comment.read()) || this.__patterns.django.read())), this._disabled.smarty || this._disabled.django && this._disabled.handlebars && (e3 = (e3 = (e3 = e3 || this.__patterns.smarty_comment.read()) || this.__patterns.smarty_literal.read()) || this.__patterns.smarty.read())), e3;
      }, t3.exports.TemplatablePattern = _;
    }], u = {};
    var t2 = function t3(e2) {
      var i = u[e2];
      if (void 0 !== i) return i.exports;
      i = u[e2] = { exports: {} };
      return n[e2](i, i.exports, t3), i.exports;
    }(0);
    e = t2;
  }();
  var e, t = e;
  "function" == typeof define && define.amd ? define([], function() {
    return { js_beautify: t };
  }) : "undefined" != typeof exports ? exports.js_beautify = t : "undefined" != typeof window ? window.js_beautify = t : "undefined" != typeof global && (global.js_beautify = t);
}();
!function() {
  !function() {
    var i2 = [, , function(t2) {
      function _3(t3) {
        this.__parent = t3, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function n2(t3, e3) {
        this.__cache = [""], this.__indent_size = t3.indent_size, this.__indent_string = t3.indent_char, t3.indent_with_tabs || (this.__indent_string = new Array(t3.indent_size + 1).join(t3.indent_char)), e3 = e3 || "", 0 < t3.indent_level && (e3 = new Array(t3.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t3, e3) {
        this.__indent_cache = new n2(t3, e3), this.raw = false, this._end_with_newline = t3.end_with_newline, this.indent_size = t3.indent_size, this.wrap_line_length = t3.wrap_line_length, this.indent_empty_lines = t3.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new _3(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      _3.prototype.clone_empty = function() {
        var t3 = new _3(this.__parent);
        return t3.set_indent(this.__indent_count, this.__alignment_count), t3;
      }, _3.prototype.item = function(t3) {
        return t3 < 0 ? this.__items[this.__items.length + t3] : this.__items[t3];
      }, _3.prototype.has_match = function(t3) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t3)) return true;
        return false;
      }, _3.prototype.set_indent = function(t3, e3) {
        this.is_empty() && (this.__indent_count = t3 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, _3.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, _3.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, _3.prototype._allow_wrap = function() {
        var t3;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t3 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t3.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t3.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t3.__items[0] && (t3.__items.splice(0, 1), --t3.__character_count), true);
      }, _3.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, _3.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, _3.prototype.push = function(t3) {
        this.__items.push(t3);
        var e3 = t3.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t3.length - e3 : this.__character_count += t3.length;
      }, _3.prototype.pop = function() {
        var t3 = null;
        return this.is_empty() || (t3 = this.__items.pop(), this.__character_count -= t3.length), t3;
      }, _3.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, _3.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, _3.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, _3.prototype.toString = function() {
        var t3 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t3 = this.__parent.get_indent_string(this.__indent_count)) : (t3 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t3 += this.__items.join("")), t3;
      }, n2.prototype.get_indent_size = function(t3, e3) {
        var n3 = this.__base_string_length;
        return n3 = (n3 = t3 < 0 ? 0 : n3) + t3 * this.__indent_size + (e3 = e3 || 0);
      }, n2.prototype.get_indent_string = function(t3, e3) {
        var n3 = this.__base_string;
        return e3 = e3 || 0, t3 < 0 && (t3 = 0, n3 = ""), e3 += t3 * this.__indent_size, this.__ensure_cache(e3), n3 += this.__cache[e3];
      }, n2.prototype.__ensure_cache = function(t3) {
        for (; t3 >= this.__cache.length; ) this.__add_column();
      }, n2.prototype.__add_column = function() {
        var t3, e3 = this.__cache.length, n3 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t3 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, n3 = new Array(t3 + 1).join(this.__indent_string)), e3 && (n3 += new Array(e3 + 1).join(" ")), this.__cache.push(n3);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t3, e3) {
        return this.__indent_cache.get_indent_string(t3, e3);
      }, e2.prototype.get_indent_size = function(t3, e3) {
        return this.__indent_cache.get_indent_size(t3, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t3) {
        return !(this.is_empty() || !t3 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t3) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t3 ? e3.replace(/[\\n]/g, t3) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t3, e3) {
        return this.next_line.set_indent(t3 = t3 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t3, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t3) {
        for (var e3 = 0; e3 < t3.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t3.whitespace_before), this.current_line.push(t3.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t3) {
        this.__add_space_before_token(), this.current_line.push(t3), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t3) {
        for (var e3 = this.__lines.length; t3 < e3; ) this.__lines[t3]._remove_indent(), t3++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t3) {
        for (t3 = void 0 !== t3 && t3, this.current_line.trim(); t3 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t3, e3) {
        for (var n3 = this.__lines.length - 2; 0 <= n3; ) {
          var i3 = this.__lines[n3];
          if (i3.is_empty()) break;
          if (0 !== i3.item(0).indexOf(t3) && i3.item(-1) !== e3) {
            this.__lines.splice(n3 + 1, 0, new _3(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          n3--;
        }
      }, t2.exports.Output = e2;
    }, function(t2) {
      t2.exports.Token = function(t3, e2, n2, i3) {
        this.type = t3, this.text = e2, this.comments_before = null, this.newlines = n2 || 0, this.whitespace_before = i3 || "", this.parent = null, this.next = null, this.previous = null, this.opened = null, this.closed = null, this.directives = null;
      };
    }, , , function(t2) {
      function e2(t3, e3) {
        this.raw_options = n2(t3, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function n2(t3, e3) {
        var n3, i3 = {};
        for (n3 in t3 = _3(t3)) n3 !== e3 && (i3[n3] = t3[n3]);
        if (e3 && t3[e3]) for (n3 in t3[e3]) i3[n3] = t3[e3][n3];
        return i3;
      }
      function _3(t3) {
        var e3, n3 = {};
        for (e3 in t3) n3[e3.replace(/-/g, "_")] = t3[e3];
        return n3;
      }
      e2.prototype._get_array = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = e3 || [];
        return "object" == typeof t3 ? null !== t3 && "function" == typeof t3.concat && (e3 = t3.concat()) : "string" == typeof t3 && (e3 = t3.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t3, e3) {
        t3 = this.raw_options[t3];
        return void 0 === t3 ? !!e3 : !!t3;
      }, e2.prototype._get_characters = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = e3 || "";
        return e3 = "string" == typeof t3 ? t3.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t3, e3) {
        t3 = this.raw_options[t3], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t3 = parseInt(t3, 10);
        return t3 = isNaN(t3) ? e3 : t3;
      }, e2.prototype._get_selection = function(t3, e3, n3) {
        n3 = this._get_selection_list(t3, e3, n3);
        if (1 !== n3.length) throw new Error("Invalid Option Value: The option '" + t3 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t3] + "'");
        return n3[0];
      }, e2.prototype._get_selection_list = function(t3, e3, n3) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (n3 = n3 || [e3[0]], !this._is_valid_selection(n3, e3)) throw new Error("Invalid Default Value!");
        n3 = this._get_array(t3, n3);
        if (this._is_valid_selection(n3, e3)) return n3;
        throw new Error("Invalid Option Value: The option '" + t3 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t3] + "'");
      }, e2.prototype._is_valid_selection = function(t3, e3) {
        return t3.length && e3.length && !t3.some(function(t4) {
          return -1 === e3.indexOf(t4);
        });
      }, t2.exports.Options = e2, t2.exports.normalizeOpts = _3, t2.exports.mergeOpts = n2;
    }, , function(t2) {
      var i3 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t3) {
        this.__input = t3 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t3 = null;
        return this.hasNext() && (t3 = this.__input.charAt(this.__position), this.__position += 1), t3;
      }, e2.prototype.peek = function(t3) {
        var e3 = null;
        return t3 = t3 || 0, e3 = 0 <= (t3 += this.__position) && t3 < this.__input_length ? this.__input.charAt(t3) : e3;
      }, e2.prototype.__match = function(t3, e3) {
        t3.lastIndex = e3;
        var n2 = t3.exec(this.__input);
        return !n2 || i3 && t3.sticky || n2.index !== e3 && (n2 = null), n2;
      }, e2.prototype.test = function(t3, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t3, e3);
      }, e2.prototype.testChar = function(t3, e3) {
        e3 = this.peek(e3);
        return t3.lastIndex = 0, null !== e3 && t3.test(e3);
      }, e2.prototype.match = function(t3) {
        t3 = this.__match(t3, this.__position);
        return t3 ? this.__position += t3[0].length : t3 = null, t3;
      }, e2.prototype.read = function(t3, e3, n2) {
        var i4, _3 = "";
        return t3 && (i4 = this.match(t3)) && (_3 += i4[0]), !e3 || !i4 && t3 || (_3 += this.readUntil(e3, n2)), _3;
      }, e2.prototype.readUntil = function(t3, e3) {
        var n2 = this.__position, t3 = (t3.lastIndex = this.__position, t3.exec(this.__input));
        return t3 ? (n2 = t3.index, e3 && (n2 += t3[0].length)) : n2 = this.__input_length, e3 = this.__input.substring(this.__position, n2), this.__position = n2, e3;
      }, e2.prototype.readUntilAfter = function(t3) {
        return this.readUntil(t3, true);
      }, e2.prototype.get_regexp = function(t3, e3) {
        var n2 = null, e3 = e3 && i3 ? "y" : "g";
        return "string" == typeof t3 && "" !== t3 ? n2 = new RegExp(t3, e3) : t3 && (n2 = new RegExp(t3.source, e3)), n2;
      }, e2.prototype.get_literal_regexp = function(t3) {
        return RegExp(t3.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t3) {
        var e3 = this.__position, t3 = this.readUntilAfter(t3);
        return this.__position = e3, t3;
      }, e2.prototype.lookBack = function(t3) {
        var e3 = this.__position - 1;
        return e3 >= t3.length && this.__input.substring(e3 - t3.length, e3).toLowerCase() === t3;
      }, t2.exports.InputScanner = e2;
    }, function(t2, e2, n2) {
      function i3(t3, e3) {
        this._input = new _3(t3), this._options = e3 || {}, this.__tokens = null, this._patterns = {}, this._patterns.whitespace = new a(this._input);
      }
      var _3 = n2(8).InputScanner, s = n2(3).Token, r = n2(10).TokenStream, a = n2(11).WhitespacePattern, o = { START: "TK_START", RAW: "TK_RAW", EOF: "TK_EOF" };
      i3.prototype.tokenize = function() {
        this._input.restart(), this.__tokens = new r(), this._reset();
        for (var t3, e3 = new s(o.START, ""), n3 = null, i4 = [], _4 = new r(); e3.type !== o.EOF; ) {
          for (t3 = this._get_next_token(e3, n3); this._is_comment(t3); ) _4.add(t3), t3 = this._get_next_token(e3, n3);
          _4.isEmpty() || (t3.comments_before = _4, _4 = new r()), t3.parent = n3, this._is_opening(t3) ? (i4.push(n3), n3 = t3) : n3 && this._is_closing(t3, n3) && ((t3.opened = n3).closed = t3, n3 = i4.pop(), t3.parent = n3), (t3.previous = e3).next = t3, this.__tokens.add(t3), e3 = t3;
        }
        return this.__tokens;
      }, i3.prototype._is_first_token = function() {
        return this.__tokens.isEmpty();
      }, i3.prototype._reset = function() {
      }, i3.prototype._get_next_token = function(t3, e3) {
        this._readWhitespace();
        var n3 = this._input.read(/.+/g);
        return n3 ? this._create_token(o.RAW, n3) : this._create_token(o.EOF, "");
      }, i3.prototype._is_comment = function(t3) {
        return false;
      }, i3.prototype._is_opening = function(t3) {
        return false;
      }, i3.prototype._is_closing = function(t3, e3) {
        return false;
      }, i3.prototype._create_token = function(t3, e3) {
        return new s(t3, e3, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
      }, i3.prototype._readWhitespace = function() {
        return this._patterns.whitespace.read();
      }, t2.exports.Tokenizer = i3, t2.exports.TOKEN = o;
    }, function(t2) {
      function e2(t3) {
        this.__tokens = [], this.__tokens_length = this.__tokens.length, this.__position = 0, this.__parent_token = t3;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.isEmpty = function() {
        return 0 === this.__tokens_length;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__tokens_length;
      }, e2.prototype.next = function() {
        var t3 = null;
        return this.hasNext() && (t3 = this.__tokens[this.__position], this.__position += 1), t3;
      }, e2.prototype.peek = function(t3) {
        var e3 = null;
        return t3 = t3 || 0, e3 = 0 <= (t3 += this.__position) && t3 < this.__tokens_length ? this.__tokens[t3] : e3;
      }, e2.prototype.add = function(t3) {
        this.__parent_token && (t3.parent = this.__parent_token), this.__tokens.push(t3), this.__tokens_length += 1;
      }, t2.exports.TokenStream = e2;
    }, function(t2, e2, n2) {
      var i3 = n2(12).Pattern;
      function _3(t3, e3) {
        i3.call(this, t3, e3), e3 ? this._line_regexp = this._input.get_regexp(e3._line_regexp) : this.__set_whitespace_patterns("", ""), this.newline_count = 0, this.whitespace_before_token = "";
      }
      (_3.prototype = new i3()).__set_whitespace_patterns = function(t3, e3) {
        this._match_pattern = this._input.get_regexp("[" + (t3 += "\\\\t ") + (e3 += "\\\\n\\\\r") + "]+", true), this._newline_regexp = this._input.get_regexp("\\\\r\\\\n|[" + e3 + "]");
      }, _3.prototype.read = function() {
        this.newline_count = 0, this.whitespace_before_token = "";
        var t3, e3 = this._input.read(this._match_pattern);
        return " " === e3 ? this.whitespace_before_token = " " : e3 && (t3 = this.__split(this._newline_regexp, e3), this.newline_count = t3.length - 1, this.whitespace_before_token = t3[this.newline_count]), e3;
      }, _3.prototype.matching = function(t3, e3) {
        var n3 = this._create();
        return n3.__set_whitespace_patterns(t3, e3), n3._update(), n3;
      }, _3.prototype._create = function() {
        return new _3(this._input, this);
      }, _3.prototype.__split = function(t3, e3) {
        for (var n3 = t3.lastIndex = 0, i4 = [], _4 = t3.exec(e3); _4; ) i4.push(e3.substring(n3, _4.index)), n3 = _4.index + _4[0].length, _4 = t3.exec(e3);
        return n3 < e3.length ? i4.push(e3.substring(n3, e3.length)) : i4.push(""), i4;
      }, t2.exports.WhitespacePattern = _3;
    }, function(t2) {
      function e2(t3, e3) {
        this._input = t3, this._starting_pattern = null, this._match_pattern = null, this._until_pattern = null, this._until_after = false, e3 && (this._starting_pattern = this._input.get_regexp(e3._starting_pattern, true), this._match_pattern = this._input.get_regexp(e3._match_pattern, true), this._until_pattern = this._input.get_regexp(e3._until_pattern), this._until_after = e3._until_after);
      }
      e2.prototype.read = function() {
        var t3 = this._input.read(this._starting_pattern);
        return this._starting_pattern && !t3 || (t3 += this._input.read(this._match_pattern, this._until_pattern, this._until_after)), t3;
      }, e2.prototype.read_match = function() {
        return this._input.match(this._match_pattern);
      }, e2.prototype.until_after = function(t3) {
        var e3 = this._create();
        return e3._until_after = true, e3._until_pattern = this._input.get_regexp(t3), e3._update(), e3;
      }, e2.prototype.until = function(t3) {
        var e3 = this._create();
        return e3._until_after = false, e3._until_pattern = this._input.get_regexp(t3), e3._update(), e3;
      }, e2.prototype.starting_with = function(t3) {
        var e3 = this._create();
        return e3._starting_pattern = this._input.get_regexp(t3, true), e3._update(), e3;
      }, e2.prototype.matching = function(t3) {
        var e3 = this._create();
        return e3._match_pattern = this._input.get_regexp(t3, true), e3._update(), e3;
      }, e2.prototype._create = function() {
        return new e2(this._input, this);
      }, e2.prototype._update = function() {
      }, t2.exports.Pattern = e2;
    }, function(t2) {
      function e2(t3, e3) {
        t3 = "string" == typeof t3 ? t3 : t3.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t3 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t3 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t3) {
        if (!t3.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, n2 = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t3)); n2; ) e3[n2[1]] = n2[2], n2 = this.__directive_pattern.exec(t3);
        return e3;
      }, e2.prototype.readIgnored = function(t3) {
        return t3.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t2.exports.Directives = e2;
    }, function(t2, e2, n2) {
      var i3 = n2(12).Pattern, _3 = { django: false, erb: false, handlebars: false, php: false, smarty: false };
      function s(t3, e3) {
        i3.call(this, t3, e3), this.__template_pattern = null, this._disabled = Object.assign({}, _3), this._excluded = Object.assign({}, _3), e3 && (this.__template_pattern = this._input.get_regexp(e3.__template_pattern), this._excluded = Object.assign(this._excluded, e3._excluded), this._disabled = Object.assign(this._disabled, e3._disabled));
        e3 = new i3(t3);
        this.__patterns = { handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars_unescaped: e3.starting_with(/{{{/).until_after(/}}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), php: e3.starting_with(/<\\?(?:[= ]|php)/).until_after(/\\?>/), erb: e3.starting_with(/<%[^%]/).until_after(/[^%]%>/), django: e3.starting_with(/{%/).until_after(/%}/), django_value: e3.starting_with(/{{/).until_after(/}}/), django_comment: e3.starting_with(/{#/).until_after(/#}/), smarty: e3.starting_with(/{(?=[^}{\\s\\n])/).until_after(/[^\\s\\n]}/), smarty_comment: e3.starting_with(/{\\*/).until_after(/\\*}/), smarty_literal: e3.starting_with(/{literal}/).until_after(/{\\/literal}/) };
      }
      (s.prototype = new i3())._create = function() {
        return new s(this._input, this);
      }, s.prototype._update = function() {
        this.__set_templated_pattern();
      }, s.prototype.disable = function(t3) {
        var e3 = this._create();
        return e3._disabled[t3] = true, e3._update(), e3;
      }, s.prototype.read_options = function(t3) {
        var e3, n3 = this._create();
        for (e3 in _3) n3._disabled[e3] = -1 === t3.templating.indexOf(e3);
        return n3._update(), n3;
      }, s.prototype.exclude = function(t3) {
        var e3 = this._create();
        return e3._excluded[t3] = true, e3._update(), e3;
      }, s.prototype.read = function() {
        for (var t3 = "", t3 = this._match_pattern ? this._input.read(this._starting_pattern) : this._input.read(this._starting_pattern, this.__template_pattern), e3 = this._read_template(); e3; ) this._match_pattern ? e3 += this._input.read(this._match_pattern) : e3 += this._input.readUntil(this.__template_pattern), t3 += e3, e3 = this._read_template();
        return this._until_after && (t3 += this._input.readUntilAfter(this._until_pattern)), t3;
      }, s.prototype.__set_templated_pattern = function() {
        var t3 = [];
        this._disabled.php || t3.push(this.__patterns.php._starting_pattern.source), this._disabled.handlebars || t3.push(this.__patterns.handlebars._starting_pattern.source), this._disabled.erb || t3.push(this.__patterns.erb._starting_pattern.source), this._disabled.django || (t3.push(this.__patterns.django._starting_pattern.source), t3.push(this.__patterns.django_value._starting_pattern.source), t3.push(this.__patterns.django_comment._starting_pattern.source)), this._disabled.smarty || t3.push(this.__patterns.smarty._starting_pattern.source), this._until_pattern && t3.push(this._until_pattern.source), this.__template_pattern = this._input.get_regexp("(?:" + t3.join("|") + ")");
      }, s.prototype._read_template = function() {
        var t3, e3 = "", n3 = this._input.peek();
        return "<" === n3 ? (t3 = this._input.peek(1), this._disabled.php || this._excluded.php || "?" !== t3 || (e3 = e3 || this.__patterns.php.read()), this._disabled.erb || this._excluded.erb || "%" !== t3 || (e3 = e3 || this.__patterns.erb.read())) : "{" === n3 && (this._disabled.handlebars || this._excluded.handlebars || (e3 = (e3 = (e3 = e3 || this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars_unescaped.read()) || this.__patterns.handlebars.read()), this._disabled.django || (this._excluded.django || this._excluded.handlebars || (e3 = e3 || this.__patterns.django_value.read()), this._excluded.django || (e3 = (e3 = e3 || this.__patterns.django_comment.read()) || this.__patterns.django.read())), this._disabled.smarty || this._disabled.django && this._disabled.handlebars && (e3 = (e3 = (e3 = e3 || this.__patterns.smarty_comment.read()) || this.__patterns.smarty_literal.read()) || this.__patterns.smarty.read())), e3;
      }, t2.exports.TemplatablePattern = s;
    }, , , , function(t2, e2, n2) {
      var _3 = n2(19).Beautifier, i3 = n2(20).Options;
      t2.exports = function(t3, e3, n3, i4) {
        return new _3(t3, e3, n3, i4).beautify();
      }, t2.exports.defaultOptions = function() {
        return new i3();
      };
    }, function(t2, e2, n2) {
      function p(t3, e3) {
        this.indent_level = 0, this.alignment_size = 0, this.max_preserve_newlines = t3.max_preserve_newlines, this.preserve_newlines = t3.preserve_newlines, this._output = new i3(t3, e3);
      }
      function s(t3, e3) {
        var n3 = null, i4 = null;
        return e3.closed ? ("script" === t3 ? n3 = "text/javascript" : "style" === t3 && (n3 = "text/css"), -1 < (n3 = function(t4) {
          for (var e4 = null, n4 = t4.next; n4.type !== u.EOF && t4.closed !== n4; ) {
            if (n4.type === u.ATTRIBUTE && "type" === n4.text) {
              n4.next && n4.next.type === u.EQUALS && n4.next.next && n4.next.next.type === u.VALUE && (e4 = n4.next.next.text);
              break;
            }
            n4 = n4.next;
          }
          return e4;
        }(e3) || n3).search("text/css") ? i4 = "css" : -1 < n3.search(/module|((text|application|dojo)\\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\\+)?json|method|aspect))/) ? i4 = "javascript" : -1 < n3.search(/(text|application|dojo)\\/(x-)?(html)/) ? i4 = "html" : -1 < n3.search(/test\\/null/) && (i4 = "null"), i4) : null;
      }
      var _3 = n2(20).Options, i3 = n2(2).Output, h = n2(21).Tokenizer, u = n2(21).TOKEN, l = /\\r\\n|[\\r\\n]/, c = /\\r\\n|[\\r\\n]/g;
      p.prototype.current_line_has_match = function(t3) {
        return this._output.current_line.has_match(t3);
      }, p.prototype.set_space_before_token = function(t3, e3) {
        this._output.space_before_token = t3, this._output.non_breaking_space = e3;
      }, p.prototype.set_wrap_point = function() {
        this._output.set_indent(this.indent_level, this.alignment_size), this._output.set_wrap_point();
      }, p.prototype.add_raw_token = function(t3) {
        this._output.add_raw_token(t3);
      }, p.prototype.print_preserved_newlines = function(t3) {
        var e3 = 0;
        t3.type !== u.TEXT && t3.previous.type !== u.TEXT && (e3 = t3.newlines ? 1 : 0), this.preserve_newlines && (e3 = t3.newlines < this.max_preserve_newlines + 1 ? t3.newlines : this.max_preserve_newlines + 1);
        for (var n3 = 0; n3 < e3; n3++) this.print_newline(0 < n3);
        return 0 !== e3;
      }, p.prototype.traverse_whitespace = function(t3) {
        return !(!t3.whitespace_before && !t3.newlines) && (this.print_preserved_newlines(t3) || (this._output.space_before_token = true), true);
      }, p.prototype.previous_token_wrapped = function() {
        return this._output.previous_token_wrapped;
      }, p.prototype.print_newline = function(t3) {
        this._output.add_new_line(t3);
      }, p.prototype.print_token = function(t3) {
        t3.text && (this._output.set_indent(this.indent_level, this.alignment_size), this._output.add_token(t3.text));
      }, p.prototype.indent = function() {
        this.indent_level++;
      }, p.prototype.get_full_indent = function(t3) {
        return (t3 = this.indent_level + (t3 || 0)) < 1 ? "" : this._output.get_indent_string(t3);
      };
      function r(t3, e3) {
        return -1 !== e3.indexOf(t3);
      }
      function a(t3, e3, n3) {
        this.parent = t3 || null, this.tag = e3 ? e3.tag_name : "", this.indent_level = n3 || 0, this.parser_token = e3 || null;
      }
      function d(t3) {
        this._printer = t3, this._current_frame = null;
      }
      function g(t3, e3, n3, i4) {
        this._source_text = t3 || "", e3 = e3 || {}, this._js_beautify = n3, this._css_beautify = i4, this._tag_stack = null;
        t3 = new _3(e3, "html");
        this._options = t3, this._is_wrap_attributes_force = "force" === this._options.wrap_attributes.substr(0, "force".length), this._is_wrap_attributes_force_expand_multiline = "force-expand-multiline" === this._options.wrap_attributes, this._is_wrap_attributes_force_aligned = "force-aligned" === this._options.wrap_attributes, this._is_wrap_attributes_aligned_multiple = "aligned-multiple" === this._options.wrap_attributes, this._is_wrap_attributes_preserve = "preserve" === this._options.wrap_attributes.substr(0, "preserve".length), this._is_wrap_attributes_preserve_aligned = "preserve-aligned" === this._options.wrap_attributes;
      }
      d.prototype.get_parser_token = function() {
        return this._current_frame ? this._current_frame.parser_token : null;
      }, d.prototype.record_tag = function(t3) {
        t3 = new a(this._current_frame, t3, this._printer.indent_level);
        this._current_frame = t3;
      }, d.prototype._try_pop_frame = function(t3) {
        var e3 = null;
        return t3 && (e3 = t3.parser_token, this._printer.indent_level = t3.indent_level, this._current_frame = t3.parent), e3;
      }, d.prototype._get_frame = function(t3, e3) {
        for (var n3 = this._current_frame; n3 && -1 === t3.indexOf(n3.tag); ) {
          if (e3 && -1 !== e3.indexOf(n3.tag)) {
            n3 = null;
            break;
          }
          n3 = n3.parent;
        }
        return n3;
      }, d.prototype.try_pop = function(t3, e3) {
        t3 = this._get_frame([t3], e3);
        return this._try_pop_frame(t3);
      }, d.prototype.indent_to_tag = function(t3) {
        t3 = this._get_frame(t3);
        t3 && (this._printer.indent_level = t3.indent_level);
      }, g.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t3 = this._source_text, e3 = this._options.eol, n3 = ("auto" === this._options.eol && (e3 = "\\n", t3 && l.test(t3) && (e3 = t3.match(l)[0])), (t3 = t3.replace(c, "\\n")).match(/^[\\t ]*/)[0]), i4 = { text: "", type: "" }, _4 = new f(), s2 = new p(this._options, n3), r2 = new h(t3, this._options).tokenize(), a2 = (this._tag_stack = new d(s2), null), o2 = r2.next(); o2.type !== u.EOF; ) o2.type === u.TAG_OPEN || o2.type === u.COMMENT ? _4 = a2 = this._handle_tag_open(s2, o2, _4, i4, r2) : o2.type === u.ATTRIBUTE || o2.type === u.EQUALS || o2.type === u.VALUE || o2.type === u.TEXT && !_4.tag_complete ? a2 = this._handle_inside_tag(s2, o2, _4, i4) : o2.type === u.TAG_CLOSE ? a2 = this._handle_tag_close(s2, o2, _4) : o2.type === u.TEXT ? a2 = this._handle_text(s2, o2, _4) : s2.add_raw_token(o2), i4 = a2, o2 = r2.next();
        return s2._output.get_code(e3);
      }, g.prototype._handle_tag_close = function(t3, e3, n3) {
        var i4 = { text: e3.text, type: e3.type };
        return t3.alignment_size = 0, n3.tag_complete = true, t3.set_space_before_token(e3.newlines || "" !== e3.whitespace_before, true), n3.is_unformatted ? t3.add_raw_token(e3) : ("<" === n3.tag_start_char && (t3.set_space_before_token("/" === e3.text[0], true), this._is_wrap_attributes_force_expand_multiline && n3.has_wrapped_attrs && t3.print_newline(false)), t3.print_token(e3)), !n3.indent_content || n3.is_unformatted || n3.is_content_unformatted || (t3.indent(), n3.indent_content = false), n3.is_inline_element || n3.is_unformatted || n3.is_content_unformatted || t3.set_wrap_point(), i4;
      }, g.prototype._handle_inside_tag = function(t3, e3, n3, i4) {
        var _4 = n3.has_wrapped_attrs, s2 = { text: e3.text, type: e3.type };
        return t3.set_space_before_token(e3.newlines || "" !== e3.whitespace_before, true), n3.is_unformatted ? t3.add_raw_token(e3) : "{" === n3.tag_start_char && e3.type === u.TEXT ? t3.print_preserved_newlines(e3) ? (e3.newlines = 0, t3.add_raw_token(e3)) : t3.print_token(e3) : (e3.type === u.ATTRIBUTE ? t3.set_space_before_token(true) : (e3.type === u.EQUALS || e3.type === u.VALUE && e3.previous.type === u.EQUALS) && t3.set_space_before_token(false), e3.type === u.ATTRIBUTE && "<" === n3.tag_start_char && ((this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) && (t3.traverse_whitespace(e3), _4 = _4 || 0 !== e3.newlines), this._is_wrap_attributes_force && n3.attr_count >= this._options.wrap_attributes_min_attrs && (i4.type !== u.TAG_OPEN || this._is_wrap_attributes_force_expand_multiline) && (t3.print_newline(false), _4 = true)), t3.print_token(e3), _4 = _4 || t3.previous_token_wrapped(), n3.has_wrapped_attrs = _4), s2;
      }, g.prototype._handle_text = function(t3, e3, n3) {
        var i4 = { text: e3.text, type: "TK_CONTENT" };
        return n3.custom_beautifier_name ? this._print_custom_beatifier_text(t3, e3, n3) : n3.is_unformatted || n3.is_content_unformatted ? t3.add_raw_token(e3) : (t3.traverse_whitespace(e3), t3.print_token(e3)), i4;
      }, g.prototype._print_custom_beatifier_text = function(t3, e3, n3) {
        var i4 = this;
        if ("" !== e3.text) {
          var _4, s2 = e3.text, r2 = 1, a2 = "", o2 = "", r2 = ("javascript" === n3.custom_beautifier_name && "function" == typeof this._js_beautify ? _4 = this._js_beautify : "css" === n3.custom_beautifier_name && "function" == typeof this._css_beautify ? _4 = this._css_beautify : "html" === n3.custom_beautifier_name && (_4 = function(t4, e4) {
            return new g(t4, e4, i4._js_beautify, i4._css_beautify).beautify();
          }), "keep" === this._options.indent_scripts ? r2 = 0 : "separate" === this._options.indent_scripts && (r2 = -t3.indent_level), t3.get_full_indent(r2));
          if (s2 = s2.replace(/\\n[ \\t]*\$/, ""), "html" !== n3.custom_beautifier_name && "<" === s2[0] && s2.match(/^(<!--|<!\\[CDATA\\[)/)) {
            var n3 = /^(<!--[^\\n]*|<!\\[CDATA\\[)(\\n?)([ \\t\\n]*)([\\s\\S]*)(-->|]]>)\$/.exec(s2);
            if (!n3) return void t3.add_raw_token(e3);
            a2 = r2 + n3[1] + "\\n", s2 = n3[4], n3[5] && (o2 = r2 + n3[5]), s2 = s2.replace(/\\n[ \\t]*\$/, ""), (n3[2] || -1 !== n3[3].indexOf("\\n")) && (n3 = n3[3].match(/[ \\t]+\$/)) && (e3.whitespace_before = n3[0]);
          }
          s2 = s2 && (_4 ? ((n3 = function() {
            this.eol = "\\n";
          }).prototype = this._options.raw_options, _4(r2 + s2, new n3())) : r2 + (s2 = (_4 = e3.whitespace_before) ? s2.replace(new RegExp("\\n(" + _4 + ")?", "g"), "\\n") : s2).replace(/\\n/g, "\\n" + r2)), a2 && (s2 = s2 ? a2 + s2 + "\\n" + o2 : a2 + o2), t3.print_newline(false), s2 && (e3.text = s2, e3.whitespace_before = "", e3.newlines = 0, t3.add_raw_token(e3), t3.print_newline(true));
        }
      }, g.prototype._handle_tag_open = function(t3, e3, n3, i4, _4) {
        var s2 = this._get_tag_open_token(e3);
        if (!n3.is_unformatted && !n3.is_content_unformatted || n3.is_empty_element || e3.type !== u.TAG_OPEN || s2.is_start_tag ? (t3.traverse_whitespace(e3), this._set_tag_position(t3, e3, s2, n3, i4), s2.is_inline_element || t3.set_wrap_point(), t3.print_token(e3)) : (t3.add_raw_token(e3), s2.start_tag_token = this._tag_stack.try_pop(s2.tag_name)), s2.is_start_tag && this._is_wrap_attributes_force) for (var r2, a2 = 0; (r2 = _4.peek(a2)).type === u.ATTRIBUTE && (s2.attr_count += 1), a2 += 1, r2.type !== u.EOF && r2.type !== u.TAG_CLOSE; ) ;
        return (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) && (s2.alignment_size = e3.text.length + 1), s2.tag_complete || s2.is_unformatted || (t3.alignment_size = s2.alignment_size), s2;
      };
      var f = function(t3, e3) {
        var n3;
        this.parent = t3 || null, this.text = "", this.type = "TK_TAG_OPEN", this.tag_name = "", this.is_inline_element = false, this.is_unformatted = false, this.is_content_unformatted = false, this.is_empty_element = false, this.is_start_tag = false, this.is_end_tag = false, this.indent_content = false, this.multiline_content = false, this.custom_beautifier_name = null, this.start_tag_token = null, this.attr_count = 0, this.has_wrapped_attrs = false, this.alignment_size = 0, this.tag_complete = false, this.tag_start_char = "", this.tag_check = "", e3 ? (this.tag_start_char = e3.text[0], this.text = e3.text, "<" === this.tag_start_char ? (n3 = e3.text.match(/^<([^\\s>]*)/), this.tag_check = n3 ? n3[1] : "") : (n3 = e3.text.match(/^{{~?(?:[\\^]|#\\*?)?([^\\s}]+)/), this.tag_check = n3 ? n3[1] : "", (e3.text.startsWith("{{#>") || e3.text.startsWith("{{~#>")) && ">" === this.tag_check[0] && (">" === this.tag_check && null !== e3.next ? this.tag_check = e3.next.text.split(" ")[0] : this.tag_check = e3.text.split(">")[1])), this.tag_check = this.tag_check.toLowerCase(), e3.type === u.COMMENT && (this.tag_complete = true), this.is_start_tag = "/" !== this.tag_check.charAt(0), this.tag_name = this.is_start_tag ? this.tag_check : this.tag_check.substr(1), this.is_end_tag = !this.is_start_tag || e3.closed && "/>" === e3.closed.text, t3 = 2, "{" === this.tag_start_char && 3 <= this.text.length && "~" === this.text.charAt(2) && (t3 = 3), this.is_end_tag = this.is_end_tag || "{" === this.tag_start_char && (this.text.length < 3 || /[^#\\^]/.test(this.text.charAt(t3)))) : this.tag_complete = true;
      }, o = (g.prototype._get_tag_open_token = function(t3) {
        t3 = new f(this._tag_stack.get_parser_token(), t3);
        return t3.alignment_size = this._options.wrap_attributes_indent_size, t3.is_end_tag = t3.is_end_tag || r(t3.tag_check, this._options.void_elements), t3.is_empty_element = t3.tag_complete || t3.is_start_tag && t3.is_end_tag, t3.is_unformatted = !t3.tag_complete && r(t3.tag_check, this._options.unformatted), t3.is_content_unformatted = !t3.is_empty_element && r(t3.tag_check, this._options.content_unformatted), t3.is_inline_element = r(t3.tag_name, this._options.inline) || this._options.inline_custom_elements && t3.tag_name.includes("-") || "{" === t3.tag_start_char, t3;
      }, g.prototype._set_tag_position = function(t3, e3, n3, i4, _4) {
        n3.is_empty_element || (n3.is_end_tag ? n3.start_tag_token = this._tag_stack.try_pop(n3.tag_name) : (this._do_optional_end_element(n3) && !n3.is_inline_element && t3.print_newline(false), this._tag_stack.record_tag(n3), "script" !== n3.tag_name && "style" !== n3.tag_name || n3.is_unformatted || n3.is_content_unformatted || (n3.custom_beautifier_name = s(n3.tag_check, e3)))), r(n3.tag_check, this._options.extra_liners) && (t3.print_newline(false), t3._output.just_added_blankline() || t3.print_newline(true)), n3.is_empty_element ? ("{" === n3.tag_start_char && "else" === n3.tag_check && (this._tag_stack.indent_to_tag(["if", "unless", "each"]), n3.indent_content = true, t3.current_line_has_match(/{{#if/) || t3.print_newline(false)), "!--" === n3.tag_name && _4.type === u.TAG_CLOSE && i4.is_end_tag && -1 === n3.text.indexOf("\\n") || (n3.is_inline_element || n3.is_unformatted || t3.print_newline(false), this._calcluate_parent_multiline(t3, n3))) : n3.is_end_tag ? (e3 = false, e3 = (e3 = n3.start_tag_token && n3.start_tag_token.multiline_content) || !n3.is_inline_element && !(i4.is_inline_element || i4.is_unformatted) && !(_4.type === u.TAG_CLOSE && n3.start_tag_token === i4) && "TK_CONTENT" !== _4.type, (e3 = n3.is_content_unformatted || n3.is_unformatted ? false : e3) && t3.print_newline(false)) : (n3.indent_content = !n3.custom_beautifier_name, "<" === n3.tag_start_char && ("html" === n3.tag_name ? n3.indent_content = this._options.indent_inner_html : "head" === n3.tag_name ? n3.indent_content = this._options.indent_head_inner_html : "body" === n3.tag_name && (n3.indent_content = this._options.indent_body_inner_html)), n3.is_inline_element || n3.is_unformatted || "TK_CONTENT" === _4.type && !n3.is_content_unformatted || t3.print_newline(false), this._calcluate_parent_multiline(t3, n3));
      }, g.prototype._calcluate_parent_multiline = function(t3, e3) {
        !e3.parent || !t3._output.just_added_newline() || (e3.is_inline_element || e3.is_unformatted) && e3.parent.is_inline_element || (e3.parent.multiline_content = true);
      }, ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "menu", "nav", "ol", "p", "pre", "section", "table", "ul"]), m = ["a", "audio", "del", "ins", "map", "noscript", "video"];
      g.prototype._do_optional_end_element = function(t3) {
        var e3, n3 = null;
        if (!t3.is_empty_element && t3.is_start_tag && t3.parent) return "body" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("head") : "li" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("li", ["ol", "ul", "menu"]) : "dd" === t3.tag_name || "dt" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("dt", ["dl"])) || this._tag_stack.try_pop("dd", ["dl"]) : "p" === t3.parent.tag_name && -1 !== o.indexOf(t3.tag_name) ? (e3 = t3.parent.parent) && -1 !== m.indexOf(e3.tag_name) || (n3 = n3 || this._tag_stack.try_pop("p")) : "rp" === t3.tag_name || "rt" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("rt", ["ruby", "rtc"])) || this._tag_stack.try_pop("rp", ["ruby", "rtc"]) : "optgroup" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("optgroup", ["select"]) : "option" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]) : "colgroup" === t3.tag_name ? n3 = n3 || this._tag_stack.try_pop("caption", ["table"]) : "thead" === t3.tag_name ? n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"]) : "tbody" === t3.tag_name || "tfoot" === t3.tag_name ? n3 = (n3 = (n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"])) || this._tag_stack.try_pop("thead", ["table"])) || this._tag_stack.try_pop("tbody", ["table"]) : "tr" === t3.tag_name ? n3 = (n3 = (n3 = n3 || this._tag_stack.try_pop("caption", ["table"])) || this._tag_stack.try_pop("colgroup", ["table"])) || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]) : "th" !== t3.tag_name && "td" !== t3.tag_name || (n3 = (n3 = n3 || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"])) || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"])), t3.parent = this._tag_stack.get_parser_token(), n3;
      }, t2.exports.Beautifier = g;
    }, function(t2, e2, n2) {
      var i3 = n2(6).Options;
      function _3(t3) {
        i3.call(this, t3, "html"), 1 === this.templating.length && "auto" === this.templating[0] && (this.templating = ["django", "erb", "handlebars", "php"]), this.indent_inner_html = this._get_boolean("indent_inner_html"), this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true), this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true), this.indent_handlebars = this._get_boolean("indent_handlebars", true), this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]), this.wrap_attributes_min_attrs = this._get_number("wrap_attributes_min_attrs", 2), this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size), this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]), this.inline = this._get_array("inline", ["a", "abbr", "area", "audio", "b", "bdi", "bdo", "br", "button", "canvas", "cite", "code", "data", "datalist", "del", "dfn", "em", "embed", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "map", "mark", "math", "meter", "noscript", "object", "output", "progress", "q", "ruby", "s", "samp", "select", "small", "span", "strong", "sub", "sup", "svg", "template", "textarea", "time", "u", "var", "video", "wbr", "text", "acronym", "big", "strike", "tt"]), this.inline_custom_elements = this._get_boolean("inline_custom_elements", true), this.void_elements = this._get_array("void_elements", ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr", "!doctype", "?xml", "basefont", "isindex"]), this.unformatted = this._get_array("unformatted", []), this.content_unformatted = this._get_array("content_unformatted", ["pre", "textarea"]), this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter"), this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
      }
      _3.prototype = new i3(), t2.exports.Options = _3;
    }, function(t2, e2, n2) {
      function i3(t3, e3) {
        _3.call(this, t3, e3), this._current_tag_name = "";
        var t3 = new a(this._input).read_options(this._options), e3 = new o(this._input);
        this.__patterns = { word: t3.until(/[\\n\\r\\t <]/), single_quote: t3.until_after(/'/), double_quote: t3.until_after(/"/), attribute: t3.until(/[\\n\\r\\t =>]|\\/>/), element_name: t3.until(/[\\n\\r\\t >\\/]/), handlebars_comment: e3.starting_with(/{{!--/).until_after(/--}}/), handlebars: e3.starting_with(/{{/).until_after(/}}/), handlebars_open: e3.until(/[\\n\\r\\t }]/), handlebars_raw_close: e3.until(/}}/), comment: e3.starting_with(/<!--/).until_after(/-->/), cdata: e3.starting_with(/<!\\[CDATA\\[/).until_after(/]]>/), conditional_comment: e3.starting_with(/<!\\[/).until_after(/]>/), processing: e3.starting_with(/<\\?/).until_after(/\\?>/) }, this._options.indent_handlebars && (this.__patterns.word = this.__patterns.word.exclude("handlebars")), this._unformatted_content_delimiter = null, this._options.unformatted_content_delimiter && (t3 = this._input.get_literal_regexp(this._options.unformatted_content_delimiter), this.__patterns.unformatted_content_delimiter = e3.matching(t3).until_after(t3));
      }
      var _3 = n2(9).Tokenizer, s = n2(9).TOKEN, r = n2(13).Directives, a = n2(14).TemplatablePattern, o = n2(12).Pattern, p = { TAG_OPEN: "TK_TAG_OPEN", TAG_CLOSE: "TK_TAG_CLOSE", ATTRIBUTE: "TK_ATTRIBUTE", EQUALS: "TK_EQUALS", VALUE: "TK_VALUE", COMMENT: "TK_COMMENT", TEXT: "TK_TEXT", UNKNOWN: "TK_UNKNOWN", START: s.START, RAW: s.RAW, EOF: s.EOF }, h = new r(/<\\!--/, /-->/);
      (i3.prototype = new _3())._is_comment = function(t3) {
        return false;
      }, i3.prototype._is_opening = function(t3) {
        return t3.type === p.TAG_OPEN;
      }, i3.prototype._is_closing = function(t3, e3) {
        return t3.type === p.TAG_CLOSE && e3 && ((">" === t3.text || "/>" === t3.text) && "<" === e3.text[0] || "}}" === t3.text && "{" === e3.text[0] && "{" === e3.text[1]);
      }, i3.prototype._reset = function() {
        this._current_tag_name = "";
      }, i3.prototype._get_next_token = function(t3, e3) {
        this._readWhitespace();
        var n3 = this._input.peek();
        return null === n3 ? this._create_token(p.EOF, "") : this._read_open_handlebars(n3, e3) || this._read_attribute(n3, t3, e3) || this._read_close(n3, e3) || this._read_raw_content(n3, t3, e3) || this._read_content_word(n3) || this._read_comment_or_cdata(n3) || this._read_processing(n3) || this._read_open(n3, e3) || this._create_token(p.UNKNOWN, this._input.next());
      }, i3.prototype._read_comment_or_cdata = function(t3) {
        var e3 = null, n3 = null, i4 = null;
        return "<" === t3 && ("!" === this._input.peek(1) && ((n3 = this.__patterns.comment.read()) ? (i4 = h.get_directives(n3)) && "start" === i4.ignore && (n3 += h.readIgnored(this._input)) : n3 = this.__patterns.cdata.read()), n3 && ((e3 = this._create_token(p.COMMENT, n3)).directives = i4)), e3;
      }, i3.prototype._read_processing = function(t3) {
        var e3 = null, n3 = null;
        return "<" === t3 && (n3 = "!" !== (t3 = this._input.peek(1)) && "?" !== t3 ? n3 : (n3 = this.__patterns.conditional_comment.read()) || this.__patterns.processing.read()) && ((e3 = this._create_token(p.COMMENT, n3)).directives = null), e3;
      }, i3.prototype._read_open = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 || "<" === t3 && (n3 = this._input.next(), "/" === this._input.peek() && (n3 += this._input.next()), n3 += this.__patterns.element_name.read(), i4 = this._create_token(p.TAG_OPEN, n3)), i4;
      }, i3.prototype._read_open_handlebars = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 || this._options.indent_handlebars && "{" === t3 && "{" === this._input.peek(1) && (i4 = "!" === this._input.peek(2) ? (n3 = (n3 = this.__patterns.handlebars_comment.read()) || this.__patterns.handlebars.read(), this._create_token(p.COMMENT, n3)) : (n3 = this.__patterns.handlebars_open.read(), this._create_token(p.TAG_OPEN, n3))), i4;
      }, i3.prototype._read_close = function(t3, e3) {
        var n3 = null, i4 = null;
        return e3 && ("<" === e3.text[0] && (">" === t3 || "/" === t3 && ">" === this._input.peek(1)) ? (n3 = this._input.next(), "/" === t3 && (n3 += this._input.next()), i4 = this._create_token(p.TAG_CLOSE, n3)) : "{" === e3.text[0] && "}" === t3 && "}" === this._input.peek(1) && (this._input.next(), this._input.next(), i4 = this._create_token(p.TAG_CLOSE, "}}"))), i4;
      }, i3.prototype._read_attribute = function(t3, e3, n3) {
        var i4 = null;
        return n3 && "<" === n3.text[0] && ("=" === t3 ? i4 = this._create_token(p.EQUALS, this._input.next()) : '"' === t3 || "'" === t3 ? (n3 = this._input.next(), n3 += ('"' === t3 ? this.__patterns.double_quote : this.__patterns.single_quote).read(), i4 = this._create_token(p.VALUE, n3)) : (t3 = this.__patterns.attribute.read()) && (i4 = e3.type === p.EQUALS ? this._create_token(p.VALUE, t3) : this._create_token(p.ATTRIBUTE, t3))), i4;
      }, i3.prototype._is_content_unformatted = function(t3) {
        return -1 === this._options.void_elements.indexOf(t3) && (-1 !== this._options.content_unformatted.indexOf(t3) || -1 !== this._options.unformatted.indexOf(t3));
      }, i3.prototype._read_raw_content = function(t3, e3, n3) {
        var i4 = "";
        if (n3 && "{" === n3.text[0]) i4 = this.__patterns.handlebars_raw_close.read();
        else if (e3.type === p.TAG_CLOSE && "<" === e3.opened.text[0] && "/" !== e3.text[0]) {
          n3 = e3.opened.text.substr(1).toLowerCase();
          if ("script" === n3 || "style" === n3) {
            e3 = this._read_comment_or_cdata(t3);
            if (e3) return e3.type = p.TEXT, e3;
            i4 = this._input.readUntil(new RegExp("</" + n3 + "[\\\\n\\\\r\\\\t ]*?>", "ig"));
          } else this._is_content_unformatted(n3) && (i4 = this._input.readUntil(new RegExp("</" + n3 + "[\\\\n\\\\r\\\\t ]*?>", "ig")));
        }
        return i4 ? this._create_token(p.TEXT, i4) : null;
      }, i3.prototype._read_content_word = function(t3) {
        var e3 = "";
        if (e3 = (e3 = this._options.unformatted_content_delimiter && t3 === this._options.unformatted_content_delimiter[0] ? this.__patterns.unformatted_content_delimiter.read() : e3) || this.__patterns.word.read()) return this._create_token(p.TEXT, e3);
      }, t2.exports.Tokenizer = i3, t2.exports.TOKEN = p;
    }], _2 = {};
    var t = function t2(e2) {
      var n2 = _2[e2];
      if (void 0 !== n2) return n2.exports;
      n2 = _2[e2] = { exports: {} };
      return i2[e2](n2, n2.exports, t2), n2.exports;
    }(18);
    e = t;
  }();
  var e, n, i, _ = e;
  "function" == typeof define && define.amd ? define(["require", "./beautify", "./beautify-css"], function(t) {
    var n2 = t("./beautify"), i2 = t("./beautify-css");
    return { html_beautify: function(t2, e2) {
      return _(t2, e2, n2.js_beautify, i2.css_beautify);
    } };
  }) : "undefined" != typeof exports ? (n = require("./beautify.js"), i = require("./beautify-css.js"), exports.html_beautify = function(t, e2) {
    return _(t, e2, n.js_beautify, i.css_beautify);
  }) : "undefined" != typeof window ? window.html_beautify = function(t, e2) {
    return _(t, e2, window.js_beautify, window.css_beautify);
  } : "undefined" != typeof global && (global.html_beautify = function(t, e2) {
    return _(t, e2, global.js_beautify, global.css_beautify);
  });
}();
!function() {
  !function() {
    var n = [, , function(t3) {
      function _2(t4) {
        this.__parent = t4, this.__character_count = 0, this.__indent_count = -1, this.__alignment_count = 0, this.__wrap_point_index = 0, this.__wrap_point_character_count = 0, this.__wrap_point_indent_count = -1, this.__wrap_point_alignment_count = 0, this.__items = [];
      }
      function i(t4, e3) {
        this.__cache = [""], this.__indent_size = t4.indent_size, this.__indent_string = t4.indent_char, t4.indent_with_tabs || (this.__indent_string = new Array(t4.indent_size + 1).join(t4.indent_char)), e3 = e3 || "", 0 < t4.indent_level && (e3 = new Array(t4.indent_level + 1).join(this.__indent_string)), this.__base_string = e3, this.__base_string_length = e3.length;
      }
      function e2(t4, e3) {
        this.__indent_cache = new i(t4, e3), this.raw = false, this._end_with_newline = t4.end_with_newline, this.indent_size = t4.indent_size, this.wrap_line_length = t4.wrap_line_length, this.indent_empty_lines = t4.indent_empty_lines, this.__lines = [], this.previous_line = null, this.current_line = null, this.next_line = new _2(this), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false, this.__add_outputline();
      }
      _2.prototype.clone_empty = function() {
        var t4 = new _2(this.__parent);
        return t4.set_indent(this.__indent_count, this.__alignment_count), t4;
      }, _2.prototype.item = function(t4) {
        return t4 < 0 ? this.__items[this.__items.length + t4] : this.__items[t4];
      }, _2.prototype.has_match = function(t4) {
        for (var e3 = this.__items.length - 1; 0 <= e3; e3--) if (this.__items[e3].match(t4)) return true;
        return false;
      }, _2.prototype.set_indent = function(t4, e3) {
        this.is_empty() && (this.__indent_count = t4 || 0, this.__alignment_count = e3 || 0, this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count));
      }, _2.prototype._set_wrap_point = function() {
        this.__parent.wrap_line_length && (this.__wrap_point_index = this.__items.length, this.__wrap_point_character_count = this.__character_count, this.__wrap_point_indent_count = this.__parent.next_line.__indent_count, this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count);
      }, _2.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      }, _2.prototype._allow_wrap = function() {
        var t4;
        return !!this._should_wrap() && (this.__parent.add_new_line(), (t4 = this.__parent.current_line).set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count), t4.__items = this.__items.slice(this.__wrap_point_index), this.__items = this.__items.slice(0, this.__wrap_point_index), t4.__character_count += this.__character_count - this.__wrap_point_character_count, this.__character_count = this.__wrap_point_character_count, " " === t4.__items[0] && (t4.__items.splice(0, 1), --t4.__character_count), true);
      }, _2.prototype.is_empty = function() {
        return 0 === this.__items.length;
      }, _2.prototype.last = function() {
        return this.is_empty() ? null : this.__items[this.__items.length - 1];
      }, _2.prototype.push = function(t4) {
        this.__items.push(t4);
        var e3 = t4.lastIndexOf("\\n");
        -1 !== e3 ? this.__character_count = t4.length - e3 : this.__character_count += t4.length;
      }, _2.prototype.pop = function() {
        var t4 = null;
        return this.is_empty() || (t4 = this.__items.pop(), this.__character_count -= t4.length), t4;
      }, _2.prototype._remove_indent = function() {
        0 < this.__indent_count && (--this.__indent_count, this.__character_count -= this.__parent.indent_size);
      }, _2.prototype._remove_wrap_indent = function() {
        0 < this.__wrap_point_indent_count && --this.__wrap_point_indent_count;
      }, _2.prototype.trim = function() {
        for (; " " === this.last(); ) this.__items.pop(), --this.__character_count;
      }, _2.prototype.toString = function() {
        var t4 = "";
        return this.is_empty() ? this.__parent.indent_empty_lines && (t4 = this.__parent.get_indent_string(this.__indent_count)) : (t4 = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count), t4 += this.__items.join("")), t4;
      }, i.prototype.get_indent_size = function(t4, e3) {
        var i2 = this.__base_string_length;
        return i2 = (i2 = t4 < 0 ? 0 : i2) + t4 * this.__indent_size + (e3 = e3 || 0);
      }, i.prototype.get_indent_string = function(t4, e3) {
        var i2 = this.__base_string;
        return e3 = e3 || 0, t4 < 0 && (t4 = 0, i2 = ""), e3 += t4 * this.__indent_size, this.__ensure_cache(e3), i2 += this.__cache[e3];
      }, i.prototype.__ensure_cache = function(t4) {
        for (; t4 >= this.__cache.length; ) this.__add_column();
      }, i.prototype.__add_column = function() {
        var t4, e3 = this.__cache.length, i2 = "";
        this.__indent_size && e3 >= this.__indent_size && (e3 -= (t4 = Math.floor(e3 / this.__indent_size)) * this.__indent_size, i2 = new Array(t4 + 1).join(this.__indent_string)), e3 && (i2 += new Array(e3 + 1).join(" ")), this.__cache.push(i2);
      }, e2.prototype.__add_outputline = function() {
        this.previous_line = this.current_line, this.current_line = this.next_line.clone_empty(), this.__lines.push(this.current_line);
      }, e2.prototype.get_line_number = function() {
        return this.__lines.length;
      }, e2.prototype.get_indent_string = function(t4, e3) {
        return this.__indent_cache.get_indent_string(t4, e3);
      }, e2.prototype.get_indent_size = function(t4, e3) {
        return this.__indent_cache.get_indent_size(t4, e3);
      }, e2.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      }, e2.prototype.add_new_line = function(t4) {
        return !(this.is_empty() || !t4 && this.just_added_newline()) && (this.raw || this.__add_outputline(), true);
      }, e2.prototype.get_code = function(t4) {
        this.trim(true);
        var e3 = this.current_line.pop(), e3 = (e3 && ("\\n" === e3[e3.length - 1] && (e3 = e3.replace(/\\n+\$/g, "")), this.current_line.push(e3)), this._end_with_newline && this.__add_outputline(), this.__lines.join("\\n"));
        return e3 = "\\n" !== t4 ? e3.replace(/[\\n]/g, t4) : e3;
      }, e2.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      }, e2.prototype.set_indent = function(t4, e3) {
        return this.next_line.set_indent(t4 = t4 || 0, e3 = e3 || 0), 1 < this.__lines.length ? (this.current_line.set_indent(t4, e3), true) : (this.current_line.set_indent(), false);
      }, e2.prototype.add_raw_token = function(t4) {
        for (var e3 = 0; e3 < t4.newlines; e3++) this.__add_outputline();
        this.current_line.set_indent(-1), this.current_line.push(t4.whitespace_before), this.current_line.push(t4.text), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = false;
      }, e2.prototype.add_token = function(t4) {
        this.__add_space_before_token(), this.current_line.push(t4), this.space_before_token = false, this.non_breaking_space = false, this.previous_token_wrapped = this.current_line._allow_wrap();
      }, e2.prototype.__add_space_before_token = function() {
        this.space_before_token && !this.just_added_newline() && (this.non_breaking_space || this.set_wrap_point(), this.current_line.push(" "));
      }, e2.prototype.remove_indent = function(t4) {
        for (var e3 = this.__lines.length; t4 < e3; ) this.__lines[t4]._remove_indent(), t4++;
        this.current_line._remove_wrap_indent();
      }, e2.prototype.trim = function(t4) {
        for (t4 = void 0 !== t4 && t4, this.current_line.trim(); t4 && 1 < this.__lines.length && this.current_line.is_empty(); ) this.__lines.pop(), this.current_line = this.__lines[this.__lines.length - 1], this.current_line.trim();
        this.previous_line = 1 < this.__lines.length ? this.__lines[this.__lines.length - 2] : null;
      }, e2.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      }, e2.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      }, e2.prototype.ensure_empty_line_above = function(t4, e3) {
        for (var i2 = this.__lines.length - 2; 0 <= i2; ) {
          var n2 = this.__lines[i2];
          if (n2.is_empty()) break;
          if (0 !== n2.item(0).indexOf(t4) && n2.item(-1) !== e3) {
            this.__lines.splice(i2 + 1, 0, new _2(this)), this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          i2--;
        }
      }, t3.exports.Output = e2;
    }, , , , function(t3) {
      function e2(t4, e3) {
        this.raw_options = i(t4, e3), this.disabled = this._get_boolean("disabled"), this.eol = this._get_characters("eol", "auto"), this.end_with_newline = this._get_boolean("end_with_newline"), this.indent_size = this._get_number("indent_size", 4), this.indent_char = this._get_characters("indent_char", " "), this.indent_level = this._get_number("indent_level"), this.preserve_newlines = this._get_boolean("preserve_newlines", true), this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786), this.preserve_newlines || (this.max_preserve_newlines = 0), this.indent_with_tabs = this._get_boolean("indent_with_tabs", "	" === this.indent_char), this.indent_with_tabs && (this.indent_char = "	", 1 === this.indent_size && (this.indent_size = 4)), this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char")), this.indent_empty_lines = this._get_boolean("indent_empty_lines"), this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      function i(t4, e3) {
        var i2, n2 = {};
        for (i2 in t4 = _2(t4)) i2 !== e3 && (n2[i2] = t4[i2]);
        if (e3 && t4[e3]) for (i2 in t4[e3]) n2[i2] = t4[e3][i2];
        return n2;
      }
      function _2(t4) {
        var e3, i2 = {};
        for (e3 in t4) i2[e3.replace(/-/g, "_")] = t4[e3];
        return i2;
      }
      e2.prototype._get_array = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || [];
        return "object" == typeof t4 ? null !== t4 && "function" == typeof t4.concat && (e3 = t4.concat()) : "string" == typeof t4 && (e3 = t4.split(/[^a-zA-Z0-9_\\/\\-]+/)), e3;
      }, e2.prototype._get_boolean = function(t4, e3) {
        t4 = this.raw_options[t4];
        return void 0 === t4 ? !!e3 : !!t4;
      }, e2.prototype._get_characters = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = e3 || "";
        return e3 = "string" == typeof t4 ? t4.replace(/\\\\r/, "\\r").replace(/\\\\n/, "\\n").replace(/\\\\t/, "	") : e3;
      }, e2.prototype._get_number = function(t4, e3) {
        t4 = this.raw_options[t4], e3 = parseInt(e3, 10), isNaN(e3) && (e3 = 0), t4 = parseInt(t4, 10);
        return t4 = isNaN(t4) ? e3 : t4;
      }, e2.prototype._get_selection = function(t4, e3, i2) {
        i2 = this._get_selection_list(t4, e3, i2);
        if (1 !== i2.length) throw new Error("Invalid Option Value: The option '" + t4 + "' can only be one of the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
        return i2[0];
      }, e2.prototype._get_selection_list = function(t4, e3, i2) {
        if (!e3 || 0 === e3.length) throw new Error("Selection list cannot be empty.");
        if (i2 = i2 || [e3[0]], !this._is_valid_selection(i2, e3)) throw new Error("Invalid Default Value!");
        i2 = this._get_array(t4, i2);
        if (this._is_valid_selection(i2, e3)) return i2;
        throw new Error("Invalid Option Value: The option '" + t4 + "' can contain only the following values:\\n" + e3 + "\\nYou passed in: '" + this.raw_options[t4] + "'");
      }, e2.prototype._is_valid_selection = function(t4, e3) {
        return t4.length && e3.length && !t4.some(function(t5) {
          return -1 === e3.indexOf(t5);
        });
      }, t3.exports.Options = e2, t3.exports.normalizeOpts = _2, t3.exports.mergeOpts = i;
    }, , function(t3) {
      var n2 = RegExp.prototype.hasOwnProperty("sticky");
      function e2(t4) {
        this.__input = t4 || "", this.__input_length = this.__input.length, this.__position = 0;
      }
      e2.prototype.restart = function() {
        this.__position = 0;
      }, e2.prototype.back = function() {
        0 < this.__position && --this.__position;
      }, e2.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      }, e2.prototype.next = function() {
        var t4 = null;
        return this.hasNext() && (t4 = this.__input.charAt(this.__position), this.__position += 1), t4;
      }, e2.prototype.peek = function(t4) {
        var e3 = null;
        return t4 = t4 || 0, e3 = 0 <= (t4 += this.__position) && t4 < this.__input_length ? this.__input.charAt(t4) : e3;
      }, e2.prototype.__match = function(t4, e3) {
        t4.lastIndex = e3;
        var i = t4.exec(this.__input);
        return !i || n2 && t4.sticky || i.index !== e3 && (i = null), i;
      }, e2.prototype.test = function(t4, e3) {
        return e3 = e3 || 0, 0 <= (e3 += this.__position) && e3 < this.__input_length && !!this.__match(t4, e3);
      }, e2.prototype.testChar = function(t4, e3) {
        e3 = this.peek(e3);
        return t4.lastIndex = 0, null !== e3 && t4.test(e3);
      }, e2.prototype.match = function(t4) {
        t4 = this.__match(t4, this.__position);
        return t4 ? this.__position += t4[0].length : t4 = null, t4;
      }, e2.prototype.read = function(t4, e3, i) {
        var n3, _2 = "";
        return t4 && (n3 = this.match(t4)) && (_2 += n3[0]), !e3 || !n3 && t4 || (_2 += this.readUntil(e3, i)), _2;
      }, e2.prototype.readUntil = function(t4, e3) {
        var i = this.__position, t4 = (t4.lastIndex = this.__position, t4.exec(this.__input));
        return t4 ? (i = t4.index, e3 && (i += t4[0].length)) : i = this.__input_length, e3 = this.__input.substring(this.__position, i), this.__position = i, e3;
      }, e2.prototype.readUntilAfter = function(t4) {
        return this.readUntil(t4, true);
      }, e2.prototype.get_regexp = function(t4, e3) {
        var i = null, e3 = e3 && n2 ? "y" : "g";
        return "string" == typeof t4 && "" !== t4 ? i = new RegExp(t4, e3) : t4 && (i = new RegExp(t4.source, e3)), i;
      }, e2.prototype.get_literal_regexp = function(t4) {
        return RegExp(t4.replace(/[-\\/\\\\^\$*+?.()|[\\]{}]/g, "\\\\\$&"));
      }, e2.prototype.peekUntilAfter = function(t4) {
        var e3 = this.__position, t4 = this.readUntilAfter(t4);
        return this.__position = e3, t4;
      }, e2.prototype.lookBack = function(t4) {
        var e3 = this.__position - 1;
        return e3 >= t4.length && this.__input.substring(e3 - t4.length, e3).toLowerCase() === t4;
      }, t3.exports.InputScanner = e2;
    }, , , , , function(t3) {
      function e2(t4, e3) {
        t4 = "string" == typeof t4 ? t4 : t4.source, e3 = "string" == typeof e3 ? e3 : e3.source, this.__directives_block_pattern = new RegExp(t4 + / beautify( \\w+[:]\\w+)+ /.source + e3, "g"), this.__directive_pattern = / (\\w+)[:](\\w+)/g, this.__directives_end_ignore_pattern = new RegExp(t4 + /\\sbeautify\\signore:end\\s/.source + e3, "g");
      }
      e2.prototype.get_directives = function(t4) {
        if (!t4.match(this.__directives_block_pattern)) return null;
        for (var e3 = {}, i = (this.__directive_pattern.lastIndex = 0, this.__directive_pattern.exec(t4)); i; ) e3[i[1]] = i[2], i = this.__directive_pattern.exec(t4);
        return e3;
      }, e2.prototype.readIgnored = function(t4) {
        return t4.readUntilAfter(this.__directives_end_ignore_pattern);
      }, t3.exports.Directives = e2;
    }, , function(t3, e2, i) {
      var n2 = i(16).Beautifier, _2 = i(17).Options;
      t3.exports = function(t4, e3) {
        return new n2(t4, e3).beautify();
      }, t3.exports.defaultOptions = function() {
        return new _2();
      };
    }, function(t3, e2, i) {
      var n2 = i(17).Options, w = i(2).Output, y = i(8).InputScanner, v2 = new (i(13)).Directives(/\\/\\*/, /\\*\\//), m = /\\r\\n|[\\r\\n]/, b = /\\r\\n|[\\r\\n]/g, k = /\\s/, x = /(?:\\s|\\n)+/g, O = /\\/\\*(?:[\\s\\S]*?)((?:\\*\\/)|\$)/g, S = /\\/\\/(?:[^\\n\\r\\u2028\\u2029]*)/g;
      function _2(t4, e3) {
        this._source_text = t4 || "", this._options = new n2(e3), this._ch = null, this._input = null, this.NESTED_AT_RULE = { page: true, "font-face": true, keyframes: true, media: true, supports: true, document: true }, this.CONDITIONAL_GROUP_RULE = { media: true, supports: true, document: true }, this.NON_SEMICOLON_NEWLINE_PROPERTY = ["grid-template-areas", "grid-template"];
      }
      _2.prototype.eatString = function(t4) {
        var e3 = "";
        for (this._ch = this._input.next(); this._ch; ) {
          if (e3 += this._ch, "\\\\" === this._ch) e3 += this._input.next();
          else if (-1 !== t4.indexOf(this._ch) || "\\n" === this._ch) break;
          this._ch = this._input.next();
        }
        return e3;
      }, _2.prototype.eatWhitespace = function(t4) {
        for (var e3 = k.test(this._input.peek()), i2 = 0; k.test(this._input.peek()); ) this._ch = this._input.next(), t4 && "\\n" === this._ch && (0 === i2 || i2 < this._options.max_preserve_newlines) && (i2++, this._output.add_new_line(true));
        return e3;
      }, _2.prototype.foundNestedPseudoClass = function() {
        for (var t4 = 0, e3 = 1, i2 = this._input.peek(e3); i2; ) {
          if ("{" === i2) return true;
          if ("(" === i2) t4 += 1;
          else if (")" === i2) {
            if (0 === t4) return false;
            --t4;
          } else if (";" === i2 || "}" === i2) return false;
          e3++, i2 = this._input.peek(e3);
        }
        return false;
      }, _2.prototype.print_string = function(t4) {
        this._output.set_indent(this._indentLevel), this._output.non_breaking_space = true, this._output.add_token(t4);
      }, _2.prototype.preserveSingleSpace = function(t4) {
        t4 && (this._output.space_before_token = true);
      }, _2.prototype.indent = function() {
        this._indentLevel++;
      }, _2.prototype.outdent = function() {
        0 < this._indentLevel && this._indentLevel--;
      }, _2.prototype.beautify = function() {
        if (this._options.disabled) return this._source_text;
        for (var t4, e3, i2, n3 = this._source_text, _3 = this._options.eol, s = ("auto" === _3 && (_3 = "\\n", n3 && m.test(n3 || "") && (_3 = n3.match(m)[0])), (n3 = n3.replace(b, "\\n")).match(/^[\\t ]*/)[0]), r = (this._output = new w(this._options, s), this._input = new y(n3), this._indentLevel = 0, this._nestedLevel = 0, this._ch = null, 0), h = false, o = false, p = false, a = false, u = false, c = this._ch, l = false; t4 = "" !== this._input.read(x), e3 = c, this._ch = this._input.next(), "\\\\" === this._ch && this._input.hasNext() && (this._ch += this._input.next()), c = this._ch, this._ch; ) if ("/" === this._ch && "*" === this._input.peek()) {
          this._output.add_new_line(), this._input.back();
          var d = this._input.read(O), f = v2.get_directives(d);
          f && "start" === f.ignore && (d += v2.readIgnored(this._input)), this.print_string(d), this.eatWhitespace(true), this._output.add_new_line();
        } else if ("/" === this._ch && "/" === this._input.peek()) this._output.space_before_token = true, this._input.back(), this.print_string(this._input.read(S)), this.eatWhitespace(true);
        else if ("\$" === this._ch) {
          this.preserveSingleSpace(t4), this.print_string(this._ch);
          f = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='"]/g);
          f.match(/[ :]\$/) && (f = this.eatString(": ").replace(/\\s+\$/, ""), this.print_string(f), this._output.space_before_token = true), 0 === r && -1 !== f.indexOf(":") && (o = true, this.indent());
        } else if ("@" === this._ch) this.preserveSingleSpace(t4), "{" === this._input.peek() ? this.print_string(this._ch + this.eatString("}")) : (this.print_string(this._ch), (d = this._input.peekUntilAfter(/[: ,;{}()[\\]\\/='"]/g)).match(/[ :]\$/) && (d = this.eatString(": ").replace(/\\s+\$/, ""), this.print_string(d), this._output.space_before_token = true), 0 === r && -1 !== d.indexOf(":") ? (o = true, this.indent()) : d in this.NESTED_AT_RULE ? (this._nestedLevel += 1, d in this.CONDITIONAL_GROUP_RULE && (p = true)) : 0 !== r || o || (a = true));
        else if ("#" === this._ch && "{" === this._input.peek()) this.preserveSingleSpace(t4), this.print_string(this._ch + this.eatString("}"));
        else if ("{" === this._ch) o && (o = false, this.outdent()), a = false, h = p ? (p = false, this._indentLevel >= this._nestedLevel) : this._indentLevel >= this._nestedLevel - 1, this._options.newline_between_rules && h && this._output.previous_line && "{" !== this._output.previous_line.item(-1) && this._output.ensure_empty_line_above("/", ","), this._output.space_before_token = true, "expand" === this._options.brace_style ? (this._output.add_new_line(), this.print_string(this._ch), this.indent(), this._output.set_indent(this._indentLevel)) : ("(" === e3 ? this._output.space_before_token = false : "," !== e3 && this.indent(), this.print_string(this._ch)), this.eatWhitespace(true), this._output.add_new_line();
        else if ("}" === this._ch) this.outdent(), this._output.add_new_line(), "{" === e3 && this._output.trim(true), o && (this.outdent(), o = false), this.print_string(this._ch), h = false, this._nestedLevel && this._nestedLevel--, this.eatWhitespace(true), this._output.add_new_line(), this._options.newline_between_rules && !this._output.just_added_blankline() && "}" !== this._input.peek() && this._output.add_new_line(true), ")" === this._input.peek() && (this._output.trim(true), "expand" === this._options.brace_style && this._output.add_new_line(true));
        else if (":" === this._ch) {
          for (var g = 0; g < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; g++) if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[g])) {
            l = true;
            break;
          }
          !h && !p || this._input.lookBack("&") || this.foundNestedPseudoClass() || this._input.lookBack("(") || a || 0 !== r ? (this._input.lookBack(" ") && (this._output.space_before_token = true), ":" === this._input.peek() ? (this._ch = this._input.next(), this.print_string("::")) : this.print_string(":")) : (this.print_string(":"), o || (this._output.space_before_token = o = true, this.eatWhitespace(true), this.indent()));
        } else '"' === this._ch || "'" === this._ch ? (this.preserveSingleSpace('"' === e3 || "'" === e3 || t4), this.print_string(this._ch + this.eatString(this._ch)), this.eatWhitespace(true)) : ";" === this._ch ? (l = false, 0 === r ? (o && (this.outdent(), o = false), a = false, this.print_string(this._ch), this.eatWhitespace(true), "/" !== this._input.peek() && this._output.add_new_line()) : (this.print_string(this._ch), this.eatWhitespace(true), this._output.space_before_token = true)) : "(" === this._ch ? this._input.lookBack("url") ? (this.print_string(this._ch), this.eatWhitespace(), r++, this.indent(), this._ch = this._input.next(), ")" === this._ch || '"' === this._ch || "'" === this._ch ? this._input.back() : this._ch && (this.print_string(this._ch + this.eatString(")")), r && (r--, this.outdent()))) : (i2 = false, this._input.lookBack("with") && (i2 = true), this.preserveSingleSpace(t4 || i2), this.print_string(this._ch), o && "\$" === e3 && this._options.selector_separator_newline ? (this._output.add_new_line(), u = true) : (this.eatWhitespace(), r++, this.indent())) : ")" === this._ch ? (r && (r--, this.outdent()), u && ";" === this._input.peek() && this._options.selector_separator_newline && (u = false, this.outdent(), this._output.add_new_line()), this.print_string(this._ch)) : "," === this._ch ? (this.print_string(this._ch), this.eatWhitespace(true), !this._options.selector_separator_newline || o && !u || 0 !== r || a ? this._output.space_before_token = true : this._output.add_new_line()) : ">" !== this._ch && "+" !== this._ch && "~" !== this._ch || o || 0 !== r ? "]" === this._ch ? this.print_string(this._ch) : "[" === this._ch ? (this.preserveSingleSpace(t4), this.print_string(this._ch)) : "=" === this._ch ? (this.eatWhitespace(), this.print_string("="), k.test(this._ch) && (this._ch = "")) : "!" !== this._ch || this._input.lookBack("\\\\") ? (this.preserveSingleSpace('"' === e3 || "'" === e3 || t4), this.print_string(this._ch), !this._output.just_added_newline() && "\\n" === this._input.peek() && l && this._output.add_new_line()) : (this._output.space_before_token = true, this.print_string(this._ch)) : this._options.space_around_combinator ? (this._output.space_before_token = true, this.print_string(this._ch), this._output.space_before_token = true) : (this.print_string(this._ch), this.eatWhitespace(), this._ch && k.test(this._ch) && (this._ch = ""));
        return this._output.get_code(_3);
      }, t3.exports.Beautifier = _2;
    }, function(t3, e2, i) {
      var n2 = i(6).Options;
      function _2(t4) {
        n2.call(this, t4, "css"), this.selector_separator_newline = this._get_boolean("selector_separator_newline", true), this.newline_between_rules = this._get_boolean("newline_between_rules", true);
        var t4 = this._get_boolean("space_around_selector_separator"), e3 = (this.space_around_combinator = this._get_boolean("space_around_combinator") || t4, this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]));
        this.brace_style = "collapse";
        for (var i2 = 0; i2 < e3.length; i2++) "expand" !== e3[i2] ? this.brace_style = "collapse" : this.brace_style = e3[i2];
      }
      _2.prototype = new n2(), t3.exports.Options = _2;
    }], _ = {};
    var t2 = function t3(e2) {
      var i = _[e2];
      if (void 0 !== i) return i.exports;
      i = _[e2] = { exports: {} };
      return n[e2](i, i.exports, t3), i.exports;
    }(15);
    e = t2;
  }();
  var e, t = e;
  "function" == typeof define && define.amd ? define([], function() {
    return { css_beautify: t };
  }) : "undefined" != typeof exports ? exports.css_beautify = t : "undefined" != typeof window ? window.css_beautify = t : "undefined" != typeof global && (global.css_beautify = t);
}();
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineSimpleMode = function(name, states) {
    CodeMirror2.defineMode(name, function(config) {
      return CodeMirror2.simpleMode(config, states);
    });
  };
  CodeMirror2.simpleMode = function(config, states) {
    ensureState(states, "start");
    var states_ = {}, meta2 = states.meta || {}, hasIndentation = false;
    for (var state in states) if (state != meta2 && states.hasOwnProperty(state)) {
      var list = states_[state] = [], orig = states[state];
      for (var i = 0; i < orig.length; i++) {
        var data = orig[i];
        list.push(new Rule(data, states));
        if (data.indent || data.dedent) hasIndentation = true;
      }
    }
    var mode = {
      startState: function() {
        return {
          state: "start",
          pending: null,
          local: null,
          localState: null,
          indent: hasIndentation ? [] : null
        };
      },
      copyState: function(state2) {
        var s = {
          state: state2.state,
          pending: state2.pending,
          local: state2.local,
          localState: null,
          indent: state2.indent && state2.indent.slice(0)
        };
        if (state2.localState)
          s.localState = CodeMirror2.copyState(state2.local.mode, state2.localState);
        if (state2.stack)
          s.stack = state2.stack.slice(0);
        for (var pers = state2.persistentStates; pers; pers = pers.next)
          s.persistentStates = {
            mode: pers.mode,
            spec: pers.spec,
            state: pers.state == state2.localState ? s.localState : CodeMirror2.copyState(pers.mode, pers.state),
            next: s.persistentStates
          };
        return s;
      },
      token: tokenFunction(states_, config),
      innerMode: function(state2) {
        return state2.local && { mode: state2.local.mode, state: state2.localState };
      },
      indent: indentFunction(states_, meta2)
    };
    if (meta2) {
      for (var prop in meta2) if (meta2.hasOwnProperty(prop))
        mode[prop] = meta2[prop];
    }
    return mode;
  };
  function ensureState(states, name) {
    if (!states.hasOwnProperty(name))
      throw new Error("Undefined state " + name + " in simple mode");
  }
  function toRegex(val, caret) {
    if (!val) return /(?:)/;
    var flags = "";
    if (val instanceof RegExp) {
      if (val.ignoreCase) flags = "i";
      if (val.unicode) flags += "u";
      val = val.source;
    } else {
      val = String(val);
    }
    return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
  }
  function asToken(val) {
    if (!val) return null;
    if (val.apply) return val;
    if (typeof val == "string") return val.replace(/\\./g, " ");
    var result = [];
    for (var i = 0; i < val.length; i++)
      result.push(val[i] && val[i].replace(/\\./g, " "));
    return result;
  }
  function Rule(data, states) {
    if (data.next || data.push) ensureState(states, data.next || data.push);
    this.regex = toRegex(data.regex);
    this.token = asToken(data.token);
    this.data = data;
  }
  function tokenFunction(states, config) {
    return function(stream, state) {
      if (state.pending) {
        var pend = state.pending.shift();
        if (state.pending.length == 0) state.pending = null;
        stream.pos += pend.text.length;
        return pend.token;
      }
      if (state.local) {
        if (state.local.end && stream.match(state.local.end)) {
          var tok = state.local.endToken || null;
          state.local = state.localState = null;
          return tok;
        } else {
          var tok = state.local.mode.token(stream, state.localState), m;
          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))
            stream.pos = stream.start + m.index;
          return tok;
        }
      }
      var curState = states[state.state];
      for (var i = 0; i < curState.length; i++) {
        var rule = curState[i];
        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
        if (matches) {
          if (rule.data.next) {
            state.state = rule.data.next;
          } else if (rule.data.push) {
            (state.stack || (state.stack = [])).push(state.state);
            state.state = rule.data.push;
          } else if (rule.data.pop && state.stack && state.stack.length) {
            state.state = state.stack.pop();
          }
          if (rule.data.mode)
            enterLocalMode(config, state, rule.data.mode, rule.token);
          if (rule.data.indent)
            state.indent.push(stream.indentation() + config.indentUnit);
          if (rule.data.dedent)
            state.indent.pop();
          var token = rule.token;
          if (token && token.apply) token = token(matches);
          if (matches.length > 2 && rule.token && typeof rule.token != "string") {
            for (var j = 2; j < matches.length; j++)
              if (matches[j])
                (state.pending || (state.pending = [])).push({ text: matches[j], token: rule.token[j - 1] });
            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
            return token[0];
          } else if (token && token.join) {
            return token[0];
          } else {
            return token;
          }
        }
      }
      stream.next();
      return null;
    };
  }
  function cmp(a, b) {
    if (a === b) return true;
    if (!a || typeof a != "object" || !b || typeof b != "object") return false;
    var props = 0;
    for (var prop in a) if (a.hasOwnProperty(prop)) {
      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;
      props++;
    }
    for (var prop in b) if (b.hasOwnProperty(prop)) props--;
    return props == 0;
  }
  function enterLocalMode(config, state, spec, token) {
    var pers;
    if (spec.persistent) {
      for (var p = state.persistentStates; p && !pers; p = p.next)
        if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;
    }
    var mode = pers ? pers.mode : spec.mode || CodeMirror2.getMode(config, spec.spec);
    var lState = pers ? pers.state : CodeMirror2.startState(mode);
    if (spec.persistent && !pers)
      state.persistentStates = { mode, spec: spec.spec, state: lState, next: state.persistentStates };
    state.localState = lState;
    state.local = {
      mode,
      end: spec.end && toRegex(spec.end),
      endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),
      endToken: token && token.join ? token[token.length - 1] : token
    };
  }
  function indexOf(val, arr) {
    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;
  }
  function indentFunction(states, meta2) {
    return function(state, textAfter, line) {
      if (state.local && state.local.mode.indent)
        return state.local.mode.indent(state.localState, textAfter, line);
      if (state.indent == null || state.local || meta2.dontIndentStates && indexOf(state.state, meta2.dontIndentStates) > -1)
        return CodeMirror2.Pass;
      var pos = state.indent.length - 1, rules = states[state.state];
      scan: for (; ; ) {
        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i];
          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
            var m = rule.regex.exec(textAfter);
            if (m && m[0]) {
              pos--;
              if (rule.next || rule.push) rules = states[rule.next || rule.push];
              textAfter = textAfter.slice(m[0].length);
              continue scan;
            }
          }
        }
        break;
      }
      return pos < 0 ? 0 : state.indent[pos];
    };
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  const escapeLetters = ["س", "ر", "ج"];
  const easternHexLetters = ["ا", "ب", "ج", "د", "ه", "و"];
  const escapeLettersPatterns = escapeLetters.map((c) => tatweelRegex(c)).join("");
  const easternHexLetter = \`[\${easternHexLetters.map((c) => tatweelRegex(c)).join("")}]\`;
  const westernHexLetter = \`[a-fA-F]\`;
  const escapeChar = \`[\${escapeLettersPatterns}›»]\`;
  const unicodePrefix = tatweelRegex("م");
  const easternUnicode = \`(?:\${unicodePrefix}\${openCurly}(?:\${easternDigit}|\${easternHexLetter}){1,6}\${closeCurly})\`;
  const westernUnicode = \`(?:\${unicodePrefix}\${openCurly}(?:\${westernDigit}|\${westernHexLetter}){1,6}\${closeCurly})\`;
  const unicode = \`(?:\${easternUnicode}|\${westernUnicode})\`;
  const noCloseQuoteOrSlash = \`[^›\${slash}]\`;
  const wordsToRegex = (WORDS) => RegExp(anyWord(WORDS), "u");
  const anyWord = (WORDS) => {
    let res = [];
    Object.values(WORDS).forEach((v2) => res.push(tatweelRegex(v2.ar)));
    return \`(?:\${res.join("|")})\`;
  };
  const startMultilineComment = () => RegExp(\`\${openCurly}-\`, "u");
  const multilineComment = () => RegExp(\`.*\`, "u");
  const closeMultilineComment = () => RegExp(\`.*?-\${closeCurly}\`, "u");
  const comment = () => RegExp(\`--.*\`, "u");
  const escape = \`\${slash}(?:\${escapeChar}|\${unicode})\`;
  const char = () => RegExp(\`‹(?:\${noCloseQuoteOrSlash}|\${escape})›\`, "u");
  const startMultilineString = () => RegExp(\`b?«««\`, "u");
  const multilineString = () => RegExp(\`(?:[^»]|»(?!»»))*\`, "u");
  const endMultilineString = () => RegExp(\`»»»\`, "u");
  const startString = () => RegExp(\`b?«\`, "u");
  const string = () => RegExp(\`(?:[^\${slash}»]|\${slash}(?:.|\$))*\`, "u");
  const endString = () => RegExp(\`»\`, "u");
  const number = () => RegExp(\`(?:\${easternFloat})|(?:\${westernFloat})\`, "u");
  const variableRegex = () => RegExp(\`(?!\${anyWord(RESERVED)}(?:\${notIdPart}|\\\\s|\$))\${id}\`, "u");
  const keywordRegex = () => wordsToRegex(KEYWORDS);
  const atomRegex = () => wordsToRegex(ATOMS);
  const builtinRegex = () => wordsToRegex(BUILTINS);
  CodeMirror2.defineSimpleMode("seen-ar", {
    start: [
      { regex: startMultilineComment(), token: "comment", next: "multiline_comment" },
      { regex: comment(), token: "comment" },
      { regex: startMultilineString(), token: "string", next: "multiline_string" },
      { regex: startString(), token: "string", next: "string" },
      { regex: char(), token: "string-2" },
      { regex: number(), token: "number" },
      ...commonStartRules,
      { regex: variableRegex(), token: "variable" },
      { regex: keywordRegex(), token: "keyword" },
      { regex: atomRegex(), token: "atom" },
      { regex: builtinRegex(), token: "builtin" }
    ],
    multiline_comment: [
      { regex: closeMultilineComment(), token: "comment", next: "start" },
      { regex: multilineComment(), token: "comment" }
    ],
    multiline_string: [
      { regex: endMultilineString(), token: "string", next: "start" },
      { regex: multilineString(), token: "string" }
    ],
    string: [
      { regex: endString(), token: "string", next: "start" },
      { regex: string(), token: "string" }
    ],
    meta
  });
  CodeMirror2.defineMIME("text/x-seen-ar-src", "seen-ar");
  CodeMirror2.defineMIME("text/seen-ar", "seen-ar");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  const escapeChar = \`[nrt'"]\`;
  const unicode = \`u\${openCurly}[\\\\da-fA-F]{1,6}\${closeCurly}\`;
  const noQuoteOrBslash = \`[^'\${backslash}]\`;
  function wordsToRegex(WORDS) {
    let res = [];
    Object.values(WORDS).forEach((v2) => res.push(v2.en));
    return RegExp(\`\\\\b(?:\${res.join("|")})\\\\b\`);
  }
  const startMultilineComment = () => RegExp(\`\${openCurly}\${dash}\`);
  const multilineComment = () => RegExp(\`.*\`);
  const closeMultilineComment = () => RegExp(\`.*?\${dash}\${closeCurly}\`);
  const comment = () => RegExp(\`\${dash}\${dash}.*\`);
  const escape = \`\${backslash}(?:\${escapeChar}|\${unicode})\`;
  const char = () => RegExp(\`'(?:\${noQuoteOrBslash}|\${escape})'\`);
  const startMultilineString = () => RegExp(\`b?"""\`);
  const multilineString = () => RegExp(\`(?:[^"]|"(?!""))*\`);
  const endMultilineString = () => RegExp(\`"""\`);
  const startString = () => RegExp(\`b?'\`);
  const string = () => RegExp(\`(?:\${noQuoteOrBslash}|\${backslash}(?:.|\$))*\`);
  const endString = () => RegExp(\`'\`);
  const number = () => RegExp(\`(?:\${westernFloat})\`);
  const variableRegex = () => RegExp(\`\${id}\`, "u");
  const keywordRegex = () => wordsToRegex(KEYWORDS);
  const atomRegex = () => wordsToRegex(ATOMS);
  const builtinRegex = () => wordsToRegex(BUILTINS);
  CodeMirror2.defineSimpleMode("seen-en", {
    start: [
      { regex: startMultilineComment(), token: "comment", next: "multiline_comment" },
      { regex: comment(), token: "comment" },
      { regex: startMultilineString(), token: "string", next: "multiline_string" },
      { regex: startString(), token: "string", next: "string" },
      { regex: char(), token: "string-2" },
      { regex: number(), token: "number" },
      ...commonStartRules,
      { regex: keywordRegex(), token: "keyword" },
      { regex: atomRegex(), token: "atom" },
      { regex: builtinRegex(), token: "builtin" },
      { regex: variableRegex(), token: "variable" }
    ],
    multiline_comment: [
      { regex: closeMultilineComment(), token: "comment", next: "start" },
      { regex: multilineComment(), token: "comment" }
    ],
    multiline_string: [
      { regex: endMultilineString(), token: "string", next: "start" },
      { regex: multilineString(), token: "string" }
    ],
    string: [
      { regex: endString(), token: "string", next: "start" },
      { regex: string(), token: "string" }
    ],
    meta
  });
  CodeMirror2.defineMIME("text/x-seen-en-src", "seen-en");
  CodeMirror2.defineMIME("text/seen-en", "seen-en");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineMode("javascript", function(config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var trackScope = parserConfig.trackScope !== false;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\\w\$\\xa1-\\uffff]/;
    var keywords = function() {
      function kw(type3) {
        return { type: type3, style: "keyword" };
      }
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
      var operator = kw("operator"), atom = { type: "atom", style: "atom" };
      return {
        "if": kw("if"),
        "while": A,
        "with": A,
        "else": B,
        "do": B,
        "try": B,
        "finally": B,
        "return": D,
        "break": D,
        "continue": D,
        "new": kw("new"),
        "delete": C,
        "void": C,
        "throw": C,
        "debugger": kw("debugger"),
        "var": kw("var"),
        "const": kw("var"),
        "let": kw("var"),
        "function": kw("function"),
        "catch": kw("catch"),
        "for": kw("for"),
        "switch": kw("switch"),
        "case": kw("case"),
        "default": kw("default"),
        "in": operator,
        "typeof": operator,
        "instanceof": operator,
        "true": atom,
        "false": atom,
        "null": atom,
        "undefined": atom,
        "NaN": atom,
        "Infinity": atom,
        "this": kw("this"),
        "class": kw("class"),
        "super": kw("atom"),
        "yield": C,
        "export": kw("export"),
        "import": kw("import"),
        "extends": C,
        "await": C
      };
    }();
    var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet) return;
          if (next == "[") inSet = true;
          else if (inSet && next == "]") inSet = false;
        }
        escaped = !escaped && next == "\\\\";
      }
    }
    var type2, content;
    function ret(tp, style, cont2) {
      type2 = tp;
      content = cont2;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "0" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
        return ret("number", "number");
      } else if (/\\d/.test(ch)) {
        stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("*")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, 1)) {
          readRegexp(stream);
          stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);
          return ret("regexp", "string-2");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "\`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "#" && stream.peek() == "!") {
        stream.skipToEnd();
        return ret("meta", "meta");
      } else if (ch == "#" && stream.eatWhile(wordRE)) {
        return ret("variable", "property");
      } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\\S/.test(stream.string.slice(0, stream.start))) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=") stream.eat("=");
          } else if (/[<>*+\\-|&?]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">") stream.eat(ch);
          }
        }
        if (ch == "?" && stream.eat(".")) return ret(".");
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();
        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }
          if (word == "async" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))
            return ret("async", "keyword", word);
        }
        return ret("variable", "variable", word);
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped) break;
          escaped = !escaped && next == "\\\\";
        }
        if (!escaped) state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = ch == "*";
      }
      return ret("comment", "comment");
    }
    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "\`" || next == "\$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\\\";
      }
      return ret("quasi", "string-2", stream.current());
    }
    var brackets = "([{}])";
    function findFatArrow(stream, state) {
      if (state.fatArrowAt) state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < 0) return;
      if (isTS) {
        var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*\$/.exec(stream.string.slice(stream.start, arrow));
        if (m) arrow = m.index;
      }
      var depth = 0, sawSomething = false;
      for (var pos = arrow - 1; pos >= 0; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >= 0 && bracket < 3) {
          if (!depth) {
            ++pos;
            break;
          }
          if (--depth == 0) {
            if (ch == "(") sawSomething = true;
            break;
          }
        } else if (bracket >= 3 && bracket < 6) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\\/\`]/.test(ch)) {
          for (; ; --pos) {
            if (pos == 0) return;
            var next = stream.string.charAt(pos - 1);
            if (next == ch && stream.string.charAt(pos - 2) != "\\\\") {
              pos--;
              break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth) state.fatArrowAt = pos;
    }
    var atomicTypes = {
      "atom": true,
      "number": true,
      "variable": true,
      "string": true,
      "regexp": true,
      "this": true,
      "import": true,
      "jsonld-keyword": true
    };
    function JSLexical(indented, column, type3, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type3;
      this.prev = prev;
      this.info = info;
      if (align != null) this.align = align;
    }
    function inScope(state, varname) {
      if (!trackScope) return false;
      for (var v2 = state.localVars; v2; v2 = v2.next)
        if (v2.name == varname) return true;
      for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
        for (var v2 = cx2.vars; v2; v2 = v2.next)
          if (v2.name == varname) return true;
      }
    }
    function parseJS(state, style, type3, content2, stream) {
      var cc = state.cc;
      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;
      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type3, content2)) {
          while (cc.length && cc[cc.length - 1].lex)
            cc.pop()();
          if (cx.marked) return cx.marked;
          if (type3 == "variable" && inScope(state, content2)) return "variable-2";
          return style;
        }
      }
    }
    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name, list) {
      for (var v2 = list; v2; v2 = v2.next) if (v2.name == name) return true;
      return false;
    }
    function register(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (!trackScope) return;
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          var newContext = registerVarScoped(varname, state.context);
          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      }
      if (parserConfig.globalVars && !inList(varname, state.globalVars))
        state.globalVars = new Var(varname, state.globalVars);
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner) return null;
        if (inner == context.prev) return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }
    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    }
    function Context(prev, vars, block2) {
      this.prev = prev;
      this.vars = vars;
      this.block = block2;
    }
    function Var(name, next) {
      this.name = name;
      this.next = next;
    }
    var defaultVars = new Var("this", new Var("arguments", null));
    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }
    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }
    pushcontext.lex = pushblockcontext.lex = true;
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    popcontext.lex = true;
    function pushlex(type3, info) {
      var result = function() {
        var state = cx.state, indent2 = state.indented;
        if (state.lexical.type == "stat") indent2 = state.lexical.indented;
        else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
          indent2 = outer.indented;
        state.lexical = new JSLexical(indent2, cx.stream.column(), type3, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;
    function expect(wanted) {
      function exp(type3) {
        if (type3 == wanted) return cont();
        else if (wanted == ";" || type3 == "}" || type3 == ")" || type3 == "]") return pass();
        else return cont(exp);
      }
      return exp;
    }
    function statement(type3, value) {
      if (type3 == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type3 == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type3 == "keyword b") return cont(pushlex("form"), statement, poplex);
      if (type3 == "keyword d") return cx.stream.match(/^\\s*\$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type3 == "debugger") return cont(expect(";"));
      if (type3 == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type3 == ";") return cont();
      if (type3 == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type3 == "function") return cont(functiondef);
      if (type3 == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
      if (type3 == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type3 == "class" ? type3 : value), className, poplex);
      }
      if (type3 == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\\s*\\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum") return cont(enumdef);
          else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
          else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type3 == "switch") return cont(
        pushlex("form"),
        parenExpr,
        expect("{"),
        pushlex("}", "switch"),
        pushblockcontext,
        block,
        poplex,
        poplex,
        popcontext
      );
      if (type3 == "case") return cont(expression, expect(":"));
      if (type3 == "default") return cont(expect(":"));
      if (type3 == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type3 == "export") return cont(pushlex("stat"), afterExport, poplex);
      if (type3 == "import") return cont(pushlex("stat"), afterImport, poplex);
      if (type3 == "async") return cont(statement);
      if (value == "@") return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type3) {
      if (type3 == "(") return cont(funarg, expect(")"));
    }
    function expression(type3, value) {
      return expressionInner(type3, value, false);
    }
    function expressionNoComma(type3, value) {
      return expressionInner(type3, value, true);
    }
    function parenExpr(type3) {
      if (type3 != "(") return pass();
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
    }
    function expressionInner(type3, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
        else if (type3 == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }
      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type3)) return cont(maybeop);
      if (type3 == "function") return cont(functiondef, maybeop);
      if (type3 == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }
      if (type3 == "keyword c" || type3 == "async") return cont(noComma ? expressionNoComma : expression);
      if (type3 == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type3 == "operator" || type3 == "spread") return cont(noComma ? expressionNoComma : expression);
      if (type3 == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type3 == "{") return contCommasep(objprop, "}", null, maybeop);
      if (type3 == "quasi") return pass(quasi, maybeop);
      if (type3 == "new") return cont(maybeTarget(noComma));
      return cont();
    }
    function maybeexpression(type3) {
      if (type3.match(/[;\\}\\)\\],]/)) return pass();
      return pass(expression);
    }
    function maybeoperatorComma(type3, value) {
      if (type3 == ",") return cont(maybeexpression);
      return maybeoperatorNoComma(type3, value, false);
    }
    function maybeoperatorNoComma(type3, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type3 == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type3 == "operator") {
        if (/\\+\\+|--/.test(value) || isTS && value == "!") return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?") return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type3 == "quasi") {
        return pass(quasi, me);
      }
      if (type3 == ";") return;
      if (type3 == "(") return contCommasep(expressionNoComma, ")", "call", me);
      if (type3 == ".") return cont(property, me);
      if (type3 == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }
      if (type3 == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
        return cont(expr);
      }
    }
    function quasi(type3, value) {
      if (type3 != "quasi") return pass();
      if (value.slice(value.length - 2) != "\${") return cont(quasi);
      return cont(maybeexpression, continueQuasi);
    }
    function continueQuasi(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type3) {
      findFatArrow(cx.stream, cx.state);
      return pass(type3 == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function(type3) {
        if (type3 == ".") return cont(noComma ? targetNoComma : target);
        else if (type3 == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
        else return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }
    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }
    function maybelabel(type3) {
      if (type3 == ":") return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type3) {
      if (type3 == "variable") {
        cx.marked = "property";
        return cont();
      }
    }
    function objprop(type3, value) {
      if (type3 == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set") return cont(getterSetter);
        var m;
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))
          cx.state.fatArrowAt = cx.stream.pos + m[0].length;
        return cont(afterprop);
      } else if (type3 == "number" || type3 == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type3 == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type3 == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "*") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type3 == ":") {
        return pass(afterprop);
      }
    }
    function getterSetter(type3) {
      if (type3 != "variable") return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type3) {
      if (type3 == ":") return cont(expressionNoComma);
      if (type3 == "(") return pass(functiondef);
    }
    function commasep(what, end, sep) {
      function proceed(type3, value) {
        if (sep ? sep.indexOf(type3) > -1 : type3 == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
          return cont(function(type4, value2) {
            if (type4 == end || value2 == end) return pass();
            return pass(what);
          }, proceed);
        }
        if (type3 == end || value == end) return cont();
        if (sep && sep.indexOf(";") > -1) return pass(what);
        return cont(expect(end));
      }
      return function(type3, value) {
        if (type3 == end || value == end) return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = 3; i < arguments.length; i++)
        cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type3) {
      if (type3 == "}") return cont();
      return pass(statement, block);
    }
    function maybetype(type3, value) {
      if (isTS) {
        if (type3 == ":") return cont(typeexpr);
        if (value == "?") return cont(maybetype);
      }
    }
    function maybetypeOrIn(type3, value) {
      if (isTS && (type3 == ":" || value == "in")) return cont(typeexpr);
    }
    function mayberettype(type3) {
      if (isTS && type3 == ":") {
        if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr);
        else return cont(typeexpr);
      }
    }
    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }
    function typeexpr(type3, value) {
      if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
        cx.marked = "keyword";
        return cont(value == "typeof" ? expressionNoComma : typeexpr);
      }
      if (type3 == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }
      if (value == "|" || value == "&") return cont(typeexpr);
      if (type3 == "string" || type3 == "number" || type3 == "atom") return cont(afterType);
      if (type3 == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type3 == "{") return cont(pushlex("}"), typeprops, poplex, afterType);
      if (type3 == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type3 == "<") return cont(commasep(typeexpr, ">"), typeexpr);
      if (type3 == "quasi") {
        return pass(quasiType, afterType);
      }
    }
    function maybeReturnType(type3) {
      if (type3 == "=>") return cont(typeexpr);
    }
    function typeprops(type3) {
      if (type3.match(/[\\}\\)\\]]/)) return cont();
      if (type3 == "," || type3 == ";") return cont(typeprops);
      return pass(typeprop, typeprops);
    }
    function typeprop(type3, value) {
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?" || type3 == "number" || type3 == "string") {
        return cont(typeprop);
      } else if (type3 == ":") {
        return cont(typeexpr);
      } else if (type3 == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type3 == "(") {
        return pass(functiondecl, typeprop);
      } else if (!type3.match(/[;\\}\\)\\],]/)) {
        return cont();
      }
    }
    function quasiType(type3, value) {
      if (type3 != "quasi") return pass();
      if (value.slice(value.length - 2) != "\${") return cont(quasiType);
      return cont(typeexpr, continueQuasiType);
    }
    function continueQuasiType(type3) {
      if (type3 == "}") {
        cx.marked = "string-2";
        cx.state.tokenize = tokenQuasi;
        return cont(quasiType);
      }
    }
    function typearg(type3, value) {
      if (type3 == "variable" && cx.stream.match(/^\\s*[?:]/, false) || value == "?") return cont(typearg);
      if (type3 == ":") return cont(typeexpr);
      if (type3 == "spread") return cont(typearg);
      return pass(typeexpr);
    }
    function afterType(type3, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type3 == "." || value == "&") return cont(typeexpr);
      if (type3 == "[") return cont(typeexpr, expect("]"), afterType);
      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }
      if (value == "?") return cont(typeexpr, expect(":"), typeexpr);
    }
    function maybeTypeArgs(_, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }
    function maybeTypeDefault(_, value) {
      if (value == "=") return cont(typeexpr);
    }
    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type3, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(pattern);
      }
      if (type3 == "variable") {
        register(value);
        return cont();
      }
      if (type3 == "spread") return cont(pattern);
      if (type3 == "[") return contCommasep(eltpattern, "]");
      if (type3 == "{") return contCommasep(proppattern, "}");
    }
    function proppattern(type3, value) {
      if (type3 == "variable" && !cx.stream.match(/^\\s*:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type3 == "variable") cx.marked = "property";
      if (type3 == "spread") return cont(pattern);
      if (type3 == "}") return pass();
      if (type3 == "[") return cont(expression, expect("]"), expect(":"), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
      if (value == "=") return cont(expressionNoComma);
    }
    function vardefCont(type3) {
      if (type3 == ",") return cont(vardef);
    }
    function maybeelse(type3, value) {
      if (type3 == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type3, value) {
      if (value == "await") return cont(forspec);
      if (type3 == "(") return cont(pushlex(")"), forspec1, poplex);
    }
    function forspec1(type3) {
      if (type3 == "var") return cont(vardef, forspec2);
      if (type3 == "variable") return cont(forspec2);
      return pass(forspec2);
    }
    function forspec2(type3, value) {
      if (type3 == ")") return cont();
      if (type3 == ";") return cont(forspec2);
      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression, forspec2);
      }
      return pass(expression, forspec2);
    }
    function functiondef(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondef);
      }
      if (type3 == "variable") {
        register(value);
        return cont(functiondef);
      }
      if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }
    function functiondecl(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(functiondecl);
      }
      if (type3 == "variable") {
        register(value);
        return cont(functiondecl);
      }
      if (type3 == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }
    function typename(type3, value) {
      if (type3 == "keyword" || type3 == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }
    function funarg(type3, value) {
      if (value == "@") cont(expression, funarg);
      if (type3 == "spread") return cont(funarg);
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(funarg);
      }
      if (isTS && type3 == "this") return cont(maybetype, maybeAssign);
      return pass(pattern, maybetype, maybeAssign);
    }
    function classExpression(type3, value) {
      if (type3 == "variable") return className(type3, value);
      return classNameAfter(type3, value);
    }
    function className(type3, value) {
      if (type3 == "variable") {
        register(value);
        return cont(classNameAfter);
      }
    }
    function classNameAfter(type3, value) {
      if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
      if (value == "extends" || value == "implements" || isTS && type3 == ",") {
        if (value == "implements") cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type3 == "{") return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type3, value) {
      if (type3 == "async" || type3 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\\s+#?[\\w\$\\xa1-\\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type3 == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(classfield, classBody);
      }
      if (type3 == "number" || type3 == "string") return cont(classfield, classBody);
      if (type3 == "[")
        return cont(expression, maybetype, expect("]"), classfield, classBody);
      if (value == "*") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type3 == "(") return pass(functiondecl, classBody);
      if (type3 == ";" || type3 == ",") return cont(classBody);
      if (type3 == "}") return cont();
      if (value == "@") return cont(expression, classBody);
    }
    function classfield(type3, value) {
      if (value == "!") return cont(classfield);
      if (value == "?") return cont(classfield);
      if (type3 == ":") return cont(typeexpr, maybeAssign);
      if (value == "=") return cont(expressionNoComma);
      var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }
    function afterExport(type3, value) {
      if (value == "*") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }
      if (value == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }
      if (type3 == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type3, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }
      if (type3 == "variable") return pass(expressionNoComma, exportField);
    }
    function afterImport(type3) {
      if (type3 == "string") return cont();
      if (type3 == "(") return pass(expression);
      if (type3 == ".") return pass(maybeoperatorComma);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type3, value) {
      if (type3 == "{") return contCommasep(importSpec, "}");
      if (type3 == "variable") register(value);
      if (value == "*") cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type3) {
      if (type3 == ",") return cont(importSpec, maybeMoreImports);
    }
    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }
    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }
    function arrayLiteral(type3) {
      if (type3 == "]") return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }
    function enummember() {
      return pass(pattern, maybeAssign);
    }
    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
    }
    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)\$/.test(state.lastType) || state.lastType == "quasi" && /\\{\\s*\$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
    }
    return {
      startState: function(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 0
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace()) return null;
        var style = state.tokenize(stream, state);
        if (type2 == "comment") return style;
        state.lastType = type2 == "operator" && (content == "++" || content == "--") ? "incdec" : type2;
        return parseJS(state, style, type2, content, stream);
      },
      indent: function(state, textAfter) {
        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror2.Pass;
        if (state.tokenize != tokenBase) return 0;
        var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
        if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
          var c = state.cc[i];
          if (c == poplex) lexical = lexical.prev;
          else if (c != maybeelse && c != popcontext) break;
        }
        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))
          lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type3 = lexical.type, closing = firstChar == type3;
        if (type3 == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
        else if (type3 == "form" && firstChar == "{") return lexical.indented;
        else if (type3 == "form") return lexical.indented + indentUnit;
        else if (type3 == "stat")
          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
        else if (lexical.align) return lexical.column + (closing ? 0 : 1);
        else return lexical.indented + (closing ? 0 : indentUnit);
      },
      electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})\$/,
      blockCommentStart: jsonMode ? null : "/*",
      blockCommentEnd: jsonMode ? null : "*/",
      blockCommentContinue: jsonMode ? null : " * ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\\"\\"\`\`",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode,
      jsonMode,
      expressionAllowed,
      skipExpression: function(state) {
        parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
      }
    };
  });
  CodeMirror2.registerHelper("wordChars", "javascript", /[\\w\$]/);
  CodeMirror2.defineMIME("text/javascript", "javascript");
  CodeMirror2.defineMIME("text/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/javascript", "javascript");
  CodeMirror2.defineMIME("application/x-javascript", "javascript");
  CodeMirror2.defineMIME("application/ecmascript", "javascript");
  CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
  CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
  CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
  CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../../../lib/codemirror"), require("../../../../addon/mode/simple"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "../../addon/mode/simple"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineSimpleMode("rust", {
    start: [
      // string and byte string
      { regex: /b?"/, token: "string", next: "string" },
      // raw string and raw byte string
      { regex: /b?r"/, token: "string", next: "string_raw" },
      { regex: /b?r#+"/, token: "string", next: "string_raw_hash" },
      // character
      { regex: /'(?:[^'\\\\]|\\\\(?:[nrt0'"]|x[\\da-fA-F]{2}|u\\{[\\da-fA-F]{6}\\}))'/, token: "string-2" },
      // byte
      { regex: /b'(?:[^']|\\\\(?:['\\\\nrt0]|x[\\da-fA-F]{2}))'/, token: "string-2" },
      {
        regex: /(?:(?:[0-9][0-9_]*)(?:(?:[Ee][+-]?[0-9_]+)|\\.[0-9_]+(?:[Ee][+-]?[0-9_]+)?)(?:f32|f64)?)|(?:0(?:b[01_]+|(?:o[0-7_]+)|(?:x[0-9a-fA-F_]+))|(?:[0-9][0-9_]*))(?:u8|u16|u32|u64|i8|i16|i32|i64|isize|usize)?/,
        token: "number"
      },
      { regex: /(let(?:\\s+mut)?|fn|enum|mod|struct|type|union)(\\s+)([a-zA-Z_][a-zA-Z0-9_]*)/, token: ["keyword", null, "def"] },
      { regex: /(?:abstract|alignof|as|async|await|box|break|continue|const|crate|do|dyn|else|enum|extern|fn|for|final|if|impl|in|loop|macro|match|mod|move|offsetof|override|priv|proc|pub|pure|ref|return|self|sizeof|static|struct|super|trait|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/, token: "keyword" },
      { regex: /\\b(?:Self|isize|usize|char|bool|u8|u16|u32|u64|f16|f32|f64|i8|i16|i32|i64|str|Option)\\b/, token: "atom" },
      { regex: /\\b(?:true|false|Some|None|Ok|Err)\\b/, token: "builtin" },
      {
        regex: /\\b(fn)(\\s+)([a-zA-Z_][a-zA-Z0-9_]*)/,
        token: ["keyword", null, "def"]
      },
      { regex: /#!?\\[.*\\]/, token: "meta" },
      { regex: /\\/\\/.*/, token: "comment" },
      { regex: /\\/\\*/, token: "comment", next: "comment" },
      { regex: /[-+\\/*=<>!]+/, token: "operator" },
      { regex: /[a-zA-Z_]\\w*!/, token: "variable-3" },
      { regex: /[a-zA-Z_]\\w*/, token: "variable" },
      { regex: /[\\{\\[\\(]/, indent: true },
      { regex: /[\\}\\]\\)]/, dedent: true }
    ],
    string: [
      { regex: /"/, token: "string", next: "start" },
      { regex: /(?:[^\\\\"]|\\\\(?:.|\$))*/, token: "string" }
    ],
    string_raw: [
      { regex: /"/, token: "string", next: "start" },
      { regex: /[^"]*/, token: "string" }
    ],
    string_raw_hash: [
      { regex: /"#+/, token: "string", next: "start" },
      { regex: /(?:[^"]|"(?!#))*/, token: "string" }
    ],
    comment: [
      { regex: /.*?\\*\\//, token: "comment", next: "start" },
      { regex: /.*/, token: "comment" }
    ],
    meta: {
      dontIndentStates: ["comment"],
      electricInput: /^\\s*\\}\$/,
      blockCommentStart: "/*",
      blockCommentEnd: "*/",
      lineComment: "//",
      fold: "brace"
    }
  });
  CodeMirror2.defineMIME("text/x-rustsrc", "rust");
  CodeMirror2.defineMIME("text/rust", "rust");
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function Bar(cls, orientation, scroll) {
    this.orientation = orientation;
    this.scroll = scroll;
    this.screen = this.total = this.size = 1;
    this.pos = 0;
    this.node = document.createElement("div");
    this.node.className = cls + "-" + orientation;
    this.inner = this.node.appendChild(document.createElement("div"));
    var self2 = this;
    CodeMirror2.on(this.inner, "mousedown", function(e) {
      if (e.which != 1) return;
      CodeMirror2.e_preventDefault(e);
      var axis = self2.orientation == "horizontal" ? "pageX" : "pageY";
      var start = e[axis], startpos = self2.pos;
      function done() {
        CodeMirror2.off(document, "mousemove", move);
        CodeMirror2.off(document, "mouseup", done);
      }
      function move(e2) {
        if (e2.which != 1) return done();
        self2.moveTo(startpos + (e2[axis] - start) * (self2.total / self2.size));
      }
      CodeMirror2.on(document, "mousemove", move);
      CodeMirror2.on(document, "mouseup", done);
    });
    CodeMirror2.on(this.node, "click", function(e) {
      CodeMirror2.e_preventDefault(e);
      var innerBox = self2.inner.getBoundingClientRect(), where;
      if (self2.orientation == "horizontal")
        where = e.clientX < innerBox.left ? -1 : e.clientX > innerBox.right ? 1 : 0;
      else
        where = e.clientY < innerBox.top ? -1 : e.clientY > innerBox.bottom ? 1 : 0;
      self2.moveTo(self2.pos + where * self2.screen);
    });
    function onWheel(e) {
      var moved = CodeMirror2.wheelEventPixels(e)[self2.orientation == "horizontal" ? "x" : "y"];
      var oldPos = self2.pos;
      self2.moveTo(self2.pos + moved);
      if (self2.pos != oldPos) CodeMirror2.e_preventDefault(e);
    }
    CodeMirror2.on(this.node, "mousewheel", onWheel);
    CodeMirror2.on(this.node, "DOMMouseScroll", onWheel);
  }
  Bar.prototype.setPos = function(pos, force) {
    if (pos < 0) pos = 0;
    if (pos > this.total - this.screen) pos = this.total - this.screen;
    if (!force && pos == this.pos) return false;
    this.pos = pos;
    this.inner.style[this.orientation == "horizontal" ? "left" : "top"] = pos * (this.size / this.total) + "px";
    return true;
  };
  Bar.prototype.moveTo = function(pos) {
    if (this.setPos(pos)) this.scroll(pos, this.orientation);
  };
  var minButtonSize = 10;
  Bar.prototype.update = function(scrollSize, clientSize, barSize) {
    var sizeChanged = this.screen != clientSize || this.total != scrollSize || this.size != barSize;
    if (sizeChanged) {
      this.screen = clientSize;
      this.total = scrollSize;
      this.size = barSize;
    }
    var buttonSize = this.screen * (this.size / this.total);
    if (buttonSize < minButtonSize) {
      this.size -= minButtonSize - buttonSize;
      buttonSize = minButtonSize;
    }
    this.inner.style[this.orientation == "horizontal" ? "width" : "height"] = buttonSize + "px";
    this.setPos(this.pos, sizeChanged);
  };
  function SimpleScrollbars(cls, place, scroll) {
    this.addClass = cls;
    this.horiz = new Bar(cls, "horizontal", scroll);
    place(this.horiz.node);
    this.vert = new Bar(cls, "vertical", scroll);
    place(this.vert.node);
    this.width = null;
  }
  SimpleScrollbars.prototype.update = function(measure) {
    if (this.width == null) {
      var style = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle;
      if (style) this.width = parseInt(style.height);
    }
    var width = this.width || 0;
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    this.vert.node.style.display = needsV ? "block" : "none";
    this.horiz.node.style.display = needsH ? "block" : "none";
    if (needsV) {
      this.vert.update(
        measure.scrollHeight,
        measure.clientHeight,
        measure.viewHeight - (needsH ? width : 0)
      );
      this.vert.node.style.bottom = needsH ? width + "px" : "0";
    }
    if (needsH) {
      this.horiz.update(
        measure.scrollWidth,
        measure.clientWidth,
        measure.viewWidth - (needsV ? width : 0) - measure.barLeft
      );
      this.horiz.node.style.right = needsV ? width + "px" : "0";
      this.horiz.node.style.left = measure.barLeft + "px";
    }
    return { right: needsV ? width : 0, bottom: needsH ? width : 0 };
  };
  SimpleScrollbars.prototype.setScrollTop = function(pos) {
    this.vert.setPos(pos);
  };
  SimpleScrollbars.prototype.setScrollLeft = function(pos) {
    this.horiz.setPos(pos);
  };
  SimpleScrollbars.prototype.clear = function() {
    var parent = this.horiz.node.parentNode;
    parent.removeChild(this.horiz.node);
    parent.removeChild(this.vert.node);
  };
  CodeMirror2.scrollbarModel.simple = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-simplescroll", place, scroll);
  };
  CodeMirror2.scrollbarModel.overlay = function(place, scroll) {
    return new SimpleScrollbars("CodeMirror-overlayscroll", place, scroll);
  };
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";
  var GUTT_CLASS = "CodeMirror-activeline-gutter";
  CodeMirror2.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old == CodeMirror2.Init ? false : old;
    if (val == prev) return;
    if (prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
    if (val) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    }
  });
  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);
    }
  }
  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }
  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      var option = cm.getOption("styleActiveLine");
      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())
        continue;
      var line = cm.getLineHandleVisualStart(range.head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i2 = 0; i2 < active.length; i2++) {
        cm.addLineClass(active[i2], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i2], "background", BACK_CLASS);
        cm.addLineClass(active[i2], "gutter", GUTT_CLASS);
      }
      cm.state.activeLines = active;
    });
  }
  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
  var Pos = CodeMirror2.Pos;
  var matching = {
    "(": ")>",
    ")": "(<",
    "[": "]>",
    "]": "[<",
    "{": "}>",
    "}": "{<",
    "<": ">>",
    ">": "<<",
    "‹": "›>",
    "›": "‹<",
    "«": "»>",
    "»": "«<"
    // TODO NOTE: added for arabic support
  };
  function bracketRegex(config) {
    return config && config.bracketRegex || /[(){}[\\]]/;
  }
  function findMatchingBracket(cm, where, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var afterCursor = config && config.afterCursor;
    if (afterCursor == null)
      afterCursor = /(^| )cm-fat-cursor(\$| )/.test(cm.getWrapperElement().className);
    var re = bracketRegex(config);
    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (config && config.strict && dir > 0 != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
    if (found == null) return null;
    return {
      from: Pos(where.line, pos),
      to: found && found.pos,
      match: found && found.ch == match.charAt(0),
      forward: dir > 0
    };
  }
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = config && config.maxScanLineLength || 1e4;
    var maxScanLines = config && config.maxScanLines || 1e3;
    var stack = [];
    var re = bracketRegex(config);
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
          var match = matching[ch];
          if (match && match.charAt(1) == ">" == dir > 0) stack.push(ch);
          else if (!stack.length) return { pos: Pos(lineNo, pos), ch };
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }
  function matchBrackets(cm, autoclear, config) {
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config && config.highlightNonMatching;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));
      }
    }
    if (marks.length) {
      if (ie_lt8 && cm.state.focused) cm.focus();
      var clear2 = function() {
        cm.operation(function() {
          for (var i2 = 0; i2 < marks.length; i2++) marks[i2].clear();
        });
      };
      if (autoclear) setTimeout(clear2, 800);
      else return clear2;
    }
  }
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }
  function clearHighlighted(cm) {
    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
      cm.state.matchBrackets.currentlyHighlighted();
      cm.state.matchBrackets.currentlyHighlighted = null;
    }
  }
  CodeMirror2.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.off("cursorActivity", doMatchBrackets);
      cm.off("focus", doMatchBrackets);
      cm.off("blur", clearHighlighted);
      clearHighlighted(cm);
    }
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
      cm.on("focus", doMatchBrackets);
      cm.on("blur", clearHighlighted);
    }
  });
  CodeMirror2.defineExtension("matchBrackets", function() {
    matchBrackets(this, true);
  });
  CodeMirror2.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {
    if (oldConfig || typeof config == "boolean") {
      if (!oldConfig) {
        config = config ? { strict: true } : null;
      } else {
        oldConfig.strict = config;
        config = oldConfig;
      }
    }
    return findMatchingBracket(this, pos, config);
  });
  CodeMirror2.defineExtension("scanForBracket", function(pos, dir, style, config) {
    return scanForBracket(this, pos, dir, style, config);
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var defaults = {
    pairs: \`()[]{}''‹›""«»\`,
    //TODO NOTE: MODIFIED to add ‹›  «»
    closeBefore: \`)]}'›"»:;>\`,
    //TODO NOTE: MODIFIED to add › »
    triples: "",
    explode: "[]{}"
  };
  var Pos = CodeMirror2.Pos;
  CodeMirror2.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.removeKeyMap(keyMap);
      cm.state.closeBrackets = null;
    }
    if (val) {
      ensureBound(getOption(val, "pairs"));
      cm.state.closeBrackets = val;
      cm.addKeyMap(keyMap);
    }
  });
  function getOption(conf, name) {
    if (name == "pairs" && typeof conf == "string") return conf;
    if (typeof conf == "object" && conf[name] != null) return conf[name];
    return defaults[name];
  }
  var keyMap = { Backspace: handleBackspace, Enter: handleEnter };
  function ensureBound(chars) {
    for (var i = 0; i < chars.length; i++) {
      var ch = chars.charAt(i), key = "'" + ch + "'";
      if (!keyMap[key]) keyMap[key] = handler(ch);
    }
  }
  ensureBound(defaults.pairs + "\`");
  function handler(ch) {
    return function(cm) {
      return handleChar(cm, ch);
    };
  }
  function getConfig(cm) {
    var deflt = cm.state.closeBrackets;
    if (!deflt || deflt.override) return deflt;
    var mode = cm.getModeAt(cm.getCursor());
    return mode.closeBrackets || deflt;
  }
  function handleBackspace(cm) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var pairs = getOption(conf, "pairs");
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror2.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror2.Pass;
    }
    for (var i = ranges.length - 1; i >= 0; i--) {
      var cur = ranges[i].head;
      cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
    }
  }
  function handleEnter(cm) {
    var conf = getConfig(cm);
    var explode = conf && getOption(conf, "explode");
    if (!explode || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) return CodeMirror2.Pass;
      var around = charsAround(cm, ranges[i].head);
      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror2.Pass;
    }
    cm.operation(function() {
      var linesep = cm.lineSeparator() || "\\n";
      cm.replaceSelection(linesep + linesep, null);
      moveSel(cm, -1);
      ranges = cm.listSelections();
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var line = ranges[i2].head.line;
        cm.indentLine(line, null, true);
        cm.indentLine(line + 1, null, true);
      }
    });
  }
  function moveSel(cm, dir) {
    var newRanges = [], ranges = cm.listSelections(), primary = 0;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (range.head == cm.getCursor()) primary = i;
      var pos = range.head.ch || dir > 0 ? { line: range.head.line, ch: range.head.ch + dir } : { line: range.head.line - 1 };
      newRanges.push({ anchor: pos, head: pos });
    }
    cm.setSelections(newRanges, primary);
  }
  function contractSelection(sel) {
    var inverted = CodeMirror2.cmpPos(sel.anchor, sel.head) > 0;
    return {
      anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
      head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
    };
  }
  function handleChar(cm, ch) {
    var conf = getConfig(cm);
    if (!conf || cm.getOption("disableInput")) return CodeMirror2.Pass;
    var pairs = getOption(conf, "pairs");
    var pos = pairs.indexOf(ch);
    if (pos == -1) return CodeMirror2.Pass;
    var closeBefore = getOption(conf, "closeBefore");
    var triples = getOption(conf, "triples");
    var identical = pairs.charAt(pos + 1) == ch;
    var ranges = cm.listSelections();
    var opening = pos % 2 == 0;
    var type2;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], cur = range.head, curType;
      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
      if (opening && !range.empty()) {
        curType = "surround";
      } else if ((identical || !opening) && next == ch) {
        if (identical && stringStartsAfter(cm, cur))
          curType = "both";
        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
          curType = "skipThree";
        else
          curType = "skip";
      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
        if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror2.Pass;
        curType = "addFour";
      } else if (identical) {
        var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
        if (!CodeMirror2.isWordChar(next) && prev != ch && !CodeMirror2.isWordChar(prev)) curType = "both";
        else return CodeMirror2.Pass;
      } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {
        curType = "both";
      } else {
        return CodeMirror2.Pass;
      }
      if (!type2) type2 = curType;
      else if (type2 != curType) return CodeMirror2.Pass;
    }
    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
    var right = pos % 2 ? ch : pairs.charAt(pos + 1);
    cm.operation(function() {
      if (type2 == "skip") {
        moveSel(cm, 1);
      } else if (type2 == "skipThree") {
        moveSel(cm, 3);
      } else if (type2 == "surround") {
        var sels = cm.getSelections();
        for (var i2 = 0; i2 < sels.length; i2++)
          sels[i2] = left + sels[i2] + right;
        cm.replaceSelections(sels, "around");
        sels = cm.listSelections().slice();
        for (var i2 = 0; i2 < sels.length; i2++)
          sels[i2] = contractSelection(sels[i2]);
        cm.setSelections(sels);
      } else if (type2 == "both") {
        cm.replaceSelection(left + right, null);
        cm.triggerElectric(left + right);
        moveSel(cm, -1);
      } else if (type2 == "addFour") {
        cm.replaceSelection(left + left + left + left, "before");
        moveSel(cm, 1);
      }
    });
  }
  function charsAround(cm, pos) {
    var str = cm.getRange(
      Pos(pos.line, pos.ch - 1),
      Pos(pos.line, pos.ch + 1)
    );
    return str.length == 2 ? str : null;
  }
  function stringStartsAfter(cm, pos) {
    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
    return /\\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)));
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function doFold(cm, pos, options, force) {
    if (options && options.call) {
      var finder = options;
      options = null;
    } else {
      var finder = getOption(cm, options, "rangeFinder");
    }
    if (typeof pos == "number") pos = CodeMirror2.Pos(pos, 0);
    var minSize = getOption(cm, options, "minFoldSize");
    function getRange(allowFolded) {
      var range2 = finder(cm, pos);
      if (!range2 || range2.to.line - range2.from.line < minSize) return null;
      if (force === "fold") return range2;
      var marks = cm.findMarksAt(range2.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold) {
          if (!allowFolded) return null;
          range2.cleared = true;
          marks[i].clear();
        }
      }
      return range2;
    }
    var range = getRange(true);
    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror2.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;
    var myWidget = makeWidget(cm, options, range);
    CodeMirror2.on(myWidget, "mousedown", function(e) {
      myRange.clear();
      CodeMirror2.e_preventDefault(e);
    });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: getOption(cm, options, "clearOnEnter"),
      __isFold: true
    });
    myRange.on("clear", function(from, to) {
      CodeMirror2.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror2.signal(cm, "fold", cm, range.from, range.to);
  }
  function makeWidget(cm, options, range) {
    var widget = getOption(cm, options, "widget");
    if (typeof widget == "function") {
      widget = widget(range.from, range.to);
    }
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    } else if (widget) {
      widget = widget.cloneNode(true);
    }
    return widget;
  }
  CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
    return function(cm, pos) {
      doFold(cm, pos, { rangeFinder, widget });
    };
  };
  CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
    doFold(this, pos, options, force);
  });
  CodeMirror2.defineExtension("isFolded", function(pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold) return true;
  });
  CodeMirror2.commands.toggleFold = function(cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror2.commands.fold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror2.commands.unfold = function(cm) {
    cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
  };
  CodeMirror2.commands.foldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
    });
  };
  CodeMirror2.commands.unfoldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
    });
  };
  CodeMirror2.registerHelper("fold", "combine", function() {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function(cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });
  CodeMirror2.registerHelper("fold", "auto", function(cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });
  var defaultOptions = {
    rangeFinder: CodeMirror2.fold.auto,
    widget: "↔",
    minFoldSize: 0,
    scanUp: false,
    clearOnEnter: true
  };
  CodeMirror2.defineOption("foldOptions", null);
  function getOption(cm, options, name) {
    if (options && options[name] !== void 0)
      return options[name];
    var editorOptions = cm.options.foldOptions;
    if (editorOptions && editorOptions[name] !== void 0)
      return editorOptions[name];
    return defaultOptions[name];
  }
  CodeMirror2.defineExtension("foldOption", function(options, name) {
    return getOption(this, options, name);
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"), require("./foldcode"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror", "./foldcode"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
    if (old && old != CodeMirror2.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("changes", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", onChange);
      cm.off("optionChange", optionChange);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("changes", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", onChange);
      cm.on("optionChange", optionChange);
    }
  });
  var Pos = CodeMirror2.Pos;
  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }
  function parseOptions(opts2) {
    if (opts2 === true) opts2 = {};
    if (opts2.gutter == null) opts2.gutter = "CodeMirror-foldgutter";
    if (opts2.indicatorOpen == null) opts2.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts2.indicatorFolded == null) opts2.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts2;
  }
  function isFolded(cm, line) {
    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
    for (var i = 0; i < marks.length; ++i) {
      if (marks[i].__isFold) {
        var fromPos = marks[i].find(-1);
        if (fromPos && fromPos.line === line)
          return marks[i];
      }
    }
  }
  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec + " CodeMirror-guttermarker-subtle";
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }
  function updateFoldInfo(cm, from, to) {
    var opts2 = cm.state.foldGutter.options, cur = from - 1;
    var minSize = cm.foldOption(opts2, "minFoldSize");
    var func = cm.foldOption(opts2, "rangeFinder");
    var clsFolded = typeof opts2.indicatorFolded == "string" && classTest(opts2.indicatorFolded);
    var clsOpen = typeof opts2.indicatorOpen == "string" && classTest(opts2.indicatorOpen);
    cm.eachLine(from, to, function(line) {
      ++cur;
      var mark = null;
      var old = line.gutterMarkers;
      if (old) old = old[opts2.gutter];
      if (isFolded(cm, cur)) {
        if (clsFolded && old && clsFolded.test(old.className)) return;
        mark = marker(opts2.indicatorFolded);
      } else {
        var pos = Pos(cur, 0);
        var range = func && func(cm, pos);
        if (range && range.to.line - range.from.line >= minSize) {
          if (clsOpen && old && clsOpen.test(old.className)) return;
          mark = marker(opts2.indicatorOpen);
        }
      }
      if (!mark && !old) return;
      cm.setGutterMarker(line, opts2.gutter, mark);
    });
  }
  function classTest(cls) {
    return new RegExp("(^|\\\\s)" + cls + "(?:\$|\\\\s)\\\\s*");
  }
  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function() {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from;
    state.to = vp.to;
  }
  function onGutterClick(cm, line, gutter) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    if (gutter != opts2.gutter) return;
    var folded = isFolded(cm, line);
    if (folded) folded.clear();
    else cm.foldCode(Pos(line, 0), opts2);
  }
  function optionChange(cm, option) {
    if (option == "mode") onChange(cm);
  }
  function onChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      updateInViewport(cm);
    }, opts2.foldOnChangeTimeSpan || 600);
  }
  function onViewportChange(cm) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var opts2 = state.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function() {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts2.updateViewportTimeSpan || 400);
  }
  function onFold(cm, from) {
    var state = cm.state.foldGutter;
    if (!state) return;
    var line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  var HINT_ELEMENT_CLASS = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
  CodeMirror2.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = { hint: getHints };
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };
  CodeMirror2.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections();
    if (selections.length > 1) return;
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }
    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;
    CodeMirror2.signal(this, "startCompletion", this);
    completion.update(true);
  });
  CodeMirror2.defineExtension("closeHint", function() {
    if (this.state.completionActive) this.state.completionActive.close();
  });
  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
    if (this.options.updateOnCursorActivity) {
      var self2 = this;
      cm.on("cursorActivity", this.activityFunc = function() {
        self2.cursorActivity();
      });
    }
  }
  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1e3 / 60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      if (this.options.updateOnCursorActivity) {
        this.cm.off("cursorActivity", this.activityFunc);
      }
      if (this.widget && this.data) CodeMirror2.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror2.signal(this.cm, "endCompletion", this.cm);
    },
    active: function() {
      return this.cm.state.completionActive == this;
    },
    pick: function(data, i) {
      var completion = data.list[i], self2 = this;
      this.cm.operation(function() {
        if (completion.hint)
          completion.hint(self2.cm, data, completion);
        else
          self2.cm.replaceRange(
            getText(completion),
            completion.from || data.from,
            completion.to || data.to,
            "complete"
          );
        CodeMirror2.signal(data, "pick", completion);
        self2.cm.scrollIntoView();
      });
      if (this.options.closeOnPick) {
        this.close();
      }
    },
    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }
      var identStart = this.startPos;
      if (this.data) {
        identStart = this.data.from;
      }
      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self2 = this;
        this.debounce = requestAnimationFrame(function() {
          self2.update();
        });
        if (this.widget) this.widget.disable();
      }
    },
    update: function(first) {
      if (this.tick == null) return;
      var self2 = this, myTick = ++this.tick;
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self2.tick == myTick) self2.finishUpdate(data, first);
      });
    },
    finishUpdate: function(data, first) {
      if (this.data) CodeMirror2.signal(this.data, "update");
      var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
      if (this.widget) this.widget.close();
      this.data = data;
      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror2.signal(data, "shown");
        }
      }
    }
  };
  function parseOptions(cm, pos, options) {
    var editor2 = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor2) {
      for (var prop in editor2)
        if (editor2[prop] !== void 0) out[prop] = editor2[prop];
    }
    if (options) {
      for (var prop in options)
        if (options[prop] !== void 0) out[prop] = options[prop];
    }
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos);
    return out;
  }
  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }
  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {
        handle.moveFocus(-1);
      },
      Down: function() {
        handle.moveFocus(1);
      },
      PageUp: function() {
        handle.moveFocus(-handle.menuSize() + 1, true);
      },
      PageDown: function() {
        handle.moveFocus(handle.menuSize() - 1, true);
      },
      Home: function() {
        handle.setFocus(0);
      },
      End: function() {
        handle.setFocus(handle.length - 1);
      },
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var mac = /Mac/.test(navigator.platform);
    if (mac) {
      baseMap["Ctrl-P"] = function() {
        handle.moveFocus(-1);
      };
      baseMap["Ctrl-N"] = function() {
        handle.moveFocus(1);
      };
    }
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key2, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) {
          return val(cm, handle);
        };
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key2] = bound;
    }
    if (custom) {
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    }
    var extra = completion.options.extraKeys;
    if (extra) {
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    }
    return ourMap;
  }
  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }
  function Widget(completion, data) {
    this.id = "cm-complete-" + Math.floor(Math.random(1e6));
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;
    var ownerDocument = cm.getInputField().ownerDocument;
    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
    var hints = this.hints = ownerDocument.createElement("ul");
    hints.setAttribute("role", "listbox");
    hints.setAttribute("aria-expanded", "true");
    hints.id = this.id;
    var theme = completion.cm.options.theme;
    hints.className = "CodeMirror-hints " + theme;
    this.selectedHint = data.selectedHint || 0;
    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (i == this.selectedHint) elt.setAttribute("aria-selected", "true");
      elt.id = this.id + "-" + i;
      elt.setAttribute("role", "option");
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }
    var container = completion.options.container || ownerDocument.body;
    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    var offsetLeft = 0, offsetTop = 0;
    if (container !== ownerDocument.body) {
      var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
      var offsetParent = isContainerPositioned ? container : container.offsetParent;
      var offsetParentPosition = offsetParent.getBoundingClientRect();
      var bodyPosition = ownerDocument.body.getBoundingClientRect();
      offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
      offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
    }
    hints.style.left = left - offsetLeft + "px";
    hints.style.top = top - offsetTop + "px";
    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
    container.appendChild(hints);
    cm.getInputField().setAttribute("aria-autocomplete", "list");
    cm.getInputField().setAttribute("aria-owns", this.id);
    cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;
    var startScroll;
    setTimeout(function() {
      startScroll = cm.getScrollInfo();
    });
    var overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2;
      if (winH - box.top < spaceAbove) {
        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + "px";
        hints.style.top = (top = pos.top - height) + offsetTop + "px";
        below = false;
      } else {
        hints.style.height = winH - box.top - 2 + "px";
      }
    }
    var overlapX = box.right - winW;
    if (scrolls) overlapX += cm.display.nativeBarWidth;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = winW - 5 + "px";
        overlapX -= box.right - box.left - winW;
      }
      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px";
    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) {
        widget.changeActive(widget.selectedHint + n, avoidWrap);
      },
      setFocus: function(n) {
        widget.changeActive(n);
      },
      menuSize: function() {
        return widget.screenAmount();
      },
      length: completions.length,
      close: function() {
        completion.close();
      },
      pick: function() {
        widget.pick();
      },
      data
    }));
    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() {
        closingOnBlur = setTimeout(function() {
          completion.close();
        }, 100);
      });
      cm.on("focus", this.onFocus = function() {
        clearTimeout(closingOnBlur);
      });
    }
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor2 = cm.getWrapperElement().getBoundingClientRect();
      if (!startScroll) startScroll = cm.getScrollInfo();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor2.top || point >= editor2.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = left + startScroll.left - curScroll.left + "px";
    });
    CodeMirror2.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        widget.pick();
      }
    });
    CodeMirror2.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });
    CodeMirror2.on(hints, "mousedown", function() {
      setTimeout(function() {
        cm.focus();
      }, 20);
    });
    var selectedHintRange = this.getSelectedHintRange();
    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
      this.scrollToActive();
    }
    CodeMirror2.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }
  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);
      var input = this.completion.cm.getInputField();
      input.removeAttribute("aria-activedescendant");
      input.removeAttribute("aria-owns");
      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },
    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = { Enter: function() {
        widget.picked = true;
      } };
      this.completion.cm.addKeyMap(this.keyMap);
    },
    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },
    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0 : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      if (node) {
        node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
        node.removeAttribute("aria-selected");
      }
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      node.setAttribute("aria-selected", "true");
      this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);
      this.scrollToActive();
      CodeMirror2.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },
    scrollToActive: function() {
      var selectedHintRange = this.getSelectedHintRange();
      var node1 = this.hints.childNodes[selectedHintRange.from];
      var node2 = this.hints.childNodes[selectedHintRange.to];
      var firstNode = this.hints.firstChild;
      if (node1.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
    },
    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    },
    getSelectedHintRange: function() {
      var margin = this.completion.options.scrollMargin || 0;
      return {
        from: Math.max(0, this.selectedHint - margin),
        to: Math.min(this.data.list.length - 1, this.selectedHint + margin)
      };
    }
  };
  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers;
    var result = [];
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i]);
    return result;
  }
  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options);
    } else {
      var result = hint(cm, options);
      if (result && result.then) result.then(callback);
      else callback(result);
    }
  }
  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words;
    if (helpers.length) {
      var resolved = function(cm2, callback, options) {
        var app = applicableHelpers(cm2, helpers);
        function run2(i) {
          if (i == app.length) return callback(null);
          fetchHints(app[i], cm2, options, function(result) {
            if (result && result.list.length > 0) callback(result);
            else run2(i + 1);
          });
        }
        run2(0);
      };
      resolved.async = true;
      resolved.supportsSelection = true;
      return resolved;
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm2) {
        return CodeMirror2.hint.fromList(cm2, { words });
      };
    } else if (CodeMirror2.hint.anyword) {
      return function(cm2, options) {
        return CodeMirror2.hint.anyword(cm2, options);
      };
    } else {
      return function() {
      };
    }
  }
  CodeMirror2.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });
  CodeMirror2.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var term, from = CodeMirror2.Pos(cur.line, token.start), to = cur;
    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
      term = token.string.substr(0, cur.ch - token.start);
    } else {
      term = "";
      from = cur;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }
    if (found.length) return { list: found, from, to };
  });
  CodeMirror2.commands.autocomplete = CodeMirror2.showHint;
  var defaultOptions = {
    hint: CodeMirror2.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\\s()\\[\\]{};:>,]/,
    closeOnPick: true,
    closeOnUnfocus: true,
    updateOnCursorActivity: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null,
    paddingForScrollbar: true,
    moveOnOverlap: true
  };
  CodeMirror2.defineOption("hintOptions", null);
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function bracketFolding(pairs) {
    return function(cm, start) {
      var line = start.line, lineText = cm.getLine(line);
      function findOpening(pair) {
        var tokenType;
        for (var at = start.ch, pass = 0; ; ) {
          var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);
          if (found2 == -1) {
            if (pass == 1) break;
            pass = 1;
            at = lineText.length;
            continue;
          }
          if (pass == 1 && found2 < start.ch) break;
          tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found2 + 1));
          if (!/^(comment|string)/.test(tokenType)) return { ch: found2 + 1, tokenType, pair };
          at = found2 - 1;
        }
      }
      function findRange(found2) {
        var count = 1, lastLine = cm.lastLine(), end, startCh = found2.ch, endCh;
        outer: for (var i2 = line; i2 <= lastLine; ++i2) {
          var text = cm.getLine(i2), pos = i2 == line ? startCh : 0;
          for (; ; ) {
            var nextOpen = text.indexOf(found2.pair[0], pos), nextClose = text.indexOf(found2.pair[1], pos);
            if (nextOpen < 0) nextOpen = text.length;
            if (nextClose < 0) nextClose = text.length;
            pos = Math.min(nextOpen, nextClose);
            if (pos == text.length) break;
            if (cm.getTokenTypeAt(CodeMirror2.Pos(i2, pos + 1)) == found2.tokenType) {
              if (pos == nextOpen) ++count;
              else if (!--count) {
                end = i2;
                endCh = pos;
                break outer;
              }
            }
            ++pos;
          }
        }
        if (end == null || line == end) return null;
        return {
          from: CodeMirror2.Pos(line, startCh),
          to: CodeMirror2.Pos(end, endCh)
        };
      }
      var found = [];
      for (var i = 0; i < pairs.length; i++) {
        var open = findOpening(pairs[i]);
        if (open) found.push(open);
      }
      found.sort(function(a, b) {
        return a.ch - b.ch;
      });
      for (var i = 0; i < found.length; i++) {
        var range = findRange(found[i]);
        if (range) return range;
      }
      return null;
    };
  }
  CodeMirror2.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));
  CodeMirror2.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));
  CodeMirror2.registerHelper("fold", "import", function(cm, start) {
    function hasImport(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
      if (!/\\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
      if (start2.type != "keyword" || start2.string != "import") return null;
      for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
        var text = cm.getLine(i), semi = text.indexOf(";");
        if (semi != -1) return { startCh: start2.end, end: CodeMirror2.Pos(i, semi) };
      }
    }
    var startLine = start.line, has = hasImport(startLine), prev;
    if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
      return null;
    for (var end = has.end; ; ) {
      var next = hasImport(end.line + 1);
      if (next == null) break;
      end = next.end;
    }
    return { from: cm.clipPos(CodeMirror2.Pos(startLine, has.startCh + 1)), to: end };
  });
  CodeMirror2.registerHelper("fold", "include", function(cm, start) {
    function hasInclude(line) {
      if (line < cm.firstLine() || line > cm.lastLine()) return null;
      var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
      if (!/\\S/.test(start2.string)) start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
      if (start2.type == "meta" && start2.string.slice(0, 8) == "#include") return start2.start + 8;
    }
    var startLine = start.line, has = hasInclude(startLine);
    if (has == null || hasInclude(startLine - 1) != null) return null;
    for (var end = startLine; ; ) {
      var next = hasInclude(end + 1);
      if (next == null) break;
      ++end;
    }
    return {
      from: CodeMirror2.Pos(startLine, has + 1),
      to: cm.clipPos(CodeMirror2.Pos(end))
    };
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  function lineIndent(cm, lineNo) {
    var text = cm.getLine(lineNo);
    var spaceTo = text.search(/\\S/);
    if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror2.Pos(lineNo, spaceTo + 1))))
      return -1;
    return CodeMirror2.countColumn(text, null, cm.getOption("tabSize"));
  }
  CodeMirror2.registerHelper("fold", "indent", function(cm, start) {
    var myIndent = lineIndent(cm, start.line);
    if (myIndent < 0) return;
    var lastLineInFold = null;
    for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
      var indent2 = lineIndent(cm, i);
      if (indent2 == -1) ;
      else if (indent2 > myIndent) {
        lastLineInFold = i;
      } else {
        break;
      }
    }
    if (lastLineInFold) return {
      from: CodeMirror2.Pos(start.line, cm.getLine(start.line).length),
      to: CodeMirror2.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
    };
  });
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object")
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd)
    define(["../../lib/codemirror"], mod);
  else
    mod(CodeMirror);
})(function(CodeMirror2) {
  CodeMirror2.registerGlobalHelper("fold", "comment", function(mode) {
    return mode.blockCommentStart && mode.blockCommentEnd;
  }, function(cm, start) {
    var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
    if (!startToken || !endToken) return;
    var line = start.line, lineText = cm.getLine(line);
    var startCh;
    for (var at = start.ch, pass = 0; ; ) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
      if (found == -1) {
        if (pass == 1) return;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) return;
      if (/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found + 1))) && (found == 0 || lineText.slice(found - endToken.length, found) == endToken || !/comment/.test(cm.getTokenTypeAt(CodeMirror2.Pos(line, found))))) {
        startCh = found + startToken.length;
        break;
      }
      at = found - 1;
    }
    var depth = 1, lastLine = cm.lastLine(), end, endCh;
    outer: for (var i = line; i <= lastLine; ++i) {
      var text = cm.getLine(i), pos = i == line ? startCh : 0;
      for (; ; ) {
        var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
        if (nextOpen < 0) nextOpen = text.length;
        if (nextClose < 0) nextClose = text.length;
        pos = Math.min(nextOpen, nextClose);
        if (pos == text.length) break;
        if (pos == nextOpen) ++depth;
        else if (!--depth) {
          end = i;
          endCh = pos;
          break outer;
        }
        ++pos;
      }
    }
    if (end == null || line == end && endCh == startCh) return;
    return {
      from: CodeMirror2.Pos(line, startCh),
      to: CodeMirror2.Pos(end, endCh)
    };
  });
});
const THEME_LABELS = {
  theme_ttcn: { ar: "فاتح ١", en: "TTCN" },
  theme_default: { ar: "فاتح ٢", en: "CodeMirror Default" },
  theme_solarized_light: { ar: "فاتح ٣", en: "Solarized (Light)" },
  theme_eclipse: { ar: "فاتح ٤", en: "Eclipse" },
  theme_midnight: { ar: "غامق ١", en: "Midnight" },
  theme_panda_syntax: { ar: "غامق ٢", en: "Panda Syntax" },
  theme_tomorrow_night_eighties: { ar: "غامق ٣", en: "Tommorrow Night Eighties" },
  theme_night: { ar: "غامق ٤", en: "Night" },
  theme_colorforth: { ar: "غامق ٥", en: "colorForth" },
  theme_monokai: { ar: "غامق ٦", en: "Monokai" },
  theme_the_matrix: { ar: "غامق ٧", en: "The Matrix" },
  theme_ayu_dark: { ar: "غامق ٨", en: "Ayu Dark" },
  theme_moxer: { ar: "غامق ٩", en: "Moxer" },
  theme_mbo: { ar: "غامق ١٠", en: "MBO" }
};
const INDEX_LABELS = {
  new_file: { ar: "ملف جديد", en: "New File" },
  new_proj: { ar: "مشروع جديد", en: "New Project" },
  open: { ar: "فتح", en: "Open" },
  open_file: { ar: "فتح ملف", en: "Open File" },
  open_proj: { ar: "فتح مشروع", en: "Open Project" },
  new: { ar: "جديد", en: "New" },
  save: { ar: "حفظ", en: "Save" },
  compile: { ar: "ترجمة", en: "Compile" },
  build: { ar: "بناء", en: "Build" },
  terminate: { ar: "إنهاء", en: "Terminate" },
  output_label: { ar: "المخرجات", en: "Output" },
  lang_label: { ar: "لغة المحرر", en: "Editor Langauge" },
  lang_ar: { ar: "العربية - Arabic", en: "Arabic - العربية" },
  lang_en: { ar: "الانجليزية - English", en: "English - الانجليزية" },
  س: { ar: "س", en: "س" },
  ...THEME_LABELS
};
const TOOLTIP_LABELS = {
  theme: { ar: "المظهر", en: "Theme" },
  run: { ar: "تشغيل", en: "Run" },
  srccode: { ar: "رِماز", en: "Code" },
  clear: { ar: "مسح", en: "Clear" }
};
function setLabels(LABELS, langId) {
  for (let [k, v2] of Object.entries(LABELS)) {
    let el = document.querySelector(\`#\${k}\`);
    if (el) {
      el.textContent = v2[langId];
    }
  }
}
function setTooltipLabels(LABELS, langId) {
  for (let [k, v2] of Object.entries(LABELS)) {
    let el = document.querySelector(\`#\${k}\`);
    if (el) {
      el.title = v2[langId];
    }
  }
}
class Err {
  msg;
  start_loc;
  end_loc;
  constructor(msg, start_loc, end_loc) {
    this.msg = msg;
    this.start_loc = start_loc;
    this.end_loc = end_loc;
  }
}
const SUPPORTED_GEN = [
  "js",
  "node",
  "react-native",
  "html",
  "css"
];
const AR_KEYWORD = {
  "باسم": "as",
  "صحيح": "true",
  "غير_صحيح": "false",
  "عندما": "when",
  "كرر": "for",
  "احضر": "use",
  "عرف": "let",
  "ثابت": "const",
  "دل": "fn",
  "نوع": "type",
  "تركيبة": "struct",
  "تعداد": "enum",
  "مستعار": "alias",
  "سمة": "trait",
  "اعد": "return",
  "نفذ": "do",
  "لا_شيء": "void"
};
const EN_KEYWORD = {
  "as": "باسم",
  "true": "صحيح",
  "false": "غير_صحيح",
  "when": "عندما",
  "for": "كرر",
  "use": "احضر",
  "let": "عرف",
  "const": "ثابت",
  "fn": "دل",
  "type": "نوع",
  "struct": "تركيبة",
  "enum": "تعداد",
  "alias": "مستعار",
  "trait": "سمة",
  "return": "اعد",
  "do": "نفذ",
  "void": "لا_شيء"
};
const MASHRIQ_DIGIT = ["٠", "١", "٢", "٣", "٤", "٥", "٦", "٧", "٨", "٩"];
const MAGHRIB_DIGIT\$2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
const TATWEEL = "ـ";
const ANY_LETTER = regexp("\\\\p{L}");
const ANY_NUM = regexp("\\\\p{N}");
function is_none(x) {
  return x == null;
}
function is_list\$2(x) {
  return x instanceof Array;
}
function contains\$2(list, el) {
  return list.includes(el);
}
function replace(array, i, v2) {
  array[i] = v2;
}
function is_empty(list) {
  return Array.isArray(list) && list.length === 0;
}
function to_str\$2(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function regexp(expr) {
  return new RegExp(expr, "u");
}
function pprint\$1(obj, indent2) {
  if (obj == null) {
    console.log("undefined");
  } else {
    {
      console.log(JSON.stringify(obj));
    }
  }
}
function panic\$2(v2) {
  throw new Error(v2);
}
function clone(obj) {
  return { ...obj };
}
function to_lowercase(str) {
  return str.toLowerCase();
}
class Loc {
  line;
  column;
  constructor(line, column) {
    this.line = line;
    this.column = column;
    return this;
  }
}
class Token {
  v;
  loc;
  constructor(v2, loc) {
    this.v = v2;
    this.loc = loc;
    return this;
  }
}
class Lexer {
  lang;
  code;
  start_loc;
  end_loc;
  tokens;
  errs;
  current_index;
  current;
  lookbehind;
  ignore_cmts_ws;
  init(lang2, code, ignore_cmts_ws) {
    this.lang = lang2;
    this.code = code;
    this.start_loc = new Loc(1, 1);
    this.end_loc = new Loc(1, 1);
    this.tokens = [];
    this.errs = [];
    this.current_index = -1;
    this.current = null;
    this.lookbehind = null;
    this.ignore_cmts_ws = ignore_cmts_ws;
  }
  run() {
    if (this.lang === "ar") {
      this.ar();
    } else if (this.lang === "en") {
      this.en();
    }
    this.start_loc = clone(this.end_loc);
    this.add_token("\$eof");
  }
  add_token(v2) {
    const tk = new Token(v2, clone(this.start_loc));
    this.tokens.push(tk);
  }
  next() {
    this.lookbehind = this.current;
    this.current_index += 1;
    const c = this.code[this.current_index];
    this.current = c;
    if (c === "\\n") {
      this.end_loc.line += 1;
      this.end_loc.column = 1;
    } else {
      this.end_loc.column += 1;
    }
    return this.current;
  }
  lookahead() {
    return this.code[this.current_index + 1];
  }
  skip(count) {
    while (count > 0) {
      this.next();
      count -= 1;
    }
  }
  insert_err(msg) {
    const err = new Err(msg, clone(this.start_loc), clone(this.end_loc));
    this.errs.push(err);
  }
  last_token() {
    return this.tokens[this.tokens.length - 1];
  }
  skip_invalid_num_or_id() {
    while (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
      this.skip(1);
    }
  }
  expect_tatweel() {
    return this.lookahead() === TATWEEL;
  }
  expect_nl_behind() {
    return this.lookbehind === "\\n";
  }
  expect_none_behind() {
    return is_none(this.lookbehind);
  }
  expect_none_ahead() {
    return is_none(this.lookahead());
  }
  expect_ws_behind() {
    return this.lookbehind === "\\n" || this.lookbehind === " " || this.lookbehind === "\\r" || this.lookbehind === "	";
  }
  expect_space_ahead() {
    return this.lookahead() === " " || this.lookahead() === "	";
  }
  expect_ws_ahead() {
    return this.lookahead() === "\\n" || this.lookahead() === " " || this.lookahead() === "\\r" || this.lookahead() === "	";
  }
  expect_nl_ahead() {
    return this.lookahead() === "\\n";
  }
  expect_separator_behind() {
    return this.lookbehind === "," || this.lookbehind === ";" || this.lookbehind === ";;" || this.lookbehind === ":" || this.lookbehind === "(" || this.lookbehind === "[" || this.lookbehind === "{" || this.lookbehind === "<";
  }
  expect_separator_ahead() {
    return this.lookahead() === "," || this.lookahead() === ";" || this.lookahead() === ";;" || this.lookahead() === ":" || this.lookahead() === ")" || this.lookahead() === "]" || this.lookahead() === "}" || this.lookahead() === ">";
  }
  expect_open_bracket() {
    return this.lookahead() === "[";
  }
  expect_open_paren() {
    return this.lookahead() === "(";
  }
  expect_letter() {
    if (this.lookahead()) {
      return this.lookahead().match(ANY_LETTER);
    }
  }
  expect_num() {
    return this.lookahead().match(ANY_NUM);
  }
  expect_underscore() {
    return this.lookahead() === "_";
  }
  expect_eof() {
    return is_none(this.lookahead());
  }
  expect_eol() {
    return this.lookahead() === "\\n" || this.lookahead() === "\\r" || this.expect_eof();
  }
  multi_comment() {
    if ("-" === this.lookahead()) {
      let v2 = "";
      const levels = [];
      while (!this.expect_eof()) {
        if ("{" === this.current && "-" === this.lookahead()) {
          v2 += this.next() + this.next();
          levels.push(clone(this.end_loc));
        } else if ("-" === this.current && "}" === this.lookahead()) {
          if (levels.length > 1) {
            v2 += this.next() + this.next();
            levels.pop();
          } else {
            v2 += this.next();
            levels.pop();
            break;
          }
        } else {
          v2 += this.next();
        }
      }
      const loc = levels.pop();
      if (loc) {
        this.start_loc = clone(loc);
        this.insert_err("unclosed comment");
      }
      if (!this.ignore_cmts_ws) {
        this.add_token(["--", v2]);
      }
      return true;
    }
  }
  ar_escape_char() {
    let sym = this.current;
    if ("٪" === sym) {
      let c = this.next();
      switch (c) {
        case "(":
          c = this.next();
          switch (c) {
            case "س":
              c = "\\n";
              break;
            case "ر":
              c = "\\r";
              break;
            case "ج":
              c = "	";
              break;
            case "‹":
              c = "‹";
              break;
            case "›":
              c = "›";
              break;
            case "«":
              c = "«";
              break;
            case "»":
              c = "»";
              break;
          }
          if (this.next() !== ")") {
            this.insert_err("invalid_escape_character: " + c);
          }
          break;
        case "٪":
          c = "٪";
          break;
        case "{":
          c = "\${";
          break;
        default: {
          this.insert_err("invalid escape character: " + c);
        }
      }
      return c;
    } else {
      return this.current;
    }
  }
  en_escape_char() {
    const sym = this.current;
    if ("%" === sym) {
      let c = this.next();
      switch (c) {
        case "n":
          c = "\\n";
          break;
        case "r":
          c = "\\r";
          break;
        case "t":
          c = "	";
          break;
        case "'":
          c = "'";
          break;
        case '"':
          c = '"';
          break;
        case "%":
          c = "%";
          break;
        case "{":
          c = "\${";
          break;
        default:
          {
            this.insert_err("invalid escape character: " + c);
          }
          break;
      }
      return c;
    } else {
      return this.current;
    }
  }
  enclosed_val(sym) {
    let v2 = "";
    while (!this.expect_eof()) {
      this.next();
      if (sym === this.current) {
        break;
      }
      if (this.expect_eol()) {
        this.insert_err("unclosed literal, expecting: " + sym);
        break;
      }
      if (this.lang === "ar") {
        v2 += this.ar_escape_char();
      } else {
        v2 += this.en_escape_char();
      }
    }
    return v2;
  }
  ar_str() {
    if ("«" === this.lookahead()) {
      this.ar_multi_str();
    } else {
      this.add_token(["str", this.enclosed_val("»")]);
    }
  }
  en_str() {
    if ('"' === this.lookahead()) {
      this.en_multi_str();
    } else {
      this.add_token(["str", this.enclosed_val("'")]);
    }
  }
  multi_str(sym) {
    let c = "";
    let v2 = "";
    while (!this.expect_eof()) {
      this.next();
      if (this.expect_eof()) {
        this.insert_err("unclosed multiline String literal, expecting " + sym);
        break;
      }
      if (sym === this.current && sym === this.lookahead()) {
        this.skip(1);
        if (this.lookahead() === sym) {
          this.skip(1);
          this.add_token(["str", v2]);
          break;
        } else {
          c += sym + sym;
        }
      } else {
        if (this.lang === "ar") {
          v2 += this.ar_escape_char();
        } else {
          v2 += this.en_escape_char();
        }
        v2 += c;
      }
    }
  }
  ar_multi_str(sym) {
    this.skip(1);
    if ("«" === this.lookahead()) {
      this.skip(1);
      this.multi_str("»");
    } else {
      this.add_token(["str", ""]);
    }
  }
  en_multi_str(sym) {
    this.skip(1);
    if ('"' === this.lookahead()) {
      this.skip(1);
      this.multi_str('"');
    } else {
      this.add_token(["str", ""]);
    }
  }
  equal() {
    const sym = [];
    while ("=" === this.lookahead()) {
      sym.push(this.next());
    }
    if (sym.length === 0) {
      this.add_token("=");
    } else if (sym.length === 1) {
      this.add_token("==");
    } else if (sym.length > 1) {
      if (!this.ignore_cmts_ws) {
        this.add_token(["===", sym.length + 1]);
      }
    } else {
      return false;
    }
    return true;
  }
  thick_arrow() {
    if (">" === this.lookahead()) {
      this.next();
      this.add_token("=>");
      return true;
    }
  }
  add_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("+=");
      return true;
    }
  }
  concat() {
    if ("+" === this.lookahead()) {
      this.next();
      this.add_token("++");
      return true;
    }
  }
  add() {
    this.add_token("+");
    return true;
  }
  sub_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("-=");
      return true;
    }
  }
  thin_arrow() {
    if (">" === this.lookahead()) {
      this.next();
      this.add_token("->");
      return true;
    }
  }
  dash() {
    const sym = [];
    while ("-" === this.lookahead()) {
      sym.push(this.next());
    }
    if (sym.length === 0) {
      this.add_token("-");
    } else if (sym.length > 1) {
      if (!this.ignore_cmts_ws) {
        this.add_token(["---", sym.length + 1]);
      }
    } else {
      return false;
    }
    return true;
  }
  tilde() {
    if ("~" === this.lookahead()) {
      this.next();
      this.add_token("~");
      return true;
    }
  }
  mul_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("*=");
      return true;
    }
  }
  mul() {
    this.add_token("*");
    return true;
  }
  asterisk() {
    let sym = "*";
    while ("*" === this.lookahead()) {
      sym += this.next();
    }
    if (sym.length === 1) {
      this.mul();
    } else {
      return false;
    }
    return true;
  }
  ar_div_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("\\\\=");
      return true;
    }
  }
  div_asgmt() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("/=");
      return true;
    }
  }
  comment() {
    if ("-" === this.lookahead()) {
      let v2 = "";
      while (!this.expect_eof()) {
        if (this.expect_eol()) {
          break;
        } else {
          v2 += this.next();
        }
      }
      if (!this.ignore_cmts_ws) {
        this.add_token(["--", v2]);
      }
      return true;
    }
  }
  ar_div() {
    this.add_token("\\\\");
    return true;
  }
  div() {
    this.add_token("/");
    return true;
  }
  ne() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("!=");
      return true;
    }
  }
  exclamation() {
    this.add_token("!");
    return true;
  }
  ge() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token(">=");
      return true;
    }
  }
  gt() {
    this.add_token(">");
    return true;
  }
  le() {
    if ("=" === this.lookahead()) {
      this.next();
      this.add_token("<=");
      return true;
    }
  }
  lt() {
    this.add_token("<");
    return true;
  }
  and() {
    if (this.lookahead() === "&") {
      this.skip(1);
      this.add_token("&&");
      return true;
    } else {
      this.add_token("&");
      return true;
    }
  }
  or_listpipe() {
    if (this.lookahead() === "|") {
      this.skip(1);
      if (this.lookahead() === ">") {
        this.skip(1);
        this.add_token("||>");
        return true;
      }
      this.add_token("||");
      return true;
    }
  }
  pipe() {
    if (this.lookahead() === ">") {
      this.skip(1);
      this.add_token("|>");
      return true;
    }
  }
  bar() {
    this.add_token("|");
    return true;
  }
  mashriq_float() {
    if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
      v = this.current + this.mashriq_fract();
      this.add_token(["float", v]);
    } else {
      this.insert_err("ill-formed floating point number");
    }
  }
  maghrib_float() {
    if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
      v = this.current + this.maghrib_fract();
      this.add_token(["float", v]);
      return true;
    }
  }
  dots() {
    if ("." === this.lookahead()) {
      this.skip(1);
      if ("." === this.lookahead()) {
        this.skip(1);
        this.add_token("...");
      } else {
        this.add_token("..");
      }
      return true;
    }
  }
  dot() {
    this.add_token(".");
    return true;
  }
  trailing() {
    if (this.lookahead() === ">") {
      this.skip(1);
      this.add_token(":>");
      return true;
    }
  }
  decl() {
    if (this.lookahead() === "=") {
      this.skip(1);
      this.add_token(":=");
      return true;
    }
  }
  dcolon() {
    if (this.lookahead() === ":") {
      this.skip(1);
      if (this.lookahead() === "=") {
        this.skip(1);
        this.add_token("::=");
      } else {
        this.add_token("::");
      }
      return true;
    }
  }
  colon() {
    this.add_token(":");
    return true;
  }
  ar_semicolon() {
    this.add_token(";");
    return true;
  }
  en_semicolon() {
    this.add_token(";");
    return true;
  }
  mashriq_num() {
    let v2 = this.current;
    while (true) {
      if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        v2 += this.next();
      } else if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        this.insert_err("you can either use Mashriq digits (٠ - ٩) or Maghrib digits (0 - 9) but not a mix: " + this.current);
        this.skip_invalid_num_or_id();
      } else if ("," === this.lookahead()) {
        v2 += this.next();
        v2 += this.maghrib_fract();
      } else {
        break;
      }
      if (this.expect_eof()) {
        break;
      }
    }
    if (this.is_float) {
      this.add_token(["float", v2]);
    } else {
      this.add_token(["int", v2]);
    }
  }
  maghrib_num() {
    let v2 = this.current;
    let is_float = false;
    while (true) {
      if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        v2 += this.next();
      } else if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        this.insert_err("you can either use Eastern Arabic digits (٠ - ٩) or Western (0 - 9) but not a mix: " + this.current);
        this.skip_invalid_num_or_id();
      } else if ("." === this.lookahead()) {
        v2 += this.next();
        is_float = true;
        v2 += this.maghrib_fract();
      } else {
        break;
      }
      if (this.expect_eof()) {
        break;
      }
    }
    if (is_float) {
      this.add_token(["float", v2]);
    } else {
      this.add_token(["int", v2]);
    }
  }
  ar_id() {
    let v2 = this.current;
    while (!this.expect_eof()) {
      if (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
        if (this.expect_tatweel()) {
          this.skip(1);
        } else {
          v2 += this.next();
        }
      } else {
        break;
      }
    }
    if (AR_KEYWORD[v2]) {
      this.add_token(["key", AR_KEYWORD[v2]]);
    } else {
      this.add_token(["id", v2]);
    }
  }
  en_id() {
    let v2 = this.current;
    while (!this.expect_eof()) {
      if (this.expect_letter() || this.expect_num() || this.expect_underscore()) {
        v2 += this.next();
      } else {
        break;
      }
    }
    if (EN_KEYWORD[v2]) {
      this.add_token(["key", v2]);
    } else {
      this.add_token(["id", v2]);
    }
  }
  mashriq_fract() {
    let v2 = "";
    while (!this.expect_eof()) {
      if (contains\$2(MASHRIQ_DIGIT, this.lookahead())) {
        v2 += this.next();
      } else {
        break;
      }
    }
    return v2;
  }
  maghrib_float() {
    if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
      const v2 = this.current + this.maghrib_fract();
      this.add_token(["float", v2]);
      return true;
    }
  }
  maghrib_fract() {
    let v2 = "";
    while (!this.expect_eof()) {
      if (contains\$2(MAGHRIB_DIGIT\$2, this.lookahead())) {
        v2 += this.next();
      } else {
        break;
      }
    }
    return v2;
  }
  new_line() {
    let count = 1;
    while (true) {
      if (this.lookahead() === "\\n") {
        this.skip(1);
        count += 1;
      } else {
        if (this.last_token() && this.last_token().v !== "\\n") {
          this.add_token(["\\n", count]);
        }
        break;
      }
    }
  }
  ar() {
    while (!this.expect_eof()) {
      this.start_loc = clone(this.end_loc);
      const c = this.next();
      switch (c) {
        case "؟":
          this.add_token("?");
          break;
        case "٪":
          this.add_token("%");
          break;
        case ",":
          this.mashriq_float();
          break;
        case ".":
          this.maghrib_float() || this.tdot() || this.dots() || this.dot();
          break;
        case "،":
          this.add_token(",");
          break;
        case "×":
          this.mul_asgmt() || this.mul();
          break;
        case "*":
          this.mul_asgmt() || this.asterisk();
          break;
        case "÷":
        case "/":
          this.div_asgmt() || this.div();
          break;
        case "\\\\":
          this.ar_div_asgmt() || this.ar_div();
          break;
        case "؛":
          this.ar_semicolon();
          break;
        case "«":
          this.ar_str();
          break;
        default: {
          if (contains\$2(MASHRIQ_DIGIT, c)) {
            this.mashriq_num();
          } else if (contains\$2(MAGHRIB_DIGIT\$2, c)) {
            this.maghrib_num();
          } else {
            if (c === "_" || c.match(ANY_LETTER)) {
              this.ar_id();
            } else {
              this.common(c);
            }
          }
        }
      }
    }
  }
  en() {
    while (!this.expect_eof()) {
      this.start_loc = clone(this.end_loc);
      const c = this.next();
      switch (c) {
        case "?":
          this.add_token("?");
          break;
        case "%":
          this.add_token("%");
          break;
        case ".":
          this.maghrib_float() || this.ddot() || this.dot();
          break;
        case ",":
          this.add_token(",");
          break;
        case "*":
          this.mul_asgmt() || this.asterisk();
          break;
        case "/":
          this.div_asgmt() || this.div();
          break;
        case ";":
          this.en_semicolon();
          break;
        case "'":
          this.en_str();
          break;
        default: {
          if (contains\$2(MAGHRIB_DIGIT\$2, c)) {
            this.maghrib_num();
          } else if (contains\$2(MASHRIQ_DIGIT, c)) {
            this.insert_err("only English Numerals are allowed in English source files: " + this.current);
            this.skip_invalid_num_or_id();
          } else {
            if (c === "_" || c.match(ANY_LETTER)) {
              this.en_id();
            } else {
              this.common(c);
            }
          }
        }
      }
    }
  }
  common(c) {
    switch (c) {
      case "\\n":
        this.new_line();
        break;
      case "\\r":
      case "	":
      case " ":
        {
          if (!this.ignore_cmts_ws) {
            this.add_token(c);
          }
        }
        break;
      case "&":
        this.and();
        break;
      case "|":
        this.pipe() || this.or_listpipe() || this.bar();
        break;
      case "+":
        this.add_asgmt() || this.concat() || this.add();
        break;
      case "-":
        this.comment() || this.sub_asgmt() || this.thin_arrow() || this.dash();
        break;
      case "~":
        this.tilde();
        break;
      case "^":
        this.add_token("^");
        break;
      case "=":
        this.thick_arrow() || this.equal();
        break;
      case "!":
        this.ne() || this.exclamation();
        break;
      case ">":
        this.ge() || this.gt();
        break;
      case "<":
        this.le() || this.lt();
        break;
      case ":":
        this.trailing() || this.decl() || this.dcolon() || this.colon();
        break;
      case "\`":
        this.transl();
        break;
      case "@":
        this.add_token("@");
        break;
      case "\$":
        this.add_token("\$");
        break;
      case "[":
        this.add_token("[");
        break;
      case "]":
        this.add_token("]");
        break;
      case "(":
        this.add_token("(");
        break;
      case ")":
        this.add_token(")");
        break;
      case "{":
        this.multi_comment() || this.add_token("{");
        break;
      case "}":
        this.add_token("}");
        break;
      default:
        this.insert_err("unrecognized character: " + this.current);
    }
  }
}
class Symtab {
  /*tmp*/
  fns;
  /*tmp*/
  structs;
  /*tmp*/
  receivers;
  root;
  stack;
  current;
  constructor() {
    this.fns = [];
    this.structs = [];
    this.enums = [];
    this.receivers = {};
    this.root = new Table(null);
    this.stack = [];
    this.stack.push(this.root);
    this.current = this.root;
  }
  /*tmp*/
  insert_fn(fn) {
    this.fns.push(fn);
  }
  /*tmp*/
  insert_struct(struct) {
    this.structs.push(struct);
  }
  /*tmp*/
  insert_enum(_enum) {
    this.enums.push(_enum);
  }
  /*tmp*/
  insert_receiver(id2, fns) {
    if (!this.receivers[id2]) {
      this.receivers[id2] = _fns;
    } else {
      this.receivers[id2] = [...this.receivers[id2], ..._fns];
    }
  }
  begin_scope() {
    const table = new Table(this.current);
    const entry = new Entry("", "table", { table });
    this.current.insert(entry);
    this.stack.push(table);
    this.current = this.stack[this.stack.length - 1];
    return entry;
  }
  end_scope() {
    this.current = this.stack.pop();
    return this.current;
  }
  insert_fn(id2, arity, rtype) {
    const entry = new Entry(id2, "fn", { arity, rtype });
    this.current.insert(entry);
    return entry;
  }
  insert_type(id2, fields) {
    const entry = new Entry(id2, "t", { fields });
    this.current.insert(entry);
    return entry;
  }
  insert_const(id2, t) {
    const entry = new Entry(id2, "const", { t });
    this.current.insert(entry);
    return entry;
  }
  insert_var(id2, t) {
    const entry = new Entry(id2, "var", { t });
    this.current.insert(entry);
    return entry;
  }
  insert_ref(id2) {
    const entry = new Entry(id2, "ref", {});
    this.current.insert(entry);
    return entry;
  }
}
class Table {
  parent;
  entries;
  inner_scope;
  constructor(parent) {
    this.parent = parent;
    this.entries = [];
    this.inner_scope = [];
  }
  insert(entry) {
    this.entries.push(entry);
  }
}
class Entry {
  id;
  t;
  attrs;
  constructor(id2, t, attrs) {
    this.id = id2;
    this.t = t;
    this.attrs = attrs;
  }
}
class Node {
  id;
  t;
  v;
  constructor(id2, t, v2) {
    this.id = id2, this.t = t, this.v = v2;
  }
}
class Type {
  t;
  o;
  constructor(t, o) {
    this.t = t;
    this.o = o;
  }
}
class Struct {
  name;
  fields;
  constructor(name, fields) {
    this.name = name;
    this.fields = fields;
  }
}
class Enum {
  name;
  variants;
  constructor(name, variants) {
    this.name = name;
    this.variants = variants;
  }
}
class TypeTempl {
  t;
  ts;
  o;
  constructor(t, ts, o) {
    this.t = t;
    this.ts = ts;
    this.o = o;
  }
}
class EnumPat {
  name;
  variant;
  constructor(name, variant) {
    this.name = name;
    this.variant = variant;
  }
}
class Uni {
  opr;
  op;
  constructor(opr, op) {
    this.opr = opr;
    this.op = op;
  }
}
class Bin {
  lopr;
  op;
  ropr;
  constructor(lopr, op, ropr) {
    this.lopr = lopr;
    this.op = op;
    this.ropr = ropr;
  }
}
class Method {
  t;
  fn;
  constructor(t, fn) {
    this.t = t;
    this.fn = fn;
  }
}
class Trait {
  id;
  fns;
  sigs;
  constructor(id2, fns, sigs) {
    this.id = id2;
    this.fns = fns;
    this.sigs = sigs;
  }
}
class Fn {
  name;
  params;
  ret_types;
  body;
  constructor(name, params2, ret_types, body) {
    this.name = name;
    this.params = params2;
    this.ret_types = ret_types;
    this.body = body;
  }
}
class FnSig {
  name;
  params;
  ret_types;
  constructor(name, params2, ret_types) {
    this.name = name;
    this.params = params2;
    this.ret_types = ret_types;
  }
}
class FnParam {
  _pat;
  t;
  constructor(_pat2, t) {
    this._pat = _pat2;
    this.t = t;
  }
}
class TrailingClosure {
  label;
  fn;
  constructor(label, fn) {
    this.label = label;
    this.fn = fn;
  }
}
class FnCall {
  id;
  args;
  trailing;
  constructor(id2, args, trailing) {
    this.id = id2;
    this.args = args;
    this.trailing = trailing;
  }
}
class Field {
  id;
  t;
  implicit;
  constructor(id2, t, implicit) {
    this.id = id2;
    this.t = t;
    this.implicit = implicit;
  }
}
class FieldAsgmt {
  id;
  expr;
  constructor(id2, expr) {
    this.id = id2;
    this.expr = expr;
  }
}
class AnonymousMethod {
  id;
  expr;
  constructor(stmts) {
    this.stmts = stmts;
  }
}
class StructLEl {
  k;
  v;
  constructor(k, v2) {
    this.k = k;
    this.v = v2;
  }
}
class Asgmt {
  lhs;
  t;
  rhs;
  constructor(lhs, t, rhs) {
    this.lhs = lhs;
    this.t = t;
    this.rhs = rhs;
  }
}
class ForInf {
  body;
  constructor(body) {
    this.body = body;
  }
}
class ForCond {
  expr;
  body;
  constructor(expr, body) {
    this.expr = expr;
    this.body = body;
  }
}
class ForIn {
  pat;
  expr;
  body;
  constructor(pat, expr, body) {
    this.pat = pat;
    this.expr = expr;
    this.body = body;
  }
}
class When {
  expr;
  arms;
  constructor(expr, arms) {
    this.expr = expr;
    this.arms = arms;
  }
}
class WhenArm {
  pats;
  expr;
  constructor(pats, expr) {
    this.pats = pats;
    this.expr = expr;
  }
}
const BIN_OP = ["+", "-", "*", "/", "[", "~=", "=>", "++", "::", ":=", "=", "+=", "-=", "*=", "/=", "|=", "&=", "==", "!=", ">", ">=", "<", "<=", "|", "||", "|>", "||>", ":>", "&", "&&", ".", ".."];
const PREFIX_UNI_OP = ["...", ".", "!", "not", "-", "+"];
const POSTFIX_UNI_OP = ["?", "!", "%"];
const BIN_R_ASSOC = ["=", ":", ":=", "~=", "+=", "-=", "*=", "/=", "÷=", "&=", "&&=", "|=", "||="];
class Parser {
  tokens;
  current_index;
  skipped_new_line;
  current;
  ast;
  symtab;
  attrs;
  errs;
  init(tokens) {
    this.tokens = tokens;
    this.current_index = -1;
    this.skipped_new_line = false;
    this.current = null;
    this.ast = [];
    this.symtab = new Symtab();
    this.attrs = [];
    this.errs = [];
  }
  run() {
    this.next();
    while (!this.is_eof()) {
      if (!this.maybe_use()) {
        break;
      }
    }
    while (!this.is_eof()) {
      let parsed = this.maybe_global_const();
      if (!parsed) {
        this.maybe_attrs();
        this.maybe_modifier();
        parsed = this.maybe_global_fn() || this.maybe_struct() || this.maybe_enum() || this.maybe_trait() || this.maybe_impl();
      }
      if (!parsed) {
        panic\$2("invalid syntax: " + to_str\$2(this.current));
      }
    }
  }
  next(nl) {
    this.current_index += 1;
    const tk = this.tokens[this.current_index];
    this.current = tk;
    if (tk.v[0] === "\\n") {
      this.skipped_new_line = true;
      this.next(true);
    } else {
      if (!nl) {
        this.skipped_new_line = false;
      }
    }
    return this.current;
  }
  backtrack() {
    this.current_index -= 1;
    const tk = this.tokens[this.current_index];
    this.current = tk;
    if (tk.v[0] === "\\n") {
      this.backtrack();
    }
  }
  skip() {
    return this.next();
  }
  lookahead() {
    return this.lookahead_n(1);
  }
  lookahead_n(n) {
    let j = this.current_index;
    while (n > 0) {
      j += 1;
      while (true) {
        const tk = this.tokens[j];
        let nl;
        if (tk) {
          nl = tk.v[0] === "\\n";
        }
        if (nl) {
          j += 1;
        } else {
          break;
        }
      }
      n -= 1;
    }
    return this.tokens[j];
  }
  lookahead_ws() {
    const i = this.current_index + 1;
    return this.tokens[i];
  }
  is_eof() {
    return this.current.v === "\$eof";
  }
  is_newline() {
    return this.skipped_new_line;
  }
  is_asterisk() {
    return this.current.v === "*";
  }
  is_at() {
    return this.current.v === "@";
  }
  is_asgmt() {
    return this.current.v === "=";
  }
  is_hash() {
    return this.current.v === "--";
  }
  is_percent() {
    return this.current.v === "%";
  }
  is_dpercent() {
    return this.current.v === "%%";
  }
  is_behind_none() {
    return is_none(this.lookbehind);
  }
  is_behind_nl() {
    return this.lookbehind === "\\n";
  }
  is_dot() {
    return this.current.v === ".";
  }
  is_double_dot() {
    return this.current.v === "..";
  }
  is_tripple_dot() {
    return this.current.v === "...";
  }
  is_colon() {
    return this.current.v === ":";
  }
  is_dplus() {
    return this.current.v === "++";
  }
  is_dcolon() {
    return this.current.v === "::";
  }
  is_caret() {
    return this.current.v === "^";
  }
  is_semicolon() {
    return this.current.v === ";";
  }
  is_comma() {
    return this.current.v === ",";
  }
  is_backtick() {
    return this.current.v === "\`";
  }
  is_tbacktick() {
    return this.current.v[0] === "\`\`\`";
  }
  is_underscore() {
    return this.is_id() && this.current.v[1] === "_";
  }
  is_plus() {
    return this.current.v === "+";
  }
  is_minus() {
    return this.current.v === "-";
  }
  is_exclamation() {
    return this.current.v === "!";
  }
  is_question() {
    return this.current.v === "?";
  }
  is_bar() {
    return this.current.v === "|";
  }
  is_thin_arrow() {
    return this.current.v === "->";
  }
  is_thick_arrow() {
    return this.current.v === "=>";
  }
  is_tilde() {
    return this.current.v === "~";
  }
  is_void() {
    return this.is_keyword("void");
  }
  is_or() {
    return this.is_keyword("or");
  }
  is_and() {
    return this.is_keyword("and");
  }
  is_not() {
    return this.is_keyword("not");
  }
  is_use() {
    return this.is_keyword("use");
  }
  is_let() {
    return this.is_keyword("let");
  }
  is_if_let() {
    return this.is_keyword("if_let");
  }
  is_const() {
    return this.is_keyword("const");
  }
  is_var() {
    return this.is_keyword("var");
  }
  is_then() {
    return this.is_keyword("then");
  }
  is_do() {
    return this.is_keyword("do");
  }
  is_end() {
    return this.is_keyword("end");
  }
  is_fn() {
    return this.is_keyword("fn");
  }
  is_alias() {
    return this.is_keyword("alias");
  }
  is_typedef() {
    return this.is_keyword("type");
  }
  is_struct() {
    return this.is_keyword("struct");
  }
  is_enum() {
    return this.is_keyword("enum");
  }
  is_trait() {
    return this.is_keyword("trait");
  }
  is_open_paren() {
    return this.current.v === "(";
  }
  is_close_paren() {
    return this.current.v === ")";
  }
  is_open_curly() {
    return this.current.v === "{";
  }
  is_close_curly() {
    return this.current.v === "}";
  }
  is_open_bracket() {
    return this.current.v === "[";
  }
  is_close_bracket() {
    return this.current.v === "]";
  }
  is_open_angle() {
    return this.current.v === "<";
  }
  is_close_angle() {
    return this.current.v === ">";
  }
  is_double_close_angle() {
    return this.current.v === ">>";
  }
  is_if() {
    return this.is_keyword("if");
  }
  is_else() {
    return this.is_keyword("else");
  }
  is_ret() {
    return this.is_keyword("return");
  }
  is_break() {
    return this.is_keyword("break");
  }
  is_when() {
    return this.is_keyword("when");
  }
  is_for() {
    return this.is_keyword("for");
  }
  is_in() {
    return this.is_keyword("in");
  }
  is_while() {
    return this.is_keyword("while");
  }
  is_bool() {
    return this.is_keyword("true") || this.is_keyword("false");
  }
  is_char() {
    return this.current.v[0] === "char";
  }
  is_str() {
    return this.current.v[0] === "str";
  }
  is_int() {
    return this.current.v[0] === "int";
  }
  is_float() {
    return this.current.v[0] === "float";
  }
  is_modifier() {
    const plus_or_minus = this.expect_plus() || this.expect_minus() && this.lookahead_n(2).v === ")";
    return this.is_open_paren() && plus_or_minus;
  }
  is_this() {
    return this.is_keyword("this");
  }
  is_keyword(id2) {
    return this.current.v[0] === "key" && this.current.v[1] === id2;
  }
  is_id() {
    return this.current.v[0] === "id";
  }
  is_id_pat() {
    return this.current.v[0] === "id";
  }
  is_bool_pat() {
    return this.current.v[0] === "bool";
  }
  is_char_pat() {
    return this.current.v[0] === "char";
  }
  is_str_pat() {
    return this.current.v[0] === "str";
  }
  is_int_pat() {
    return this.current.v[0] === "int";
  }
  is_float_pat() {
    return this.current.v[0] === "float";
  }
  is_tuple_pat() {
    return this.is_open_paren();
  }
  is_list_pat() {
    return this.is_open_bracket();
  }
  is_structl_pat() {
    return this.is_open_curly();
  }
  is_enum_pat() {
    return this.is_dot();
  }
  is_pat() {
    return this.is_bool_pat() || this.is_char_pat() || this.is_str_pat() || this.is_int_pat() || this.is_float_pat() || this.is_list_pat() || this.is_tuple_pat() || this.is_structl_pat() || this.is_enum_pat() || this.is_id_pat() || this.is_underscore();
  }
  is_assoc_fn() {
    if (!is_list\$2(this.current.v)) {
      return;
    }
    return this.is_fn() && this.lookahead().v === "^";
  }
  is_method() {
    if (!is_list\$2(this.current.v)) {
      return;
    }
    return this.is_fn() && this.lookahead().v !== "^";
  }
  expect_colon() {
    return this.lookahead().v === ":";
  }
  expect_comma() {
    return this.lookahead().v === ",";
  }
  expect_plus() {
    return this.lookahead().v === "+";
  }
  expect_minus() {
    return this.lookahead().v === "-";
  }
  expect_id() {
    const tk = this.lookahead().v;
    return tk[0] === "id";
  }
  expect_str() {
    const tk = this.lookahead().v;
    return tk[0] === "str";
  }
  expect_eof() {
    return this.lookahead().v === "\$eof";
  }
  expect_close_paren() {
    return this.lookahead().v === ")";
  }
  expect_close_bracket() {
    return this.lookahead().v === "]";
  }
  expect_open_curly() {
    return this.lookahead().v === "{";
  }
  expect_close_curly() {
    return this.lookahead().v === "}";
  }
  expect_astrisk() {
    return this.lookahead().v === "*";
  }
  expect_asgmt() {
    return this.lookahead().v === "=";
  }
  maybe_asgmt() {
    if (this.is_asgmt()) {
      this.next();
      return true;
    }
  }
  maybe_comma() {
    if (this.is_comma()) {
      this.next();
      return true;
    }
  }
  optional_comma() {
    if (this.is_newline() || this.is_close_curly() || this.is_close_paren() || this.is_close_bracket() || this.is_close_angle() || this.is_thin_arrow() || this.is_thick_arrow()) {
      return this.maybe_comma();
    } else {
      return this.req_comma();
    }
  }
  maybe_colon() {
    if (this.is_colon()) {
      this.next();
      return true;
    }
  }
  maybe_open_curly() {
    if (this.is_open_curly()) {
      this.next();
      return true;
    }
  }
  maybe_id() {
    if (this.is_id()) {
      const id2 = this.current;
      this.next();
      return id2;
    }
  }
  maybe_asterisk() {
    if (this.is_asterisk()) {
      this.current;
      this.next();
      return this.asterisk;
    }
  }
  maybe_open_paren() {
    if (is_open_paren()) {
      this.next();
      return true;
    }
  }
  maybe_modifier() {
    if (!this.is_modifier()) {
      return;
    }
    this.next();
    const n = new Node("modif", "", this.current);
    this.next();
    this.req_close_paren();
    this.ast.push(n);
    return true;
  }
  maybe_attrs() {
    while (this.is_hash()) {
      this.skip();
      const id2 = this.maybe_id();
      if (!this.id) {
        panic\$2("expecting an id: " + to_str\$2(this.current));
      }
      this.attrs.push(id2);
      if (this.lookahead().v !== ",") {
        return null;
      } else {
        this.skip();
      }
    }
    if (this.attrs.length > 0) {
      return true;
    }
  }
  maybe_pat() {
    if (this.is_pat()) {
      return this.prim_pat();
    }
  }
  req_in() {
    if (this.is_in()) {
      this.next();
      return true;
    } else {
      panic\$2('expecting "in" : ' + to_str\$2(this.current));
    }
  }
  req_asgmt() {
    if (!this.maybe_asgmt()) {
      panic\$2("expecting '=' : " + to_str\$2(this.current));
    }
    return true;
  }
  req_comma() {
    if (this.is_comma()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ',' after : " + to_str\$2(this.current));
    }
  }
  req_backtick() {
    if (this.is_backtick()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '\`' after : " + to_str\$2(this.current));
    }
  }
  req_tbacktick() {
    if (this.is_tbacktick()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '\`\`\`' after : " + to_str\$2(this.current));
    }
  }
  req_terminator() {
    return this.is_newline() || this.is_eof();
  }
  req_open_paren() {
    if (this.is_open_paren()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '(' : " + to_str\$2(this.current));
    }
  }
  req_close_paren() {
    if (this.is_close_paren()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ')' : " + to_str\$2(this.current));
    }
  }
  req_open_curly() {
    if (this.is_open_curly()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '{' : " + to_str\$2(this.current));
    }
  }
  req_close_curly() {
    if (this.is_close_curly()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '}' : " + to_str\$2(this.current));
    }
  }
  req_close_angle() {
    if (this.is_close_angle()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '>' : " + to_str\$2(this.current));
    }
  }
  req_colon() {
    if (this.is_colon()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting a colon ':' " + to_str\$2(this.current));
    }
  }
  req_dcolon() {
    if (this.is_dcolon()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting a double colon '::' " + to_str\$2(this.current));
    }
  }
  req_open_bracket() {
    if (this.is_open_bracket()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '[' : " + to_str\$2(this.current));
    }
  }
  req_close_bracket() {
    if (this.is_close_bracket()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting ']' : " + to_str\$2(this.current));
    }
  }
  req_thin_arrow() {
    if (this.is_thin_arrow()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '->' : " + to_str\$2(this.current));
    }
  }
  req_thick_arrow() {
    if (this.is_thick_arrow()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting '=>' : " + to_str\$2(this.current));
    }
  }
  req_then() {
    if (this.is_then()) {
      this.next();
      return true;
    } else {
      panic\$2("expecting 'then' : " + to_str\$2(this.current));
    }
  }
  req_pat() {
    const _pat2 = this.maybe_pat();
    if (_pat2) {
      return _pat2;
    } else {
      panic\$2("expecting a pattern: " + to_str\$2(this.current));
    }
  }
  prim_pat() {
    if (this.is_underscore()) {
      const n = new Node("_", "pat", "");
      this.next();
      return n;
    } else if (this.is_bool_pat()) {
      return this.bool_pat();
    } else if (this.is_char_pat()) {
      return this.char_pat();
    } else if (this.is_str_pat()) {
      return this.str_pat();
    } else if (this.is_int_pat()) {
      return this.int_pat();
    } else if (this.is_float_pat()) {
      return this.float_pat();
    } else if (this.is_list_pat()) {
      return this.list_pat();
    } else if (this.is_tuple_pat()) {
      return this.tuple_pat();
    } else if (this.is_structl_pat()) {
      return this.structl_pat();
    } else if (this.is_enum_pat()) {
      return this.enum_pat();
    } else if (this.is_id_pat()) {
      return this.id_pat();
    }
  }
  bool_pat() {
    const n = new Node("bool", "pat", this.current);
    this.next();
    return n;
  }
  char_pat() {
    const n = new Node("char", "pat", this.current);
    this.next();
    return n;
  }
  str_pat() {
    const n = new Node("str", "pat", this.current);
    this.next();
    return n;
  }
  int_pat() {
    const n = new Node("int", "pat", this.current);
    this.next();
    return n;
  }
  float_pat() {
    const n = new Node("float", "pat", this.current);
    this.next();
    return n;
  }
  list_pat() {
    if (!this.is_open_bracket()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        if (!this.req_comma()) {
          return;
        }
      }
      const _pat2 = this.maybe_pat();
      if (_pat2) {
        return items.push(_pat2);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_bracket();
    const n = new Node("[", "pat", items);
    return n;
  }
  tuple_pat() {
    if (!this.is_open_paren()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.maybe_pat();
      if (_pat2) {
        return items.push(_pat2);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_paren();
    const n = new Node("(", "pat", items);
    return n;
  }
  structl_pat() {
    if (!this.is_open_curly()) {
      return;
    }
    this.next();
    const items = [];
    this.maybe_comma();
    while (true) {
      if (items.length > 0) {
        this.maybe_comma() || this.req_terminator();
      }
      const id2 = this.maybe_id();
      if (!id2) {
        break;
      }
      let v2;
      if (this.is_colon()) {
        this.next();
        v2 = this.req_pat();
      }
      const el = new StructLEl(id2, v2);
      items.push(el);
    }
    this.maybe_comma();
    this.req_close_curly();
    const n = new Node("{", "pat", items);
    return n;
  }
  enum_pat() {
    panic\$2("enum patterns are not supported yet");
    const id2 = this.current;
    this.next();
    const p = new EnumPat(id2, _pat);
    if (_pat) {
      const n = new Node("enum_pat", "pat", p);
      return n;
    }
  }
  id_pat() {
    const id2 = this.current;
    this.next();
    const n = new Node("id", "pat", id2);
    return n;
  }
  req_body() {
    this.req_open_curly();
    const stmts = this.stmts();
    this.req_close_curly();
    const n = new Node("body", "body", stmts);
    return n;
  }
  req_body_ret() {
    const body = this.req_body();
    this.implicit_return(body.v);
    return body;
  }
  maybe_stmt() {
    if (this.is_eof() || this.is_modifier()) {
      return;
    }
    return this.maybe_break() || this.maybe_const() || this.maybe_let() || this.maybe_expr() || this.maybe_semicolon() || this.maybe_for();
  }
  req_stmts() {
    const token = this.current;
    const stmts = this.stmts();
    if (is_empty(stmts)) {
      panic\$2("expecting a statement : " + to_str\$2(token));
    } else {
      return stmts;
    }
  }
  stmts() {
    let _stmts = [];
    let stmt;
    while (true) {
      stmt = this.maybe_stmt();
      if (stmt) {
        _stmts.push(stmt);
      }
      if (!stmt) {
        break;
      }
    }
    return _stmts;
  }
  maybe_ret() {
    if (!this.is_ret()) {
      return;
    }
    this.next();
    const expr = this.maybe_expr();
    const n = new Node("return", "expr", expr);
    return n;
  }
  maybe_break() {
    if (!this.is_break()) {
      return;
    }
    this.next();
    const n = new Node("break", "stmt", null);
    return n;
  }
  maybe_global_const() {
    let c = this.maybe_const();
    if (c) {
      this.ast.push(c);
      return true;
    }
    return false;
  }
  maybe_global_fn() {
    let fn = this.maybe_fn();
    if (fn) {
      this.ast.push(fn);
      return true;
    }
    return false;
  }
  maybe_trait() {
    if (!this.is_trait()) {
      return;
    }
    this.next();
    let id2 = this.req_id();
    let sigs = [];
    let fns = [];
    while (!this.is_eof() || !this.is_close_curly()) {
      const fn_or_sig = this.maybe_fn_or_sig();
      if (fn_or_sig.id === "fn_sig") {
        sig.push(fn_or_sig);
      } else if (fn_or_sig.id === "fn") {
        fns.push(fn_or_sig);
      } else {
        panic\$2("expecting function or signature.");
      }
    }
    this.req_close_curly();
    const trait = new Trait(id2, fns, sigs);
    const n = new Node("trait", "def", trait);
    this.ast.push(n);
  }
  maybe_impl() {
    if (!this.is_at()) {
      return;
    }
    this.next();
    let t = this.req_type();
    return this.is_id() ? this.req_trait_impl(t) : this.req_methods(t);
  }
  req_methods(t) {
    if (this.maybe_open_curly()) {
      while (!this.is_eof() || !this.is_close_curly()) {
        const fn = this.maybe_fn();
        const method = new Method(t, fn);
        const n = new Node("method", "def", method);
        this.ast.push(n);
      }
      this.req_close_curly();
    } else {
      const method = new Method(t, this.req_fn());
      this.ast.push(new Node("method", "def", method));
    }
    return true;
  }
  req_trait_impl(t) {
    if (this.maybe_open_curly()) {
      let methods = [];
      while (!this.is_eof() || !this.is_close_curly()) {
        const fn = this.maybe_fn();
        const method = new Method(type, fn);
        methods.push(method);
      }
      const n = new Node("method", "def", methods);
      this.ast.push(n);
      this.req_close_curly();
    } else {
      const method = new Method(t, this.req_fn());
      this.ast.push(new Node("trait_impl", "def", method));
    }
    return true;
  }
  maybe_const() {
    if (!this.is_const()) {
      return;
    }
    this.next();
    const _pat2 = this.req_pat();
    const t = this.maybe_tannotation();
    this.req_asgmt();
    const rhs = this.req_expr();
    const asgmt = new Asgmt(_pat2, t, rhs);
    const n = new Node("const", "stmt", asgmt);
    return n;
  }
  maybe_let() {
    if (!this.is_let()) {
      return;
    }
    this.next();
    const _pat2 = this.req_pat();
    const t = this.maybe_tannotation();
    let eq = this.maybe_asgmt();
    let rhs;
    if (eq) {
      rhs = this.req_expr();
    }
    const asgmt = new Asgmt(_pat2, t, rhs);
    const n = new Node("var", "stmt", asgmt);
    return n;
  }
  req_expr() {
    const token = this.current;
    const expr = this.maybe_expr();
    if (expr) {
      return expr;
    } else {
      panic\$2("expecting expression : " + to_str\$2(token));
    }
  }
  maybe_do_block_ret() {
    const block = this.maybe_do_block();
    if (block) {
      this.implicit_return(block.v);
      return block;
    }
  }
  req_do_block_ret() {
    const block = this.req_do_block();
    this.implicit_return(block.v);
    return block;
  }
  maybe_do_block() {
    if (!this.is_do()) {
      return;
    }
    this.next();
    const stmts = [];
    this.req_open_curly();
    while (true) {
      if (this.is_eof() || this.is_close_curly()) {
        break;
      }
      const stmt = this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        break;
      }
    }
    this.req_close_curly();
    const n = new Node("do_block", "expr", stmts);
    return n;
  }
  req_do_block() {
    const token = this.current;
    const expr = this.maybe_do_block();
    if (expr) {
      return expr;
    } else {
      panic\$2("expecting 'do' block : " + to_str\$2(token));
    }
  }
  maybe_block() {
    if (!this.is_open_curly()) {
      return;
    }
    this.next();
    const stmts = [];
    while (true) {
      if (this.is_eof() || this.is_end()) {
        break;
      }
      const stmt = this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        break;
      }
    }
    this.implicit_return(stmts);
    this.req_end();
    const n = new Node("block", "expr", stmts);
    return n;
  }
  maybe_semicolon() {
    if (!this.is_semicolon()) {
      return;
    }
    const tk = this.next();
    const n = new Node(";", "expr", tk);
    return n;
  }
  is_bin_op() {
    if (this.current.v === "(" || this.current.v === "{" || this.current.v === "[") {
      if (!this.is_newline()) {
        return true;
      }
    } else {
      return contains\$2(BIN_OP, this.current.v);
    }
  }
  is_postfix_uni_op() {
    return contains\$2(POSTFIX_UNI_OP, this.current.v);
  }
  req_list_index() {
    const expr = this.req_expr();
    if (expr) {
      if (this.req_close_bracket()) {
        return expr;
      }
    } else {
      panic\$2("expecting  an index [...]: " + to_str\$2(this.current));
    }
  }
  req_access(lopr) {
    let n = this.req_expr();
    return n;
  }
  req_call_args() {
    const args = [];
    while (true) {
      if (this.is_eof() || this.is_close_paren()) {
        break;
      }
      if (args.length > 0) {
        if (this.is_newline()) {
          this.maybe_comma();
        } else {
          this.req_comma();
        }
      }
      let expr = this.maybe_expr();
      if (expr) {
        args.push(expr);
      }
    }
    this.req_close_paren();
    const n = new Node("args", "expr", args);
    return n;
  }
  maybe_lopr_prefix_postfix(expr, postfix_op) {
    const opr = expr.v.opr;
    const op = expr.v.op;
    if (expr.id === "prefix") {
      if (this.prec_uni(postfix_op) >= this.prec_uni(op)) {
        const postfix = new Uni(opr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        const prefix = new Uni(postfix_n, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        this.next();
        return prefix_n;
      } else {
        const postfix = new Uni(expr, postfix_op);
        const n = new Node("postfix", "expr", postfix);
        this.next();
        return n;
      }
    }
  }
  maybe_lopr_bin_postfix(expr, postfix_op) {
    if (expr.id === "bin") {
      const op = expr.v.op;
      const ropr = expr.v.ropr;
      const lopr = expr.v.lopr;
      if (this.prec_uni(postfix_op) >= this.prec_bin(op)) {
        const postfix = new Uni(ropr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        const bin = new Bin(lopr, op, postfix_n);
        const bin_n = new Node("bin", "expr", bin);
        this.next();
        return bin_n;
      } else {
        const postfix = new Uni(expr, postfix_op);
        const postfix_n = new Node("postfix", "expr", postfix);
        this.next();
        return postfix_n;
      }
    }
  }
  maybe_lopr_prefix_bin(expr, bin_op) {
    const op = expr.v.op;
    let opr = expr.v.opr;
    if (expr.id === "prefix") {
      if (this.prec_uni(op) >= this.prec_bin(bin_op)) {
        opr = this.req_op(opr);
        const prefix = new Uni(opr, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        return prefix_n;
      } else {
        const ropr = this.req_ropr(expr);
        const bin = new Bin(opr, bin_op, ropr);
        const bin_n = new Node("bin", "expr", bin);
        const prefix = new Uni(bin_n, op);
        const prefix_n = new Node("prefix", "expr", prefix);
        return prefix_n;
      }
    }
  }
  get_lopr(lopr, op) {
    let opr = this.maybe_lopr_prefix_postfix(lopr, op);
    if (!opr) {
      opr = this.maybe_lopr_bin_postfix(lopr, op);
      if (!opr) {
        const postfix = new Uni(lopr, op);
        opr = new Node("postfix", "expr", postfix);
        this.next();
      }
    }
    return opr;
  }
  req_ropr(lopr) {
    let ropr;
    const token = this.current;
    if (this.is_open_bracket()) {
      this.next();
      ropr = this.req_list_index();
    } else if (this.is_dot()) {
      this.next();
      ropr = this.req_access(lopr);
    } else if (this.is_open_paren()) {
      this.next();
      ropr = this.req_call_args();
    } else if (this.is_thick_arrow()) {
      this.next();
      ropr = this.req_anonymous_method();
    } else {
      this.next();
      ropr = this.maybe_expr();
    }
    if (!ropr) {
      panic\$2("expecting right operand: " + to_str\$2(token));
    }
    return ropr;
  }
  prec_uni(v2) {
    switch (v2.v) {
      case "...":
        return 70;
      case "%":
        return 60;
      case ".":
        return 50;
      case "!":
      case "?":
        return 16;
      case "+":
      case "-":
      case "_!":
      case "not":
        return 15;
      case "⏎":
        return 0;
      default:
        panic\$2("unexpected unary operator: " + to_str\$2(v2));
    }
  }
  prec_bin(v2) {
    switch (v2.v) {
      case "[":
        return 20;
      case "(":
      case "{":
        return 19;
      case ".":
        return 18;
      case "*":
      case "×":
      case "/":
      case "÷":
        return 13;
      case "+":
      case "-":
      case "::":
      case "++":
        return 12;
      case "<":
      case "<=":
      case ">":
      case ">=":
        return 11;
      case "==":
      case "!=":
        return 10;
      case "<<":
      case ">>":
        return 8;
      case "&":
        return 7;
      case "**":
      case "⊕":
        return 6;
      case "|":
        return 5;
      case "&&":
        return 4;
      case "||":
        return 3;
      case "|>":
      case "||>":
      case ":>":
      case "=>":
        return 2;
      case "=":
      case "~=":
      case "+=":
      case "-=":
      case "*=":
      case "×=":
      case "/=":
      case "÷=":
      case "&=":
      case "|=":
      case "^=":
      case ">>=":
      case "<<=":
      case ":=":
        return 1;
      default:
        panic\$2("unexpected binary operator: " + to_str\$2(v2));
    }
  }
  is_bin_rassoc(v2) {
    return contains\$2(BIN_R_ASSOC, v2);
  }
  maybe_op(lopr) {
    const op = this.current;
    if (this.is_postfix_uni_op()) {
      return this.get_lopr(lopr, op);
    } else if (this.is_bin_op()) {
      const opr = this.maybe_lopr_prefix_bin(lopr, op);
      if (opr) {
        return opr;
      }
      let ropr = this.req_ropr(lopr);
      if (ropr) {
        if (ropr.id === "bin") {
          ropr = this.while_op(ropr, this.prec_bin(ropr.v.op) > this.prec_bin(op) || this.prec_bin(ropr.v.op) === this.prec_bin(op) && this.is_bin_rassoc(ropr.v.op));
        } else if (ropr.id === "prefix") {
          ropr = this.while_op(ropr, this.prec_bin(op) > this.prec_uni(ropr.v.op) || this.is_bin_rassoc(op));
        } else {
          ropr = this.while_op(ropr, false);
        }
      }
      const bin = new Bin(lopr, op, ropr);
      const n = new Node("bin", "expr", bin);
      return n;
    }
  }
  req_op(lopr) {
    const op = this.maybe_op(lopr);
    if (op) {
      return op;
    }
    panic\$2("expect an operation: " + to_str\$2(this.lookahead()));
  }
  while_op(lopr, cond) {
    let expr = clone(lopr);
    if (this.is_eof()) {
      return expr;
    }
    while (this.is_bin_op() || this.is_postfix_uni_op()) {
      if (cond === false) {
        break;
      }
      expr = this.req_op(expr);
    }
    return expr;
  }
  maybe_expr() {
    let expr = this.maybe_prim();
    if (expr) {
      expr = this.while_op(expr);
      return expr;
    }
  }
  req_id() {
    const id2 = this.maybe_id();
    if (id2) {
      return id2;
    } else {
      panic\$2("expecting an ID: " + to_str\$2(this.current));
    }
  }
  maybe_void() {
    if (this.is_void()) {
      this.next();
      const n = new Node("void", "expr");
      return n;
    }
  }
  req_anonymous_fn() {
    const fn = this.maybe_anonymous_fn();
    if (fn) {
      return fn;
    } else {
      panic\$2("expecting an anonymous function : " + to_str\$2(this.current));
    }
  }
  maybe_anonymous_fn() {
    if (!this.is_tilde()) {
      return;
    }
    this.next();
    const params2 = [];
    let open_paren = this.maybe_open_paren();
    this.maybe_comma();
    while (true) {
      if (this.is_close_paren() || this.is_eof()) {
        break;
      }
      if (params2.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.req_pat();
      const t = this.maybe_tannotation();
      const param = new FnParam(_pat2, t);
      const n2 = new Node("param", "pat", param);
      if (_pat2.id !== "id") {
        panic\$2("only parameters with id patterns are currently supported");
      }
      params2.push(n2);
    }
    this.maybe_comma();
    if (open_paren) {
      this.req_close_paren();
    }
    const ret_types = this.maybe_fn_ret_types();
    const body = this.req_body_ret();
    const _afn = new Fn("", params2, ret_types, body);
    const n = new Node("afn", "expr", _afn);
    return n;
  }
  maybe_tuple_group() {
    if (this.is_open_paren()) {
      const loc = this.current.loc;
      this.next();
      if (this.is_id() && this.expect_colon()) {
        return this.req_named_tuple();
      } else {
        let expr = null;
        expr = this.maybe_expr();
        if (expr) {
          let arg = expr;
          if (this.is_comma()) {
            const tuple = [arg];
            while (true) {
              const comma_close_paren = this.is_comma() && this.expect_close_paren();
              if (this.is_eof() || this.is_close_paren() || comma_close_paren) {
                break;
              }
              this.req_comma();
              arg = this.maybe_expr();
              if (arg) {
                tuple.push(arg);
              } else {
                panic\$2("expected an argument: " + loc);
              }
            }
            this.maybe_comma();
            this.req_close_paren();
            const n = new Node("tuple", "expr", tuple);
            return n;
          } else {
            this.req_close_paren();
            expr.grouped = true;
            return expr;
          }
        }
      }
    }
  }
  req_named_tuple() {
    let named_tuple = [];
    while (!(this.is_eof() || this.is_close_paren())) {
      let name = this.req_id();
      this.req_colon();
      let expr = this.req_expr();
      named_tuple.push([name, expr]);
      this.optional_comma();
    }
    this.req_close_paren();
    return new Node("named_tuple", "expr", named_tuple);
  }
  is_prefix_uni_op() {
    return contains\$2(PREFIX_UNI_OP, this.current.v);
  }
  maybe_prefix_uni_op() {
    if (this.is_prefix_uni_op()) {
      const op = this.current;
      this.next();
      const prefix = new Uni(this.req_prim(), op);
      const n = new Node("prefix", "expr", prefix);
      return n;
    }
  }
  maybe_literal() {
    let expr = this.maybe_primitivel();
    if (!expr) {
      expr = this.maybe_list();
    }
    if (!expr) {
      expr = this.maybe_tuple();
    }
    return expr;
  }
  maybe_primitivel() {
    let expr = this.maybe_bool();
    if (!expr) {
      expr = this.maybe_char();
    }
    if (!expr) {
      expr = this.maybe_str();
    }
    if (!expr) {
      expr = this.maybe_int();
    }
    if (!expr) {
      expr = this.maybe_float();
    }
    return expr;
  }
  maybe_bool() {
    if (this.is_bool()) {
      const n = new Node("bool", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_char() {
    if (this.is_char()) {
      const n = new Node("char", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_str() {
    if (this.is_str()) {
      const n = new Node("str", "expr", this.current);
      this.next();
      return n;
    }
  }
  maybe_int() {
    if (this.is_int()) {
      const num = this.current;
      this.next();
      let suffix;
      if (this.is_id() && !this.is_newline()) {
        suffix = this.current;
        this.next();
      }
      const n = new Node("int", "expr", [num, suffix]);
      return n;
    }
  }
  maybe_float() {
    if (this.is_float()) {
      const num = this.current;
      this.next();
      let suffix;
      if (this.is_id() && !this.is_newline()) {
        suffix = this.current;
        this.next();
      }
      const n = new Node("float", "expr", [num, suffix]);
      return n;
    }
  }
  maybe_list() {
    if (this.is_open_bracket()) {
      const els = [];
      this.next();
      this.maybe_comma();
      while (true) {
        const comma_close_bracket = this.is_comma() && this.expect_close_bracket();
        if (this.is_eof() || this.is_close_bracket() || comma_close_bracket) {
          break;
        }
        if (els.length > 0) {
          if (this.is_newline()) {
            this.maybe_comma();
          } else {
            this.req_comma();
          }
        }
        els.push(this.req_expr());
      }
      this.maybe_comma();
      this.req_close_bracket();
      const n = new Node("[", "expr", els);
      return n;
    }
  }
  maybe_tuple() {
    if (this.is_open_paren()) {
      const els = [];
      this.skip();
      this.maybe_comma();
      let named_tuple = false;
      if (this.is_id && this.expect_colon()) {
        named_tuple = true;
      }
      while (true) {
        if (els.length > 0) {
          this.req_comma();
        }
        let name;
        if (named_tuple) {
          name = this.req_id();
          this.req_colon();
        }
        let expr = this.req_expr();
        if (named_tuple) {
          els.push([name, expr]);
        } else {
          els.push([expr]);
        }
        if (this.is_close_paren()) {
          break;
        }
      }
      this.maybe_comma();
      this.req_close_paren();
      if (named_tuple) {
        return new Node("(:", "expr", els);
      } else {
        return new Node("(", "expr", els);
      }
    }
  }
  maybe_call(id2) {
    const maybe_args = () => {
      const args2 = [];
      if (!this.is_open_paren()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_paren())) {
        let arg_name;
        if (this.is_id() && this.expect_colon()) {
          arg_name = this.current;
          this.next();
          this.next();
        }
        let arg;
        if (arg_name) {
          arg = new Node("named_arg", "expr", [arg_name, this.req_expr()]);
        } else {
          arg = this.maybe_expr();
        }
        if (!arg) {
          break;
        }
        args2.push(arg);
        this.optional_comma();
      }
      this.req_close_paren();
      return args2;
    };
    const args = maybe_args();
    if (!args && (!this.is_tilde() || !this.is_colon())) {
      return;
    }
    if (!args) {
      args = [];
    }
    let trailing = [];
    while (true) {
      let closure = this.maybe_trailing_closure();
      if (closure) {
        trailing.push(closure);
      } else {
        break;
      }
    }
    const fn_call = new FnCall(id2, args, trailing);
    const n = new Node("call", "expr", fn_call);
    return n;
  }
  req_ref() {
    const id2 = this.current;
    this.next();
    const n = new Node("ref", "expr", id2);
    return n;
  }
  maybe_call_or_ref() {
    if (this.is_id()) {
      const ref = this.req_ref();
      return this.maybe_call(ref) || ref;
    }
  }
  maybe_when_arm() {
    const pats = [];
    while (!this.is_thin_arrow()) {
      pats.push(this.req_pat());
      if (this.is_bar()) {
        this.next();
      } else {
        break;
      }
    }
    this.req_thin_arrow();
    const expr = this.req_expr();
    const arm = new WhenArm(pats, expr);
    const n = new Node("arm", "", arm);
    return n;
  }
  maybe_when() {
    if (!this.is_when()) {
      return;
    }
    this.next();
    this.req_open_paren();
    const expr = this.maybe_expr();
    this.req_close_paren();
    this.req_open_curly();
    const arms = [];
    this.maybe_comma();
    while (true) {
      if (this.is_eof() || this.is_close_curly()) {
        break;
      }
      if (arms.length > 0) {
        this.optional_comma();
        if (this.is_eof() || this.is_close_curly()) {
          break;
        }
      }
      const arm = this.maybe_when_arm();
      if (arm) {
        arms.push(arm);
      } else {
        break;
      }
    }
    this.maybe_comma();
    this.req_close_curly();
    const _when = new When(expr, arms);
    const n = new Node("when", "expr", _when);
    return n;
  }
  maybe_for() {
    if (!this.is_for()) {
      return;
    }
    this.next();
    let stmt = this.maybe_for_inf();
    if (!stmt) {
      stmt = this.maybe_for_cond();
    }
    if (!stmt) {
      stmt = this.req_for_in();
    }
    return stmt;
  }
  maybe_for_inf() {
    if (!this.is_open_curly()) {
      return;
    }
    let body = this.req_body();
    let stmt = new ForInf(body);
    let n = new Node("for_inf", "stmt", stmt);
    return n;
  }
  maybe_for_cond() {
    const init2 = this.maybe_let();
    let expr;
    if (init2) {
      expr = this.req_expr();
    } else {
      expr = this.maybe_expr();
    }
    if (!expr) {
      return;
    }
    const body = this.req_body();
    let stmt = new ForCond(expr, body);
    let n = new Node("for_cond", "stmt", stmt);
    return n;
  }
  req_for_in() {
    const pat = this.req_pat();
    this.req_in();
    const expr = this.req_expr();
    let body = this.req_body();
    let stmt = new ForIn(pat, expr, body);
    let n = new Node("for_in", "stmt", stmt);
    return n;
  }
  req_anonymous_method() {
    const maybe_field_asgmt = () => {
      if (!this.is_id() || this.lookahead().v !== ":") {
        return;
      }
      let id2 = this.req_id();
      this.req_colon();
      let expr = this.req_expr();
      const bin = new FieldAsgmt(id2, expr);
      return bin;
    };
    if (this.is_open_curly()) {
      this.next();
    } else {
      panic\$2("expecting ',' after : " + to_str\$2(this.current));
    }
    let stmts = [];
    while (!this.is_eof() || !this.is_close_curly()) {
      let stmt = maybe_field_asgmt() || this.maybe_stmt();
      if (stmt) {
        stmts.push(stmt);
      } else {
        panic\$2("expected a statement : " + to_str\$2(this.current));
      }
    }
    let amethod = new AnonymousMethod(stmts);
    this.req_close_curly();
    let n = new Node("amethod", "expr", amethod);
    return n;
  }
  maybe_trailing_closure() {
    if (!this.is_colon() || !this.is_tilde()) {
      return;
    }
    let label;
    if (this.is_colon()) {
      this.next();
      label = this.req_id();
    }
    let fn = this.req_anonymous_fn();
    return new TrailingClosure(label, fn);
  }
  maybe_prim() {
    let expr = this.maybe_void();
    if (!expr) {
      expr = this.maybe_tuple_group();
    }
    if (!expr) {
      expr = this.maybe_prefix_uni_op();
    }
    if (!expr) {
      expr = this.maybe_call_or_ref();
    }
    if (!expr) {
      expr = this.maybe_literal();
    }
    if (!expr) {
      expr = this.maybe_when();
    }
    if (!expr) {
      expr = this.maybe_do_block_ret();
    }
    if (!expr) {
      expr = this.maybe_ret();
    }
    if (!expr) {
      expr = this.maybe_semicolon();
    }
    return expr;
  }
  req_prim() {
    const prim = this.maybe_prim();
    if (!prim) {
      panic\$2("expecting an expression: " + to_str\$2(this.current));
    }
    return prim;
  }
  maybe_fn() {
    if (!this.is_fn()) {
      return;
    }
    const _fn = this.req_fn();
    if (_fn && contains\$2(["main", "بدء"], _fn.v.name.v[1])) {
      const n = new Node("main", "fn", _fn.v);
      return n;
    } else {
      const n = new Node("fn", "fn", _fn.v);
      return n;
    }
  }
  maybe_use() {
    if (!this.is_use()) {
      return;
    }
    this.next();
    const path = [];
    if (!this.is_id()) {
      return false;
    }
    while (this.is_id()) {
      path.push(this.current);
      this.next();
      if (this.is_dot()) {
        this.skip();
        if (!this.is_id()) {
          panic\$2("expecting an idnetifier after " + to_str\$2(this.current));
        }
      } else {
        break;
      }
    }
    const n = new Node("use", "stmt", path);
    this.ast.push(n);
    return true;
  }
  maybe_optional() {
    if (this.is_question()) {
      this.next();
      return true;
    }
  }
  maybe_simple_type() {
    if (this.is_id()) {
      let n;
      const t = this.req_id();
      if (this.is_open_angle()) {
        const ts = [];
        this.next();
        this.maybe_comma();
        while (true) {
          if (this.is_eof() || this.is_close_angle()) {
            break;
          }
          if (ts.length > 0) {
            this.req_comma();
          }
          ts.push(this.req_type());
        }
        this.maybe_comma();
        this.req_close_angle();
        const _type = new TypeTempl(t, ts, this.maybe_optional());
        n = new Node("<", "t", _type);
      } else {
        const _type = new Type(t, this.maybe_optional());
        n = new Node("t", "t", _type);
      }
      return n;
    }
  }
  maybe_list_type() {
    if (this.is_open_bracket()) {
      this.next();
      const t = this.req_type();
      this.req_close_bracket();
      const _type = new Type(t, this.maybe_optional());
      return new Node("[", "t", _type);
    }
  }
  maybe_type() {
    return this.maybe_simple_type() || this.maybe_list_type();
  }
  req_type() {
    let n = this.maybe_type();
    if (!n) {
      panic\$2("type required: " + to_str\$2(this.current));
    }
    return n;
  }
  maybe_tannotation() {
    if (!this.is_colon()) {
      return;
    }
    this.next();
    return this.maybe_type();
  }
  req_tannotation() {
    const tannotation = this.maybe_tannotation();
    if (!tannotation) {
      panic\$2("requires type annotation: " + to_str\$2(this.current));
    }
    return tannotation;
  }
  maybe_fn_params() {
    const params2 = [];
    if (!this.is_open_paren()) {
      return params2;
    }
    this.next();
    this.maybe_comma();
    while (true) {
      if (this.is_close_paren() || this.is_eof()) {
        break;
      }
      if (params2.length > 0) {
        this.req_comma();
      }
      const _pat2 = this.req_pat();
      const t = this.maybe_tannotation();
      const param = new FnParam(_pat2, t);
      const n = new Node("param", "pat", param);
      if (_pat2.id !== "id") {
        panic\$2("only parameters with id patterns are currently supported");
      }
      params2.push(n);
    }
    this.maybe_comma();
    this.req_close_paren();
    return params2;
  }
  maybe_fn_ret_types() {
    const ret_types = [];
    if (this.is_thin_arrow()) {
      this.next();
      while (this.is_id()) {
        let id2 = this.next();
        if (this.is_exclamation()) {
          this.next();
          ret_types.push({
            id: id2,
            _t: "throw"
          });
        } else {
          ret_types.push({
            id: id2,
            _t: "ret_type"
          });
        }
        this.optional_comma();
      }
    }
    return ret_types;
  }
  req_fn() {
    let sig2 = this.maybe_fn_sig();
    if (sig2) {
      sig2 = sig2.v;
    } else {
      return;
    }
    const body = this.req_body_ret();
    const _fn = new Fn(sig2.name, sig2.params, sig2.ret_types, body);
    const n = new Node("fn", "def", _fn);
    return n;
  }
  maybe_fn_sig() {
    if (!this.is_fn()) {
      return;
    }
    this.next();
    const name = this.req_id();
    this.symtab.insert_fn(name.v[1]);
    const params2 = this.maybe_fn_params();
    const ret_types = this.maybe_fn_ret_types();
    const fn_sig = new FnSig(name, params2, ret_types);
    const n = new Node("fn_sig", "def", fn_sig);
    return n;
  }
  maybe_fn_or_sig() {
    let sig2 = this.maybe_fn_sig();
    if (sig2) {
      if (this.is_open_curly()) {
        const body = this.req_body_ret();
        const _fn = new Fn(sig2.name, sig2.params, sig2.ret_types, body);
        const n = new Node("fn", "def", _fn);
        return n;
      } else {
        return sig2;
      }
    }
  }
  maybe_struct() {
    const maybe_fields = () => {
      const fields2 = [];
      if (!this.is_open_curly()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_curly())) {
        let field_name;
        if (this.is_id()) {
          field_name = this.req_id();
        } else if (this.is_open_paren()) {
          this.next();
          field_name = this.req_id();
          this.req_close_paren();
        }
        this.req_colon();
        let n2;
        let field = new Field(field_name, this.req_type());
        if (field_name) {
          n2 = new Node("field", "def", field);
        }
        if (!n2) {
          const type2 = this.maybe_list_type();
          if (type2) {
            const id22 = { v: ["id", "sn__"], loc: { "line": 0, "column": 0 } };
            let field2 = new Field(id22, type2);
            n2 = new Node("field", "def", field2);
          }
          if (n2) {
            fields2.push(n2);
          }
          break;
        }
        fields2.push(n2);
        this.optional_comma();
      }
      this.req_close_curly();
      return fields2;
    };
    if (!this.is_struct()) {
      return;
    }
    this.next();
    const id2 = this.req_id();
    this.symtab.insert_struct(id2.v[1]);
    let fields = maybe_fields() || [];
    if (!fields) {
      return;
    }
    const _t = new Struct(id2, fields);
    const n = new Node("struct", "def", _t);
    this.ast.push(n);
    return true;
  }
  maybe_enum() {
    const maybe_inner_type = () => {
      if (!this.is_open_paren()) {
        return;
      }
      this.next();
      let _t2 = this.maybe_type();
      this.req_close_paren();
      return _t2;
    };
    const maybe_variants = () => {
      const variants2 = [];
      if (!this.is_open_curly()) {
        return;
      }
      this.next();
      while (!(this.is_eof() || this.is_close_curly())) {
        let variant_name;
        if (this.is_id()) {
          variant_name = this.current;
          this.next();
        }
        let variant;
        if (variant_name) {
          variant = new Node("variant", "def", [variant_name, maybe_inner_type()]);
        }
        if (!variant) {
          break;
        }
        variants2.push(variant);
        this.optional_comma();
      }
      this.req_close_curly();
      return variants2;
    };
    if (!this.is_enum()) {
      return;
    }
    this.next();
    const id2 = this.req_id();
    this.symtab.insert_enum(id2.v[1]);
    let variants = maybe_variants() || [];
    if (!variants) {
      return;
    }
    const _t = new Enum(id2, variants);
    const n = new Node("enum", "def", _t);
    this.ast.push(n);
    return true;
  }
  implicit_return(_stmts) {
    if (!_stmts || _stmts.length <= 0) {
      return;
    }
    const last_index = _stmts.length - 1;
    const last = _stmts[last_index];
    if (contains\$2(["when", "while", "if", "for", "return", "let", "var", "const"], last.id) || last.id === "bin" && last.v.op.v === ":=") {
      return;
    }
    if (last.id === ";") {
      return;
    }
    if (last.id === "bin" && last.v.op.v === "=") {
      return;
    }
    if (last.id === "bin" && last.v.lopr.id === "ref" && contains\$2(["println", "اطبع_سطر"], last.v.lopr.v.v[1])) {
      return;
    }
    if (last.t === "expr") {
      const n = new Node("iret", "expr", last);
      return replace(_stmts, last_index, n);
    }
  }
}
class Semantic {
  ast;
  symtab;
  constructor(ast, symtab) {
    this.ast = ast;
    this.symtab = symtab;
  }
  run() {
    console.log(JSON.stringify(this.symtab.root));
  }
}
const HYPHENATED = [
  "min_width",
  "min_height",
  "background_color",
  "background_image",
  "background_position",
  "background_repeat",
  "background_size",
  "background_attachment",
  "_webkite_background_size",
  "aspect_ratio",
  "border_right",
  "border_left",
  "border_top",
  "border_bottom",
  "border_radius",
  "border_style",
  "margin_top",
  "margin_bottom",
  "margin_right",
  "margin_left",
  "align_items",
  "text_align",
  "justify_content",
  "justify_items",
  "text_justify",
  "object_fit",
  "font_size",
  "font_family",
  "box_sizing",
  "scrollbar_width",
  "user_select",
  "_ms_user_select",
  "_webkit_user_select",
  "_moz_user_select",
  "box_shadow",
  "_webkit_box_shadow",
  "_moz_box_shadow",
  "no_repeat",
  "border_box",
  "space_between",
  "flex_direction",
  "inter_word"
];
const BOOL_ATTRS = [
  "readonly"
];
const ELEMENTS_WITH_DIR = [
  "Html",
  "Body",
  "Div",
  "Span",
  "P",
  "Textarea",
  "Field"
];
const MAGHRIB_DIGIT\$1 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
function is_maghrib_num\$1(n) {
  return contains\$1(MAGHRIB_DIGIT\$1, n[0]);
}
function to_maghrib_num\$1(n) {
  if (!is_maghrib_num\$1(n)) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "٠":
          v2 += "0";
          break;
        case "١":
          v2 += "1";
          break;
        case "٢":
          v2 += "2";
          break;
        case "٣":
          v2 += "3";
          break;
        case "٤":
          v2 += "4";
          break;
        case "٥":
          v2 += "5";
          break;
        case "٦":
          v2 += "6";
          break;
        case "٧":
          v2 += "7";
          break;
        case "٨":
          v2 += "8";
          break;
        case "٩":
          v2 += "9";
          break;
        case ",":
          v2 += ".";
          break;
        default:
          panic\$1();
      }
      i += 1;
    }
    return v2;
  } else {
    return n;
  }
}
function is_list\$1(x) {
  return x instanceof Array;
}
function contains\$1(list, el) {
  return list.includes(el);
}
function to_str\$1(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function panic\$1(v2) {
  throw new Error(v2);
}
class HtmlWriter {
  jsGen;
  constructor(jsGen) {
    jsGen.init();
    this.jsGen = jsGen;
    return this;
  }
  write_html(el, page) {
    switch (el.id) {
      case "call":
        let tag = el.v[0].v.v[1];
        let attrs = el.v[1] || [];
        let children = el.v[2] || [];
        if (tag === "Br") {
          return page += "<br>";
        }
        switch (tag) {
          case "Select":
            page = this.write_css(attrs, page) + "} ";
            break;
          case "FontFace":
            page = this.write_css_fontface(attrs, page);
            break;
          case "Keyframes":
            page = this.write_css_keyframes(attrs, children, page);
            break;
          default:
            page += \`<\${tag}\`;
            attrs.forEach((attr, i) => {
              if (i === 0 && attr.id === "str") {
                page += \` id='\${attr.v.v[1]}'\`;
              } else if (attr.id === "named_arg") {
                const attr_name = attr.v[0].v[1];
                if (BOOL_ATTRS.includes(attr_name)) {
                  page += \` \${attr_name} \`;
                } else {
                  page += \` \${attr_name}= \`;
                  if (attr.v[1].id === "str") {
                    page += \`'\${attr.v[1].v.v[1]}'\`;
                  } else if (attr.v[1].id === "int" || attr.v[1].id === "float") {
                    const num = attr.v[1].v[0].v[1];
                    const suffix = attr.v[1].v[1].v[1] || "";
                    page += \`\${num}\${suffix}\`;
                  } else if (attr.v[1].id === "bool") {
                    page += \`\${attr_name}\`;
                  } else {
                    panic\$1("not supported: " + to_str\$1(attr));
                  }
                }
              } else {
                panic\$1("not supported: " + to_str\$1(attr));
              }
            });
            page += ">";
            children.forEach((c) => {
              page = this.write_html(c, page);
            });
            page += \`</\${tag}>\`;
        }
        break;
      case "str":
        page += el.v.v[1];
        break;
      default:
        panic\$1("unknown html element: " + to_str\$1(el));
    }
    return page;
  }
  write_css(attrs, page) {
    attrs.forEach((attr) => {
      const k = maybe_hyphenated(attr.v[0].v[1]);
      const v2 = attr.v[1];
      if (k === "element") {
        page = this.write_css_selector(v2, page);
        page += " {";
      } else {
        page += \`\${k} : \`;
        page = this.write_css_attr_value(v2, page);
        page += \`; \`;
      }
    });
    return page;
  }
  write_css_selector(v2, page) {
    if (is_list\$1(v2.v)) {
      page += " ";
      v2.v.forEach((x, i) => {
        page += \`\${x.v.v[1]} \`;
        if (i < v2.v.length - 1) {
          page += ",";
        }
      });
    } else {
      page += \` \${v2.v.v[1]}\`;
    }
    return page;
  }
  write_css_attr_value(v2, page) {
    switch (v2.id) {
      case "int":
      case "float":
        const num = v2.v[0].v[1];
        const suffix = v2.v[1] && v2.v[1].v[1] || "";
        page += num + suffix;
        break;
      case "prefix":
        page += v2.v.op.v;
        page = this.write_css_attr_value(v2.v.opr, page);
        break;
      case "postfix":
        page = this.write_css_attr_value(v2.v.opr, page);
        page += v2.v.op.v;
        break;
      case "str":
        page += v2.v.v[1];
        break;
      case "ref":
        page += maybe_hyphenated(v2.v.v[1]);
        break;
      case "tuple":
        v2.v.forEach((el) => {
          page = this.write_css_attr_value(el, page + " ");
        });
        break;
      case "call":
        const ref = v2.v[0].v.v[1];
        const args = v2.v[1];
        page += \` \${ref}(\`;
        args.forEach((arg) => {
          page = this.write_css_attr_value(arg, page);
        });
        page += \`)\`;
        break;
      case "bin":
        this.jsGen.write_expr(v2);
        const code = this.jsGen.get_code();
        page += "\${" + code + "}".trim();
        break;
      default:
        panic\$1(\`not supported: html generations:  \${to_str\$1(v2)}\`);
    }
    return page;
  }
  write_css_fontface(attrs, page) {
    page += \`@font-face { \`;
    page = write_ar_css(attrs, page);
    page += "}";
    return page;
  }
  write_css_keyframes(attrs, children, page) {
    page += \` @keyframes \${attrs[0].v.v[1]} { \`;
    children && children.forEach((c) => {
      const ref = c.v[0].v.v[1];
      const v2 = c.v[1];
      switch (ref) {
        case "at":
          const percentage = v2[0];
          const attrs2 = v2[1].v || [];
          page = this.write_css_attr_value(percentage, page);
          page += " {";
          attrs2.forEach((attr) => {
            if (attr.id === "named_tuple") {
              attr.v.forEach((el) => {
                const _k = maybe_hyphenated(el[0].v[1]);
                const _v = el[1];
                page += \` \${_k} : \`;
                page = this.write_css_attr_value(_v, page);
                page += \`; \`;
              });
            } else {
              const _k = maybe_hyphenated(attr[0].v[1]);
              const _v = attr[1];
              page += \` \${_k} : \`;
              page = this.write_css_attr_value(_v, page);
              page += \`; \`;
            }
          });
          page += "} ";
          break;
        default:
          panic\$1("unsupported element: " + to_str\$1(ref));
      }
    });
    page += "}";
    return page;
  }
}
const HTML_tag_en = {
  "صفحة_الشبكة": "Html",
  "راس": "Head",
  "نسق": "Style",
  "متن": "Body",
  "منطقة_النص": "Textarea",
  "عنوان_راسي٣": "H3",
  "قسم": "Div",
  "سطر": "Br"
};
const HTML_attr_en = (id2) => {
  switch (id2) {
    case "صنف":
      return "class";
    case "اعمدة":
      return "cols";
    case "صفوف":
      return "rows";
    case "للقراءة_فقط":
      return "readonly";
    default:
      return id2;
  }
};
const CSS_pseudo_en = {
  // FIXME: workaround
  "حوم": "hover"
};
const CSS_fn_en = (id2) => {
  switch (id2) {
    case "عند":
      return "at";
    case "ازاحة_س":
      return "translateX";
    case "عنوان":
      return "url";
    default:
      return id2;
  }
};
const CSS_suffix_en = (id2) => {
  switch (id2) {
    case "ع_ص":
      return "px";
    case "ع_ط":
      return "vh";
    case "م_ج":
      return "rem";
    case "ث":
      return "s";
    case "٪":
      return "%";
    default:
      return id2;
  }
};
const CSS_key_en = (id2) => {
  switch (id2) {
    case "عنصر":
      return "element";
    case "عرض":
      return "width";
    case "ادنى_عرض":
      return "min_width";
    case "ارتفاع":
      return "height";
    case "ادنى_ارتفاع":
      return "min_height";
    case "لون":
      return "color";
    case "اتجاه":
      return "direction";
    case "خلفية":
      return "background";
    case "لون_الخلفية":
      return "background_color";
    case "صورة_الخلفية":
      return "background_image";
    case "موقع_الخلفية":
      return "background_position";
    case "تكرار_الخلفية":
      return "background_repeat";
    case "ارفاق_الخلفية":
      return "background_attachment";
    case "ملائمة_العنصر":
      return "object_fit";
    case "حجم_الخلفية":
      return "background_size";
    case "_آبل_حجم_الخلفية":
      return "_webkite_background_size";
    case "فائض":
      return "overflow";
    case "عتامة":
      return "opacity";
    case "اظهار":
      return "display";
    case "هامش":
      return "margin";
    case "هامش_علوي":
      return "margin_top";
    case "هامش_سفلي":
      return "margin_bottom";
    case "هامش_ايمن":
      return "margin_right";
    case "هامش_ايسر":
      return "margin_left";
    case "بطانة":
      return "padding";
    case "تحجيم_الصندوق":
      return "box_sizing";
    case "ضبط_المحتوى":
      return "justify_content";
    case "ضبط_العناصر":
      return "justify_items";
    case "ضبط_النص":
      return "text_justify";
    case "محاذاة_العناصر":
      return "align_items";
    case "محاذاة_النص":
      return "text_align";
    case "حجم_الخط":
      return "font_size";
    case "فصيلة_الخط":
      return "font_family";
    case "فجوة":
      return "gap";
    case "حدود":
      return "border";
    case "قطر_الحدود":
      return "border_radius";
    case "نسق_الحدود":
      return "border_style";
    case "حدود_خارجية":
      return "outline";
    case "موضع":
      return "position";
    case "تحريك":
      return "animation";
    case "تحول":
      return "transform";
    case "اعادة_تحجيم":
      return "resize";
    case "مصدر":
      return "src";
    case "نسبة_س_ص":
      return "aspect_ratio";
    case "مرن_باتجاه":
      return "flex_direction";
    case "شريط_التمرير_عرض":
      return "scrollbar_width";
    case "قدرة_اختيار_النص":
      return "user_select";
    case "_مايكروسوفت_قدرة_اختيار_النص":
      return "_ms_user_select";
    case "_آبل_قدرة_اختيار_النص":
      return "_webkit_user_select";
    case "_موزيلا_قدرة_اختيار_النص":
      return "_moz_user_select";
    case "خيال_الصندوق":
      return "box_shadow";
    case "_آبل_خيال_الصندوق":
      return "_webkit_box_shadow";
    case "_موزيلا_خيال_الصندوق":
      return "_moz_box_shadow";
    default:
      return id2;
  }
};
const CSS_value_en = (id2) => {
  switch (id2) {
    case "تلقائي":
      return "auto";
    case "حدود_الصندوق":
      return "border_box";
    case "بلا_قيمة":
      return "none";
    case "مطلق":
      return "absolute";
    case "مرن":
      return "flex";
    case "مخفي":
      return "hidden";
    case "مركز":
      return "center";
    case "مسافة_بين":
      return "space_between";
    case "بداية":
      return "start";
    case "نهاية":
      return "end";
    case "بارز":
      return "ridge";
    case "لا_نهاية":
      return "infinite";
    case "لا_تكرار":
      return "no_repeat";
    case "احتواء":
      return "contain";
    case "قطع":
      return "clip";
    case "ضعف":
      return "double";
    case "ضبط":
      return "justify";
    case "بين_الكلمات":
      return "inter_word";
    case "مهم":
      return "important";
    case "غير_مهم":
      return "!important";
    case "مثبت":
      return "fixed";
    case "من_اليمين":
      return "rtl";
    case "عمودي":
      return "column";
    case "افقي":
      return "row";
    case "سماوي_فاتح":
      return "lightskyblue";
    case "ابيض":
      return "white";
    case "اصفر":
      return "yellow";
    case "اسود":
      return "black";
    case "برتقالي":
      return "orange";
    default:
      return id2;
  }
};
const CSS_str_en = (id2) => {
  switch (id2) {
    case "متن":
      return "Body";
    case "صفحة_الشبكة":
      return "Html";
    default:
      return id2;
  }
};
class ArHtmlWriter {
  jsGen;
  constructor(jsGen) {
    jsGen.init();
    this.jsGen = jsGen;
    return this;
  }
  write_ar_html(el, page) {
    switch (el.id) {
      case "call":
        const id2 = el.v[0].v.v[1];
        const tag = HTML_tag_en[id2] || id2;
        const attrs = el.v[1] || [];
        const children = el.v[2] || [];
        if (tag === "br") {
          return page += "<br>";
        }
        switch (tag) {
          case "اختر":
            page = this.write_ar_css(attrs, page) + "} ";
            break;
          case "عرف_خط":
            page = this.write_ar_css_fontface(attrs, page);
            break;
          case "اطارات_رئيسية":
            page = this.write_ar_css_keyframes(attrs, children, page);
            break;
          default:
            page += \`<\${tag}\`;
            if (ELEMENTS_WITH_DIR.includes(tag)) {
              page += \` dir='rtl'\`;
            }
            attrs.forEach((attr, i) => {
              if (i === 0 && attr.id === "str") {
                page += \` id='\${attr.v.v[1]}'\`;
              } else if (attr.id === "named_arg") {
                const attr_name = HTML_attr_en(attr.v[0].v[1]);
                if (BOOL_ATTRS.includes(attr_name)) {
                  page += \` \${attr_name} \`;
                } else {
                  page += \` \${attr_name}= \`;
                  if (attr.v[1].id === "str") {
                    page += \`'\${attr.v[1].v.v[1]}'\`;
                  } else if (attr.v[1].id === "int" || attr.v[1].id === "float") {
                    const num = to_maghrib_num\$1(attr.v[1].v[0].v[1]);
                    const suffix = attr.v[1].v[1] ? CSS_suffix_en(attr.v[1].v[1].v[1]) || "" : "";
                    page += \`\${num}\${suffix}\`;
                  } else if (attr.v[1].id === "bool") {
                    page += \`\${HTML_attr_en(attr_name)}\`;
                  } else {
                    panic\$1("not supported: " + to_str\$1(attr));
                  }
                }
              } else {
                panic\$1("not supported: " + to_str\$1(attr));
              }
            });
            page += ">";
            children.forEach((c) => {
              page = this.write_ar_html(c, page);
            });
            page += \`</\${tag}>\`;
        }
        break;
      case "str":
        page += el.v.v[1];
        break;
      default:
        panic\$1("unknown html element: " + to_str\$1(el));
    }
    return page;
  }
  write_ar_css(attrs, page) {
    attrs.forEach((attr) => {
      const k = maybe_hyphenated(CSS_key_en(attr.v[0].v[1]));
      const v2 = attr.v[1];
      if (k === "element") {
        page = this.write_ar_css_selector(v2, page);
        page += " {";
      } else {
        page += \`\${k} : \`;
        page = this.write_ar_css_attr_value(v2, page);
        page += \`; \`;
      }
    });
    return page;
  }
  write_ar_css_selector(v2, page) {
    const translate = (path) => {
      const get_regexp = (k) => RegExp(\`(?<![p{L}\\\\p{N}_])\${k}(?![\\\\p{L}\\\\p{N}_])\`, "ug");
      Object.keys(HTML_tag_en).forEach((k) => {
        path = path.replaceAll(get_regexp(k), HTML_tag_en[k]);
      });
      Object.keys(CSS_pseudo_en).forEach((k) => {
        path = path.replaceAll(get_regexp(k), CSS_pseudo_en[k]);
      });
      return path;
    };
    if (is_list\$1(v2.v)) {
      page += " ";
      v2.v.forEach((selector, i) => {
        let path = selector.v.v[1];
        page += translate(path);
        if (i < v2.v.length - 1) {
          page += ",";
        }
      });
    } else {
      const path = v2.v.v[1];
      page += translate(path);
    }
    return page;
  }
  write_ar_css_attr_value(v2, page) {
    switch (v2.id) {
      case "bool":
        panic\$1();
        break;
      case "int":
      case "float":
        const num = to_maghrib_num\$1(v2.v[0].v[1]);
        const suffix = CSS_suffix_en(v2.v[1] && v2.v[1].v[1]) || "";
        page += num + suffix;
        break;
      case "prefix":
        page += v2.v.op.v;
        page = this.write_ar_css_attr_value(v2.v.opr, page);
        break;
      case "postfix":
        page = this.write_ar_css_attr_value(v2.v.opr, page);
        page += v2.v.op.v;
        break;
      case "str":
        page += CSS_str_en(v2.v.v[1]);
        break;
      case "ref":
        page += maybe_hyphenated(CSS_value_en(v2.v.v[1]));
        break;
      case "tuple":
        v2.v.forEach((el) => {
          page = this.write_ar_css_attr_value(el, page + " ");
        });
        break;
      case "call":
        const ref = CSS_fn_en(v2.v[0].v.v[1]);
        const args = v2.v[1];
        page += \` \${ref}(\`;
        args.forEach((arg) => {
          page = this.write_ar_css_attr_value(arg, page);
        });
        page += \`)\`;
        break;
      case "bin":
        this.jsGen.write_expr(v2);
        const code = this.jsGen.get_code();
        page += "\${" + code + "}".trim();
        break;
      default:
        panic\$1(\`not supported: html generations:  \${to_str\$1(v2)}\`);
    }
    return page;
  }
  write_ar_css_fontface(attrs, page) {
    page += \`@font-face { \`;
    page = this.write_ar_css(attrs, page);
    page += "}";
    return page;
  }
  write_ar_css_keyframes(attrs, children, page) {
    page += \` @keyframes \${attrs[0].v.v[1]} { \`;
    children && children.forEach((c) => {
      const ref = c.v[0].v.v[1];
      const v2 = CSS_value_en(c.v[1]);
      switch (ref) {
        case "عند":
          const percentage = v2[0];
          const attrs2 = v2[1].v || [];
          page = this.write_ar_css_attr_value(percentage, page);
          page += " {";
          attrs2.forEach((attr) => {
            if (attr.id === "named_tuple") {
              attr.v.forEach((el) => {
                const _k = maybe_hyphenated(CSS_key_en(el[0].v[1]));
                const _v = CSS_value_en(el[1]);
                page += \` \${_k} : \`;
                page = this.write_ar_css_attr_value(_v, page);
                page += \`; \`;
              });
            } else {
              const _k = maybe_hyphenated(CSS_key_en(attr[0].v[1]));
              const _v = CSS_value_en(attr[1]);
              page += \` \${_k} : \`;
              page = this.write_ar_css_attr_value(_v, page);
              page += \`; \`;
            }
          });
          page += "} ";
          break;
        default:
          panic\$1("unsupported element: " + to_str\$1(ref));
      }
    });
    page += "}";
    return page;
  }
}
function maybe_hyphenated(id2) {
  if (HYPHENATED.includes(id2)) {
    return id2.replaceAll("_", "-");
  } else {
    return id2;
  }
}
const MAGHRIB_DIGIT = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
function is_maghrib_num(n) {
  return contains(MAGHRIB_DIGIT, n[0]);
}
function to_maghrib_num(n) {
  if (!is_maghrib_num(n)) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "٠":
          v2 += "0";
          break;
        case "١":
          v2 += "1";
          break;
        case "٢":
          v2 += "2";
          break;
        case "٣":
          v2 += "3";
          break;
        case "٤":
          v2 += "4";
          break;
        case "٥":
          v2 += "5";
          break;
        case "٦":
          v2 += "6";
          break;
        case "٧":
          v2 += "7";
          break;
        case "٨":
          v2 += "8";
          break;
        case "٩":
          v2 += "9";
          break;
        case ",":
          v2 += ".";
          break;
        default:
          panic\$3();
      }
      i += 1;
    }
    return v2;
  } else {
    return n;
  }
}
function is_list(x) {
  return x instanceof Array;
}
function contains(list, el) {
  return list.includes(el);
}
function to_str(obj, indent2) {
  let objects = [];
  const eliminateCircular = (k, v2) => {
    if (v2 && typeof v2 === "object") {
      if (objects.includes(v2)) {
        return "[CIRCULAR]";
      } else {
        objects.push(v2);
      }
    }
    return v2;
  };
  {
    return JSON.stringify(obj, eliminateCircular);
  }
}
function panic\$3(v2) {
  throw new Error(v2);
}
function repeat(str, times) {
  return str.repeat(times);
}
const HELPERS = \`
//------------------------------------------------------------------------------
// js helper functions injected to workaround missing seen features that are yet to be added.
function is_none(x) { return x == null }        
function is_list(x) { return x instanceof Array }
function replace(array, i, v) {  array[i] = v }
function to_int(str) { return parseInt(str) }
function assign(x,y) { x = y }
function concat(x,y,id) { x[id] = x[id].concat(y[id]) }
function del(array, i) { delete array[i] }
function regexp(expr) { return RegExp(expr, 'ug') }
function match_regexp(v, expr) {return expr.exec(v) }
function print(v) { throw new Error('print() is not implemeted')}
function اطبع_سطر(v) { println(v) }
function println(v) {         
    if(v == null ) { console.log("undefined") } else { console.log(v) }
}
function panic(v) { throw new Error(v)}
function clone(obj) { return {...obj} }
function contains(list, el) { return list.includes(el) }
function is_empty(list) { return Array.isArray(list) && list.length === 0 }
function اطبع_تفاصيل(obj, indent) { pprint(obj, indent) }
function pprint(obj, indent) { 
    if( obj == null ) {
        console.log("undefined")
    } else {
        if(indent) {
            console.log(JSON.stringify(obj, null, indent)) 
        } else {
            console.log(JSON.stringify(obj)) 
        }       
    }
}
function to_str(obj, indent) { 
let objects = []
function eliminateCircular(k, v) {
    if (v && typeof v === 'object') {
        if (objects.includes(v)) { return "[CIRCULAR]" } else { objects.push(v) }
    }
    return v
}
if(indent) {
    return JSON.stringify(obj, eliminateCircular, indent)
} else {
    return JSON.stringify(obj, eliminateCircular)
}
}
function repeat(str, times) { return str.repeat(times) }
function c0_to_uppercase(str){ return str.charAt(0).toUpperCase() + str.slice(1) }
function to_lowercase(str) {return str.toLowerCase()}
function عرض_اولي(code, preview_id){ preview(code, preview_id) }
function preview(code, preview_id) { window.parent.document.querySelector(preview_id).srcdoc = code }
function هات_الافرع(س) {
    return س.children
}
function اختر(س,دالة) {
    return س.filter(دالة)
}
function هات(ق,فهرس) { return ق[فهرس]}
function عدد_العناصر(ق) { return ق.length}
async function read_url(url) {
    const response = await fetch(url);
    return response.text()
}

//------------------------------------------------------------------------------
\`;
const AR_ID = {
  "بدء": "main",
  "اطبع_سطر": "println",
  "تعبير_نمطي": "regex",
  "هنا": "this",
  "مشيّد": "constructor",
  "انهاء": "panic"
};
const SPACES = 4;
class JSGen {
  current;
  indent_level;
  stack;
  astructs;
  ast;
  symtab;
  html_gen;
  main_args;
  opts;
  runtime;
  current_instance;
  init(lang2, ast, symtab, html_gen, main_args, opts2) {
    this.current = "";
    this.indent_level = 0;
    this.stack = [];
    this.astructs = [];
    this.ast = ast;
    this.symtab = symtab;
    this.html_gen = html_gen;
    this.main_args = main_args;
    this.opts = opts2;
    this.current_instance = null;
  }
  init_with_HTML(lang2, html_gen, ast, symtab, main_args, opts2) {
    this.init(lang2, ast, symtab, html_gen, main_args, opts2);
    this.html_gen = html_gen;
  }
  init_with_runtime(lang2, runtime, ast, symtab, main_args, opts2) {
    this.init(lang2, ast, symtab, null, main_args, opts2);
    this.runtime = runtime;
  }
  run() {
    this.strict_mode();
    let main;
    let i = 0;
    while (i < this.ast.length) {
      const n = this.ast[i];
      if (n) {
        const v2 = n.v;
        switch (n.id) {
          case "use":
            this.write_use(v2);
            break;
          case "modif":
            this.write_modifier(v2);
            break;
          case "main":
            main = v2;
            break;
          case "const":
            this.write_const(v2);
            break;
          case "fn":
            this.write_fn(v2);
            break;
          case "struct":
            this.write_struct(v2);
            break;
          case "enum":
            this.write_enum(v2);
            break;
          case "trait":
            this.write_trait(v2);
            break;
          case "trait_impl":
            this.write_trait_impl(v2);
            break;
          case "method":
            this.write_method(v2);
            break;
          default:
            panic\$3("unsupported node: " + this.ast[i].id);
        }
      }
      i += 1;
    }
    this.write_helper_fns();
    if (main) {
      this.write_main(main);
    }
    const code = this.get_code();
    return code;
  }
  to_en_id(id2) {
    if (!id2.v && !is_list(id2.v)) {
      return;
    }
    if (AR_ID[id2.v[1]]) {
      id2.v[1] = AR_ID[id2.v[1]];
    }
  }
  push() {
    this.stack.push(this.current);
    this.current = "";
  }
  pop() {
    this.current = this.stack.pop() + this.current;
  }
  pop_prepend() {
    this.current = this.current + this.stack.pop();
  }
  prepend(code) {
    this.current = code + this.current;
  }
  append(code) {
    this.current += code;
  }
  appendi(code) {
    this.current += this.spaces();
    this.current += code;
  }
  spaces(level) {
    if (!level) {
      level = this.indent_level;
    }
    return repeat(" ", level * SPACES);
  }
  strict_mode() {
    this.append('"use strict";\\n\\n');
  }
  write_id_pat(id2) {
    const v2 = id2.v.v[1];
    this.append(v2 === "_" ? "default" : v2);
  }
  write_char_pat(c) {
    this.append("'" + c.v.v[1] + "'");
  }
  write_str_pat(str) {
    this.append('"' + str.v.v[1] + '"');
  }
  write_tuple_pat(tuple) {
    this.append("(");
    let i = 0;
    while (i < tuple.v.length) {
      this.write_pat(tuple.v[i]);
      if (i < tuple.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(")");
  }
  write_pat(p) {
    switch (p.id) {
      case "id":
        this.write_id_pat(p);
        break;
      case "bool":
        this.append(p.v.v[1]);
        break;
      case "int":
      case "float":
        this.append(to_maghrib_num(p.v.v[1][0]));
        break;
      case "char":
        this.write_char_pat(p);
        break;
      case "str":
        this.write_str_pat(p);
        break;
      case "tuple":
        this.write_tuple_pat(p);
        break;
      case "_":
        this.append("default");
        break;
      default:
        panic\$3("unsupported pattern " + to_str(p));
    }
  }
  write_modifier(n) {
    if (this.opts.ignore_export) {
      return;
    }
    if (n.v === "+") {
      this.appendi("export ");
    }
  }
  write_use(n) {
    return;
  }
  write_main(_fn) {
    this.push();
    this.appendi("(");
    this.write_fn(_fn, this.main_args);
    this.appendi(")()\\n");
    this.pop();
  }
  write_params(params2) {
    this.append("(");
    let i = 0;
    while (i < params2.length) {
      if (i > 0) {
        this.append(", ");
      }
      this.write_pat(params2[i].v._pat);
      i += 1;
    }
    this.append(")");
  }
  write_do_block(block) {
    this.append(\`(()=>\`);
    this.write_block(block);
    this.append(\`)() 
\`);
  }
  write_block(block) {
    this.append(" {\\n");
    this.push();
    this.indent_level += 1;
    let i = 0;
    const length = block.v.length;
    while (i < length) {
      const stmt = block.v[i];
      this.write_stmt(stmt);
      i += 1;
    }
    this.pop();
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_fn(_fn, main_args) {
    this.push();
    if (_fn.t === "fn") {
      this.appendi("static ");
    }
    this.to_en_id(_fn.name);
    if (_fn.is_async) {
      this.append("async ");
    }
    this.append("function " + _fn.name.v[1]);
    if (main_args) {
      this.append("()");
    } else {
      this.write_params(_fn.params);
    }
    this.write_body(_fn.body, _fn.name === "main", main_args);
    this.pop();
  }
  write_method(_fn, instance) {
    this.push();
    this.to_en_id(_fn.name);
    if (_fn.is_async) {
      this.append("async ");
    }
    this.append(_fn.name.v[1]);
    this.write_params(_fn.params);
    this.current_instance = instance;
    this.write_body(_fn.body, false);
    this.current_instance = null;
    this.pop();
  }
  write_fields(fields) {
    const ids = [];
    fields.forEach((field) => {
      const id2 = field.v[0].v[1];
      ids.push(id2);
    });
    ids.forEach((id2) => {
      this.appendi(this.spaces() + "" + id2 + "\\n");
    });
    this.write_init(ids);
  }
  write_init(ids) {
    this.append("\\n");
    this.appendi("constructor(");
    let i = 0;
    while (i < ids.length) {
      this.append(ids[i]);
      if (i < ids.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(") {\\n");
    this.indent_level += 1;
    i = 0;
    while (i < ids.length) {
      this.appendi("this." + ids[i] + " = " + ids[i] + "\\n");
      i += 1;
    }
    this.appendi("return this\\n");
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  // write_typedef(_typedef) {
  //     this.appendi("class " + _typedef.name.v[1] + " {\\n")
  //     this.indent_level += 1
  //     if(_typedef.fields) { this.write_fields(_typedef.fields) }
  //     let fns = this.symtab.receivers[_typedef.name.v[1]]
  //     fns && fns.forEach( (data) => {
  //         const fn = data[0]
  //         const instance = data[1]
  //         this.write_method(fn.v, instance) // FIXME: names are confusing , write_fn is handling fn.v, not fn 
  //     })
  //     this.append('child(x) { return this.children[x] }')
  //     this.append('children() { return this.children }')
  //     this.indent_level -= 1
  //     this.appendi("}\\n\\n")
  // }
  write_struct(_struct) {
    this.appendi("class " + _struct.name.v[1] + " {\\n");
    if (_struct.fields) {
      this.write_fields(_struct.fields);
    }
    let fns = this.symtab.receivers[_struct.name.v[1]];
    fns && fns.forEach((data) => {
      const fn = data[0];
      const instance = data[1];
      this.write_method(fn.v, instance);
    });
    this.append("sn__(x) { return this.sn__[x] }");
    this.append("sn__() { return this.sn__}");
    this.appendi("}\\n\\n");
  }
  write_enum(_enum) {
    panic\$3("enum is not implemented yet.");
  }
  write_trait(_trait) {
    panic\$3("trait is not implemented yet.");
  }
  write_trait_impl(_trait_impl) {
    panic\$3("trait implementation is not implemented yet.");
  }
  write_method(_method) {
    panic\$3("method is not implemented yet.");
  }
  write_const(_const) {
    this.appendi("const ");
    this.write_pat(_const.lhs);
    this.append(" = ");
    this.write_expr(_const.rhs);
    this.append("\\n");
  }
  write_var(_var) {
    this.appendi("let ");
    this.write_pat(_var.lhs);
    if (_var.rhs) {
      this.append(" = ");
      this.write_expr(_var.rhs);
    }
    this.append("\\n");
  }
  write_ret(n) {
    this.append("return ");
    if (n.v) {
      this.write_expr(n.v);
    }
  }
  write_break(expr) {
    this.append("break");
  }
  write_stmt(stmt) {
    if (stmt.t === "expr") {
      this.appendi("");
      this.write_expr(stmt);
      this.append("\\n");
    } else if (stmt.id === "const") {
      this.write_const(stmt.v);
    } else if (stmt.id === "var") {
      this.write_var(stmt.v);
    } else if (stmt.id === "break") {
      this.write_break(stmt);
    } else {
      panic\$3("cannot write stmt: " + to_str(stmt));
    }
  }
  write_body(body, is_main, main_args) {
    this.append(" {\\n");
    this.push();
    this.indent_level += 1;
    if (main_args) {
      for (const [k, v2] of Object.entries(main_args)) {
        this.append(\`const \${k} = '\${v2}'
\`);
      }
    }
    let i = 0;
    const length = body.v.length;
    while (i < length) {
      const stmt = body.v[i];
      this.write_stmt(stmt);
      i += 1;
    }
    this.pop();
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_id(id2) {
    this.append(id2.v[1]);
  }
  write_ref(expr) {
    const _ref = expr.v.v[1];
    if (_ref === this.current_instance) {
      this.append("this");
    } else {
      this.append(_ref);
    }
  }
  write_str(expr) {
    const str = expr.v.v[1];
    const symbol2 = str.indexOf("\${") === -1 ? '"' : "\`";
    this.append(symbol2 + str + symbol2);
  }
  write_str_id(expr) {
    this.append(symbol + expr.v.v[1] + symbol);
  }
  is_call(expr) {
    return expr.v.id === "bin" && expr.v.v.op.v === "(";
  }
  write_iret(expr) {
    if (!(contains(["when", "while", "if", "for", "return"], expr.v.node) || expr.v.t === "()" || expr.v.t === "void" || expr.v.t === "" || this.is_call(expr) || expr.semicolon)) {
      this.append("return ");
    }
    if (this.is_call(expr)) {
      this.append("const temp_seen_var = ");
      this.write_expr(expr.v);
      this.append("\\n");
      this.append("return temp_seen_var");
    } else {
      this.write_expr(expr.v);
    }
  }
  write_list(expr) {
    this.append("[");
    let i = 0;
    const length = expr.v.length;
    while (i < length) {
      this.write_expr(expr.v[i]);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("]");
  }
  write_structl(expr) {
    const fields = expr.v;
    this.append("{");
    let i = 0;
    while (i < fields.length) {
      const field = fields[i];
      const key = field.k;
      if (key.v.v[1]) {
        this.write_id(key.v);
      } else {
        this.write_str_id(key.v);
      }
      const value = field.v;
      this.append(": ");
      this.write_expr(value);
      if (i < fields.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("}");
  }
  write_args(expr) {
    this.append("(");
    let i = 0;
    while (i < expr.v.length) {
      let _expr = expr.v[i];
      if (_expr.v.op && _expr.v.op.v === ":") {
        _expr = _expr.v.ropr;
      }
      this.write_expr(_expr);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append(")");
  }
  write_named_arg(narg) {
    narg.v[0].v[1];
    const v2 = narg.v[1];
    this.write_expr(v2);
  }
  write_tuple(expr) {
    this.append("[");
    let i = 0;
    while (i < expr.v.length) {
      let arg = expr.v[i];
      if (arg.id === "narg") {
        arg = expr.v[i].v[1];
      }
      this.write_expr(arg);
      if (i < expr.v.length - 1) {
        this.append(", ");
      }
      i += 1;
    }
    this.append("]");
  }
  write_named_tuple(expr) {
    this.append("{");
    expr.v.forEach((pair, i) => {
      const k = pair[0].v[1];
      const v2 = pair[1];
      this.append(k);
      this.append(": ");
      this.write_expr(v2);
      if (i < expr.v.length) {
        this.append(",");
      }
    });
    this.append("}");
  }
  write_when(expr) {
    this.appendi("switch(");
    this.write_expr(expr.v.expr);
    this.append(") {\\n");
    this.indent_level += 1;
    let i = 0;
    while (i < expr.v.arms.length) {
      const arm = expr.v.arms[i];
      const pats = arm.v.pats;
      const _expr = arm.v.expr;
      let j = 0;
      while (j < pats.length) {
        if (pats[j].id !== "_") {
          this.appendi("case ");
        }
        this.write_pat(pats[j]);
        this.append(" :\\n");
        j += 1;
      }
      this.indent_level += 1;
      this.appendi("");
      this.write_expr(_expr);
      this.append("\\n");
      this.appendi("break\\n");
      this.indent_level -= 1;
      i += 1;
    }
    this.indent_level -= 1;
    this.appendi("}\\n");
  }
  write_prefix_uni(expr) {
    const op = expr.v.op.v;
    switch (op) {
      case ".":
        {
          if (expr.v.opr.v.v[1] === "none") {
            this.append("null");
            return;
          } else {
            panic\$3("enum variants are not supported, found : (." + expr.v.opr.v.v[1] + ")");
          }
        }
        break;
      case "not":
        this.append("!");
        break;
      case "!":
      case "-":
        this.append(op);
        break;
      default:
        panic\$3("unsupported op: " + op);
        break;
    }
    this.write_expr(expr.v.opr);
  }
  write_pipe(stack) {
    while (stack.length > 0) {
      let expr = stack.pop();
      switch (expr.id) {
        case "ref":
          this.write_expr(expr);
          if (stack.length > 0) {
            this.append("(");
            this.write_pipe(stack);
            this.append(")");
          }
          break;
        case "call":
          const lhs = expr.v[0];
          const rhs = expr.v[1];
          this.write_expr(lhs);
          this.append("(");
          this.write_pipe(stack);
          if (this.current.slice(-1) !== "(" && rhs.length > 0) {
            this.append(", ");
          }
          rhs.forEach((el, i) => {
            this.write_expr(el);
            if (i < rhs.length - 1) {
              this.append(", ");
            }
          });
          this.append(")");
          break;
        case "int":
        case "float":
        case "str":
        case "[":
        case "tuple":
        case "named_tuple":
          this.write_expr(expr);
          break;
        default:
          throw new Error("syntax error |> :" + to_str(expr));
      }
    }
  }
  write_runtime_fn() {
  }
  write_call(expr) {
    pprint(expr);
    const runtime_impl = this.runtime && this.runtime.get_fn(expr);
    if (runtime_impl) {
      if (runtime_impl._import) {
        this.prepend(runtime_impl._import);
      }
      this.append(runtime_impl.code);
      return;
    }
    this.to_en_id(expr.v[0].v);
    if (expr.v[0].v.v[1] === "html") {
      const page = this.html_gen.en.write_html(expr, "");
      this.append(\` (() => \\\`\${page}\\\`)() \`);
      return;
    } else if (expr.v[0].v.v[1] === "صفحة_الشبكة") {
      const page = this.html_gen.ar.write_ar_html(expr, "");
      this.append(\`(() => \\\`\${page}\\\`)()\`);
      return;
    } else if (this.symtab.structs.includes(expr.v[0].v.v[1])) {
      this.append("new ");
    }
    this.write_expr(expr.v[0]);
    this.append("(");
    const args = expr.v[1];
    if (args) {
      args.forEach((arg, i) => {
        this.write_expr(arg);
        if (i < args.length - 1) {
          this.append(", ");
        }
      });
    }
    if (expr.v[2]) {
      if (args) {
        this.append(", ");
      }
      this.write_children(expr.v[2]);
    }
    this.append(")");
  }
  write_children(block) {
    if (!block || block.length === 0) {
      return;
    }
    this.append("[");
    block.forEach((expr) => {
      this.write_expr(expr);
      this.append(",");
    });
    this.append("]");
  }
  write_bin(expr) {
    const op = expr.v.op.v;
    switch (op) {
      case "[":
        this.write_expr(expr.v.lopr);
        this.append("[");
        this.write_expr(expr.v.ropr);
        this.append("]");
        break;
      case "=":
        this.write_expr(expr.v.lopr);
        this.append("=");
        this.write_expr(expr.v.ropr);
        break;
      case ":":
        this.appendi("let ");
        this.write_expr(expr.v.lopr);
        this.append("\\n");
        break;
      case "++":
        this.write_expr(expr.v.lopr);
        this.append("+");
        this.write_expr(expr.v.ropr);
        break;
      case "|>":
        throw new Error("|> not implemented");
      case "||>":
        throw new Error(" ||> : WIP , " + to_str(expr));
      case ":>":
        throw new Error(" :> : WIP , " + to_str(expr));
      case "==":
      case "!=":
      case "<":
      case "<=":
      case ">":
      case ">=":
      case "|":
      case "||":
      case "&":
      case "&&":
      case "+":
      case "-":
      case "/":
      case "*":
      case "+=":
      case "-=":
      case "*=":
      case "\\\\=":
      case ".":
        this.write_expr(expr.v.lopr);
        this.append(op);
        if (op === "==" || op === "!=") {
          this.append("=");
        }
        this.write_expr(expr.v.ropr);
        break;
      default:
        panic\$3("cannot write binary operation: " + to_str(expr));
        break;
    }
  }
  write_afn(expr) {
    this.push();
    this.write_params(expr.v.params);
    this.append("=>");
    this.write_body(expr.v.body);
    this.pop();
  }
  write_expr(expr) {
    if (expr.grouped) {
      this.append("(");
    }
    switch (expr.id) {
      case "void":
        this.append("null");
        break;
      case ";":
        break;
      case "ref":
        this.write_ref(expr);
        break;
      case "bool":
        this.append(expr.v.v[1]);
        break;
      case "int":
      case "float":
        this.append(to_maghrib_num(expr.v[0].v[1]));
        break;
      case "char":
        this.append("'" + expr.v.v[1] + "'");
        break;
      case "str":
        this.write_str(expr);
        break;
      case "return":
        this.write_ret(expr);
        break;
      case "iret":
        this.write_iret(expr);
        break;
      case "[":
        this.write_list(expr);
        break;
      case "{":
        this.write_structl(expr);
        break;
      case "args":
        this.write_args(expr);
        break;
      case "named_arg":
        this.write_named_arg(expr);
        break;
      case "tuple":
        this.write_tuple(expr);
        break;
      case "named_tuple":
        this.write_named_tuple(expr);
        break;
      case "when":
        this.write_when(expr);
        break;
      case "do_block":
        this.write_do_block(expr);
        break;
      case "block":
        this.write_block(expr);
        break;
      case "prefix":
        this.write_prefix_uni(expr);
        break;
      case "call":
        this.write_call(expr);
        break;
      case "bin":
        this.write_bin(expr);
        break;
      case "afn":
        this.write_afn(expr);
        break;
      default:
        panic\$3("cannot write expr: " + to_str(expr));
    }
    if (expr.grouped) {
      this.append(")");
    }
  }
  write_helper_fns() {
    this.append(HELPERS);
  }
  get_code() {
    return this.current;
  }
}
class HtmlCssJSGen {
  run(lang2, ast, symtab, main_args, opts2) {
    const en_html = new HtmlWriter(new JSGen());
    const ar_html = new ArHtmlWriter(new JSGen());
    const html_gen = {
      en: en_html,
      ar: ar_html
    };
    const js_gen = new JSGen();
    js_gen.init(
      lang2,
      ast,
      symtab,
      html_gen,
      main_args,
      opts2
    );
    return js_gen.run();
  }
}
class Gen {
  ast;
  symtab;
  main_args;
  target;
  target_opts;
  lang;
  init(ast, symtab, main_args, target, target_opts) {
    this.ast = ast;
    this.symtab = symtab;
    this.main_args = main_args;
    this.target = target;
    this.target_opts = target_opts;
  }
  // FIXME: setting lang separately , to avoid breaking the code for current release ,
  //              need to refactor later.
  set_lang(lang2) {
    this.lang = lang2;
  }
  async run() {
    let gen;
    const target = to_lowercase(this.target);
    if (target === "js") {
      gen = new HtmlCssJSGen();
    } else if (SUPPORTED_GEN.includes(target)) {
      const { default: Gen2 } = await import(url.pathToFileURL(this.target_opts.deps.path));
      gen = new Gen2();
    } else {
      panic\$2('target "' + this.target + '" is not supported');
    }
    return gen.run(
      this.lang || en,
      this.ast,
      this.symtab,
      this.main_args,
      this.target_opts
    );
  }
}
class Compiler {
  src;
  main_args;
  target;
  target_opts;
  lang;
  tokens;
  ast;
  symtab;
  gen_code;
  init(src, main_args, lang2, target_opts) {
    this.src = src;
    this.main_args = main_args;
    this.target = target_opts && target_opts.target || "js";
    this.target_opts = target_opts || {};
    this.lang = lang2 || "en";
  }
  init_ar(src, main_args, target_opts) {
    return this.init(src, main_args, "ar", target_opts);
  }
  async get_code() {
    if (!this.gen_code) {
      await this.run();
    }
    return this.gen_code;
  }
  async run() {
    this.scan(true);
    this.parse();
    await this.generate(this.target);
  }
  scan(ignore_cmts_ws) {
    const lexer = new Lexer();
    lexer.init(this.lang, this.src, ignore_cmts_ws);
    lexer.run();
    this.tokens = lexer.tokens;
    if (!is_empty(lexer.errs)) {
      pprint\$1(lexer.errs);
      panic\$2("");
    }
  }
  parse() {
    const parser = new Parser();
    parser.init(this.tokens);
    parser.run();
    this.ast = parser.ast;
    this.symtab = parser.symtab;
    if (!is_empty(parser.errs)) {
      pprint\$1(parser.errs);
      panic\$2("");
    }
  }
  semantic() {
    const semantic = new Semantic(this.ast, this.symtab);
    semantic.run();
    if (!is_empty(semantic.errs)) {
      pprint\$1(semantic.errs);
      panic\$2("");
    }
  }
  async generate(target) {
    const gen = new Gen();
    gen.init(this.ast, this.symtab, this.main_args, target, this.target_opts);
    gen.set_lang(this.lang);
    this.gen_code = await gen.run();
  }
}
const DEFAULT_DARK_THEME = "panda-syntax";
const DEFAULT_LIGHT_THEME = "ttcn_modified";
const USER_ALLOWED_OPTS = ["mode", "lang", "theme", "statusbar"];
const CODE_OPTS = {
  lang: "en",
  mode: "code",
  theme: "light",
  output: false,
  toolbar: false,
  readonly: true,
  statusbar: true,
  copy: false
};
const EDITOR_OPTS = {
  lang: "en",
  mode: "editor",
  theme: "light",
  output: true,
  toolbar: true,
  readonly: false,
  statusbar: true,
  copy: false
};
const userOpts = window.opts;
const optMode = userOpts.mode || "code";
let opts;
switch (optMode) {
  case "code":
    opts = CODE_OPTS;
    break;
  case "editor":
    opts = EDITOR_OPTS;
    break;
  default:
    throw new Error("invalid mode! : " + optMode);
}
let langFromURL = new URLSearchParams(window.location.search).get("lang");
let lang = langFromURL || userOpts.lang;
Object.keys(userOpts).forEach((k) => {
  if (!USER_ALLOWED_OPTS.includes(k)) {
    throw new Error("invalid option: " + k);
  }
  opts[k] = userOpts[k];
});
window.console["log"] = (data) => writeP(data);
window.console["error"] = (err) => {
  if (isChrome()) {
    writeP(err.stack, ERROR_COLOR);
  } else {
    writeP(err, ERROR_COLOR);
  }
};
const ERROR_COLOR = "rgb(217 83 77)";
const RUNNING_COLOR = "rgb(108 141 211)";
const jsBeautifyOptions = {
  "indent_size": "4",
  "indent_char": " ",
  "max_preserve_newlines": "5",
  "preserve_newlines": true,
  "keep_array_indentation": false,
  "break_chained_methods": false,
  "indent_scripts": "normal",
  "brace_style": "collapse",
  "space_before_conditional": false,
  "unescape_strings": false,
  "jslint_happy": false,
  "end_with_newline": false,
  "wrap_line_length": "0",
  "indent_inner_html": false,
  "comma_first": false,
  "e4x": false,
  "indent_empty_lines": false
};
const commonKeyMap = {
  "Ctrl-9": (cm) => cm.foldCode(cm.getCursor()),
  "Tab": () => indent(),
  "Shift-Tab": () => dedent(),
  "Ctrl-'": () => {
    insertChar("«»");
  },
  "Ctrl-0": () => {
    run();
  },
  "Ctrl-=": () => {
    increaseFont();
  },
  "Ctrl--": () => {
    decreaseFont();
  }
};
const CM_COMMANDS = ["findCtrl"];
const eval_div = document.querySelector("#eval");
const previewArea = document.querySelector("#preview_area");
const observer = new MutationObserver((mutationsList, observer2) => {
  if (onPageLoad) {
    onPageLoad = false;
  } else {
    showPreview();
  }
});
observer.observe(previewArea, { characterData: false, childList: true, attributes: true });
const editor = CodeMirror.fromTextArea(document.querySelector("#code"), {
  lineNumbers: true,
  lineWrapping: true,
  direction: getDir(lang),
  scrollbarStyle: "simple",
  indentUnit: 4,
  tabSize: 4,
  styleActiveLine: true,
  matchBrackets: true,
  autoCloseBrackets: true,
  lineNumberFormatter: lineNumberFormatter(getDir(lang)),
  extraKeys: {
    ...commonKeyMap
  },
  foldGutter: true,
  gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
  commands: CM_COMMANDS
});
const targetEditor = CodeMirror.fromTextArea(document.querySelector("#target_code"), {
  lineNumbers: true,
  lineWrapping: true,
  direction: "ltr",
  scrollbarStyle: "simple",
  indentUnit: 4,
  tabSize: 4,
  styleActiveLine: true,
  matchBrackets: true,
  autoCloseBrackets: true,
  mode: "javascript",
  lineNumberFormatter: lineNumberFormatter("ltr"),
  foldGutter: true,
  gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
  commands: CM_COMMANDS
});
targetEditor.setSize(460);
let keydown = {};
let isMaghrib;
let isArabic;
let fontSize;
let editorLang;
let projPath;
let onPageLoad;
function isChrome() {
  return navigator.userAgentData ? true : false;
}
function getDir(lang2) {
  return lang2 === "ar" ? "rtl" : "ltr";
}
const SAMPLE_CODE = {
  ar: \`دل بدء {
    اطبع_سطر(«السلام عليكم!»)  
}\`,
  en: \`fn main { 
    println('hello world') 
}\`
};
await init(lang);
await setupListeners();
async function init(langId) {
  isMaghrib = langId === "ar_m";
  isArabic = langId.startsWith("ar");
  let lang2 = langId.startsWith("ar") ? "ar" : "en";
  fontSize = 14;
  editorLang = lang2;
  projPath = "";
  onPageLoad = true;
  document.querySelector("#right_side").style.display = "none";
  document.querySelector("#preview").style.display = "none";
  document.querySelector("body").style.visibility = "hidden";
  await setEditorLang(lang2);
  document.querySelector("#left_side_label").innerText = editorLang === "ar" ? "س" : "seen";
  document.querySelector("#preview_label").innerText = editorLang === "ar" ? "العرض الأولي" : "Preview";
  setFontSize(fontSize);
  setTitle(lang2);
  setDirection(lang2);
  setLabels(INDEX_LABELS, lang2);
  setTooltipLabels(TOOLTIP_LABELS, lang2);
  setSyntaxHighlighter(lang2);
  editor.setValue(lang2 === "ar" ? SAMPLE_CODE.ar : SAMPLE_CODE.en);
  editor.clearHistory();
  arSetup(lang2);
  setCursorPosition(1, 1);
  if (projPath) {
    openProj(projPath);
  }
  await setTheme(opts.theme);
  if (isCodeMode()) {
    codeMode();
  }
  if (!opts.statusbar) {
    removeStatusBar();
  }
  document.querySelector("body").style.visibility = "visible";
}
function isCodeMode() {
  return opts.mode === "code";
}
function removeStatusBar() {
  document.querySelector("#status_bar").setAttribute("style", "display: none;");
}
function codeMode() {
  document.querySelector("#output_container").setAttribute("style", "display: none;");
  document.querySelector("#editor_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#left_side_titlebar").setAttribute("style", "display: none;");
  document.querySelector("#right_side_titlebar").setAttribute("style", "display: none;");
  document.querySelector("#tabs_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#tabs_toolbar").setAttribute("style", "display: none;");
  document.querySelector("#side_by_side").setAttribute("style", "margin-top: 0;");
}
async function setEditorLang(lang2) {
  editorLang = lang2;
}
async function setTitle(lang2, text) {
  if (lang2 === "ar") {
    text = text === void 0 ? "محرر س" : text;
    document.title = text;
  } else {
    text = text === void 0 ? "Seen Editor" : text;
    document.title = text;
  }
}
async function arSetup(lang2) {
  if (lang2 === "ar") {
    document.querySelector("#left_side_label").innerText = "س";
    document.querySelector("#left_side_label").style.fontSize = "17px";
    document.querySelector("#left_side_label").style.marginLeft = "0px";
    document.querySelector("#left_side_label").style.marginRight = "5px";
    document.querySelector("#right_side_label").style.marginLeft = "0px";
    document.querySelector("#right_side_label").style.marginRight = "5px";
    document.querySelector("#right_side_close").style.cssFloat = "left";
    document.querySelector("#right_side_toolbar").style.cssFloat = "left";
    document.querySelector("#preview_label").style.marginLeft = "0px";
    document.querySelector("#preview_label").style.marginRight = "5px";
    document.querySelector("#preview_close").style.cssFloat = "left";
  }
}
async function setDirection(lang2) {
  let dir = getDir(lang2);
  editor.setOption("direction", dir);
  document.querySelector("html").setAttribute("dir", dir);
  document.querySelector("#container").setAttribute("dir", dir);
  document.querySelector("#editor_output").setAttribute("dir", dir);
  document.querySelector("#preview").setAttribute("dir", dir);
  document.querySelector("#preview_area").setAttribute("dir", dir);
  document.querySelector("#output").setAttribute("dir", dir);
  document.querySelector("#status_bar").setAttribute("dir", dir);
  document.querySelector("#status_bar").style.textAlign = dir === "rtl" ? "left" : "right";
}
function setCursorPosition(line, ch) {
  document.querySelector("#status_bar").textContent = editorLang === "ar" ? \`سطر \${toEasternDigits(line)}, عمودي \${toEasternDigits(ch)}\` : \`Ln \${line}, Col \${ch}\`;
}
function insertChar(char) {
  let c = char;
  if (isArabic) {
    const cursor = editor.doc.getCursor();
    const line = cursor.line;
    editor.doc.replaceRange(c, cursor);
    editor.doc.setCursor(line, cursor.ch + c.length);
  } else {
    return CodeMirror.Pass;
  }
}
function indent() {
  if (editor.somethingSelected()) {
    var sel = editor.getSelection("\\n");
    if (sel.length > 0 && (sel.indexOf("\\n") > -1 || sel.length === editor.getLine(editor.getCursor().line).length)) {
      editor.indentSelection("add");
      return CodeMirror.Pass;
    }
  }
  var spaces = Array(editor.getOption("indentUnit") + 1).join(" ");
  editor.replaceSelection(spaces);
}
function dedent() {
  editor.indentSelection("subtract");
}
function increaseFont() {
  fontSize++;
  setFontSize(fontSize);
}
function decreaseFont() {
  fontSize--;
  setFontSize(fontSize);
}
async function setThemeFromOptions() {
  let themes = document.querySelector("#theme");
  let name = themes.options[themes.selectedIndex].value;
  await setTheme(name);
}
async function setTheme(name) {
  if (name === "dark") {
    name = DEFAULT_DARK_THEME;
    document.querySelector("#theme").value = DEFAULT_DARK_THEME;
  } else if (name === "light") {
    name = DEFAULT_LIGHT_THEME;
    document.querySelector("#theme").value = "ttcn";
  }
  const updateThemeClass = (el, name2) => {
    [...el.classList].forEach((className) => {
      if (className.startsWith("cm-s")) {
        el.classList.remove(className);
      }
    });
    name2.split(" ").forEach((name3) => {
      el.classList.add(\`cm-s-\${name3}\`);
    });
  };
  editor.setOption("theme", name);
  targetEditor.setOption("theme", name);
  updateThemeClass(document.querySelector("#wrapper"), name);
  updateThemeClass(document.querySelector("#editor_output"), name);
  updateThemeClass(document.querySelector("#output"), name);
  setFooterTheme();
  const inherited = window.getComputedStyle(document.querySelector("#run")).getPropertyValue("color");
  document.querySelector("#theme").style.backgroundImage = \`url("data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'%3e%3c!--!Font%20Awesome%20Free%206.6.0%20by%20@fontawesome%20-%20https://fontawesome.com%20License%20-%20https://fontawesome.com/license/free%20Copyright%202024%20Fonticons,%20Inc.--%3e%3cpath%20fill='\${inherited}'%20d='M512%20256c0%20.9%200%201.8%200%202.7c-.4%2036.5-33.6%2061.3-70.1%2061.3L344%20320c-26.5%200-48%2021.5-48%2048c0%203.4%20.4%206.7%201%209.9c2.1%2010.2%206.5%2020%2010.8%2029.9c6.1%2013.8%2012.1%2027.5%2012.1%2042c0%2031.8-21.6%2060.7-53.4%2062c-3.5%20.1-7%20.2-10.6%20.2C114.6%20512%200%20397.4%200%20256S114.6%200%20256%200S512%20114.6%20512%20256zM128%20288a32%2032%200%201%200%20-64%200%2032%2032%200%201%200%2064%200zm0-96a32%2032%200%201%200%200-64%2032%2032%200%201%200%200%2064zM288%2096a32%2032%200%201%200%20-64%200%2032%2032%200%201%200%2064%200zm96%2096a32%2032%200%201%200%200-64%2032%2032%200%201%200%200%2064z'/%3e%3c/svg%3e")\`;
}
function setFooterTheme() {
  const status_bar = document.querySelector("#status_bar");
  const output_style = window.getComputedStyle(document.querySelector("#output"));
  status_bar.style.fontSize = output_style.getPropertyValue("font-size");
  status_bar.style.color = output_style.getPropertyValue("color");
  status_bar.style.backgroundColor = output_style.getPropertyValue("background-color");
}
function setFontSize(size) {
  let els = document.querySelectorAll(".CodeMirror");
  els = [...els, ...document.querySelectorAll("button")];
  els.push(document.querySelector("#status_bar"));
  els.forEach((el) => {
    el.style.fontSize = \`\${size}px\`;
  });
}
function setSyntaxHighlighter(lang2) {
  const mode = lang2 === "ar" ? "seen-ar" : "seen-en";
  editor.setOption("mode", mode);
}
function showRightSide() {
  document.querySelector("#right_side").style.display = "flex";
}
function hideRightSide() {
  document.querySelector("#right_side").style.display = "none";
}
function showPreview() {
  document.querySelector("#preview").style.display = "flex";
}
function hidePreview() {
  document.querySelector("#preview").style.display = "none";
}
function resetOutput() {
  output.replaceChildren();
}
function runInsideIframe(code) {
  eval_div.replaceChildren();
  const iframe = document.createElement("iframe");
  eval_div.appendChild(iframe);
  iframe.contentWindow || iframe;
  const iframe_doc = iframe.contentDocument || iframe.contentWindow.document;
  const html = \` <head>
        <script>window.console=window.parent.console<\\/script>
        <script>\${code}<\\/script>
      </head>
      <body>
      </body>\`;
  iframe_doc.open();
  iframe_doc.write(html);
  iframe_doc.close();
}
async function run() {
  hideRightSide();
  hidePreview();
  resetOutput();
  try {
    let compiler = await genJS();
    runInsideIframe(await compiler.get_code());
    const END = editorLang === "ar" ? "انتهى" : "End";
    writeP("\\n");
    writeP(\`--- \${END} ---
\`, RUNNING_COLOR);
  } catch (err) {
    console.error(err);
  }
}
async function closeRightSide() {
  hideRightSide();
  targetEditor.setValue("");
}
async function closePreview() {
  hidePreview();
  previewArea.replaceChildren();
}
async function js() {
  hidePreview();
  showRightSide();
  await genJS();
}
async function genJS() {
  let content = editor.getValue();
  let compiler = new Compiler();
  let target_opts = { ignore_export: true };
  const main_args = {
    preview_id: "#preview_area",
    معرف_منطقة_العرض: "#preview_area"
  };
  compiler.init(content, main_args, editorLang, target_opts);
  await compiler.run();
  document.querySelector("#right_side_label").innerText = editorLang === "ar" ? "نص البرنامج" : "Code";
  let code = js_beautify(compiler.gen_code, jsBeautifyOptions);
  targetEditor.setOption("mode", "javascript");
  targetEditor.setOption("direction", "ltr");
  targetEditor.setOption("lineNumberFormatter", lineNumberFormatter("ltr"));
  targetEditor.setValue(code);
  return compiler;
}
async function clear() {
  document.querySelector("#output").innerHTML = "";
}
async function setupListeners() {
  document.querySelector("body").addEventListener("keydown", (e) => handleKeydown(e));
  document.querySelector("body").addEventListener("keyup", (e) => {
    keydown[e.key] = false;
  });
  document.querySelector("#theme").addEventListener("change", () => setThemeFromOptions());
  document.querySelector("#run").addEventListener("click", () => run());
  document.querySelector("#srccode").addEventListener("click", () => js());
  document.querySelector("#right_side_close").addEventListener("click", () => closeRightSide());
  document.querySelector("#preview_close").addEventListener("click", () => closePreview());
  document.querySelector("#clear").addEventListener("click", () => clear());
  editor.on("cursorActivity", (args) => {
    let { line, ch } = editor.getCursor();
    line += 1;
    ch += 1;
    setCursorPosition(line, ch);
  });
}
function lineNumberFormatter(dir) {
  if (dir === "rtl") {
    return (n) => toEasternDigits(n);
  } else {
    return (n) => n;
  }
}
function handleKeydown(e) {
  keydown[e.key] = true;
  let keys = "";
  Object.entries(keydown).forEach(([k, v2]) => {
    if (keydown[k]) {
      keys += k;
    }
  });
  switch (keys.toLowerCase()) {
    case "0control":
    case "control0":
      run();
      break;
    case "-control":
    case "control-":
      increaseFont();
      break;
    case "=control":
    case "control=":
      decreaseFont();
      break;
  }
}
function writeOutput(el) {
  var output2 = document.querySelector("#output");
  output2.appendChild(el);
  output2.scrollTop = output2.scrollHeight;
}
function writeP(text, color) {
  if (text === "") {
    console.log("\\n");
  }
  if (isArabic) {
    if (text) {
      text = toArabicPunctuations(text);
    }
    if (!isMaghrib) {
      if (text) {
        text = toMashriqNumerals(text);
      }
    }
  }
  const p = document.createElement("p");
  p.textContent = text;
  p.setAttribute("dir", getDir(editorLang));
  p.style.whiteSpace = "pre-wrap";
  if (color) {
    p.style.color = color;
  }
  writeOutput(p);
}
function toArabicPunctuations(text) {
  const p = /["'](.*?)["']/gi;
  return text.toString().replace(p, (matched, g1) => {
    if (matched) {
      return \`«\${g1}»\`;
    } else {
      return text;
    }
  });
}
function toMashriqNumerals(text) {
  function toMashriqNum(n) {
    let v2 = "";
    let i = 0;
    while (i < n.length) {
      const c = n[i];
      switch (c) {
        case "0":
          v2 += "٠";
          break;
        case "1":
          v2 += "١";
          break;
        case "2":
          v2 += "٢";
          break;
        case "3":
          v2 += "٣";
          break;
        case "4":
          v2 += "٤";
          break;
        case "5":
          v2 += "٥";
          break;
        case "6":
          v2 += "٦";
          break;
        case "7":
          v2 += "٧";
          break;
        case "8":
          v2 += "٨";
          break;
        case "9":
          v2 += "٩";
          break;
        case ".":
          v2 += "٫";
          break;
        default:
          panic();
      }
      i += 1;
    }
    return v2;
  }
  const p = /([0123456789]+)(\\.)?([0123456789]+)?/gi;
  text = text.replace(p, (matched, g1, g2, g3) => {
    if (matched) {
      let v2 = \`\${toMashriqNum(g1)}\`;
      if (g2) {
        v2 += ",";
        if (g3) {
          v2 += \`\${toMashriqNum(g3)}\`;
        }
      }
      return v2;
    } else {
      return text;
    }
  });
  return text;
}
function panic(v2) {
  throw new Error(v2);
}
function setEditorValue(code) {
  editor.setValue(code);
}
window.setEditorValue = setEditorValue;
window.hideRightSide = hideRightSide;
window.hidePreview = hidePreview;
window.resetOutput = resetOutput;
window.setTheme = setTheme;
</script>
		<style rel="stylesheet" crossorigin>.CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor .CodeMirror-line::selection,.cm-fat-cursor .CodeMirror-line>span::selection,.cm-fat-cursor .CodeMirror-line>span>span::selection{background:transparent}.cm-fat-cursor .CodeMirror-line::-moz-selection,.cm-fat-cursor .CodeMirror-line>span::-moz-selection,.cm-fat-cursor .CodeMirror-line>span>span::-moz-selection{background:transparent}.cm-fat-cursor{caret-color:transparent}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;inset:-50px 0 0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error,.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:#ff96004d}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative;z-index:0}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;inset:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors,.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:#ff06}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}.CodeMirror-simplescroll-horizontal div,.CodeMirror-simplescroll-vertical div{position:absolute;background:#ccc;-moz-box-sizing:border-box;box-sizing:border-box;border:1px solid #bbb;border-radius:2px}.CodeMirror-simplescroll-horizontal,.CodeMirror-simplescroll-vertical{position:absolute;z-index:6;background:#eee}.CodeMirror-simplescroll-horizontal{bottom:0;left:0;height:8px}.CodeMirror-simplescroll-horizontal div{bottom:0;height:100%}.CodeMirror-simplescroll-vertical{right:0;top:0;width:8px}.CodeMirror-simplescroll-vertical div{right:0;width:100%}.CodeMirror-overlayscroll .CodeMirror-scrollbar-filler,.CodeMirror-overlayscroll .CodeMirror-gutter-filler{display:none}.CodeMirror-overlayscroll-horizontal div,.CodeMirror-overlayscroll-vertical div{position:absolute;background:#bcd;border-radius:3px}.CodeMirror-overlayscroll-horizontal,.CodeMirror-overlayscroll-vertical{position:absolute;z-index:6}.CodeMirror-overlayscroll-horizontal{bottom:0;left:0;height:6px}.CodeMirror-overlayscroll-horizontal div{bottom:0;height:100%}.CodeMirror-overlayscroll-vertical{right:0;top:0;width:6px}.CodeMirror-overlayscroll-vertical div{right:0;width:100%}.CodeMirror-foldmarker{color:#00f;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded{cursor:pointer}.CodeMirror-foldgutter-open:after{content:"▾"}.CodeMirror-foldgutter-folded:after{content:"▸"}.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;-webkit-box-shadow:2px 3px 5px rgba(0,0,0,.2);-moz-box-shadow:2px 3px 5px rgba(0,0,0,.2);box-shadow:2px 3px 5px #0003;border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto;box-sizing:border-box}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}*{box-sizing:border-box}.CodeMirror{flex-grow:1;font-family:monospace;border:solid 1px}html,body{width:100%;height:100%;margin:0;padding:0}body{display:flex;flex-direction:column;font-family:monospace}#wrapper{flex-grow:1;display:flex;flex-direction:column;margin:0;padding:0}#container{flex-grow:1;display:flex;flex-direction:row}#project_label{margin-left:5px;margin-right:5px;border:1px solid}.icon{width:20px;height:20px}#theme{-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;padding-top:15px;font-size:0px;background:transparent;background-repeat:no-repeat;margin-top:1px;cursor:pointer}option{font-size:15px}#theme:focus{outline:none}#editor_output{flex-grow:1;display:flex;flex-direction:column}#side_by_side{display:flex;flex-grow:1;flex-direction:row;margin-top:5px}#preview{height:100%;flex-grow:1;display:flex;flex-direction:column;margin-left:5px;margin-right:5px;overflow:scroll;-webkit-scrollbar:none;-ms-overflow-style:none;scrollbar-width:none}#preview_area{border:none;display:flex;overflow:auto;outline:1px solid;height:100%;margin:5px}#left_side_label,#right_side_label{overflow:auto}#left_side,#right_side{display:flex;flex-direction:column;justify-content:stretch}#left_side{flex-grow:3;width:0}#right_side{flex-grow:auto}#tabs_toolbar{overflow:hidden;border-bottom:1px solid}.tab{flex-shrink:0;flex-grow:0;overflow:hidden;align-items:flex-start;cursor:pointer}#editor_toolbar{margin:5px}#left_side_toolbar{display:inline-block}#right_side_toolbar{overflow:hidden;float:right;display:inline-block}#path{margin-left:10px;border-bottom:1px solid}#output_area{display:flex;justify-content:space-between}#output_toolbar{margin-left:5px;margin-right:5px}#right_side_close{float:right;margin:0;line-height:0px}#preview_titlebar{display:flex;justify-content:space-between;padding-left:5px;padding-right:5px}#output{max-height:150px;overflow:auto;word-break:break-all;flex-grow:none}#status_bar{padding-right:5px;padding-left:5px}p{margin:5px 10px 0}.btn-link{cursor:pointer;background:none;border:none}.btn-link:hover{text-decoration:underline}button,select,option,.icon,.divider{color:inherit;background-color:inherit;border:none}button{cursor:pointer}button:hover,#theme:hover{filter:invert(50%) contrast(100%)}#eval{display:none}.divider{margin-top:25px;display:flex;flex-direction:row;-webkit-user-select:none;-ms-user-select:none;user-select:none}.divider-content{color:#6c8dd3;overflow:nowrap;text-align:center;text-justify:center}.divider-part{display:inline;border:.5px solid inherit;flex-grow:3}.cm-s-colorforth.CodeMirror{background:#000;color:#f8f8f8}.cm-s-colorforth .CodeMirror-gutters{background:#0a001f;border-right:1px solid #aaa}.cm-s-colorforth .CodeMirror-guttermarker{color:#ffbd40}.cm-s-colorforth .CodeMirror-guttermarker-subtle{color:#78846f}.cm-s-colorforth .CodeMirror-linenumber{color:#bababa}.cm-s-colorforth .CodeMirror-cursor{border-left:1px solid white}.cm-s-colorforth span.cm-comment{color:#ededed}.cm-s-colorforth span.cm-def{color:#ff1c1c;font-weight:700}.cm-s-colorforth span.cm-keyword{color:#ffd900}.cm-s-colorforth span.cm-builtin{color:#00d95a}.cm-s-colorforth span.cm-variable{color:#73ff00}.cm-s-colorforth span.cm-string{color:#007bff}.cm-s-colorforth span.cm-number{color:#00c4ff}.cm-s-colorforth span.cm-atom{color:#606060}.cm-s-colorforth span.cm-variable-2{color:#eee}.cm-s-colorforth span.cm-variable-3,.cm-s-colorforth span.cm-type{color:#ddd}.cm-s-colorforth span.cm-meta{color:#ff0}.cm-s-colorforth span.cm-qualifier{color:#fff700}.cm-s-colorforth span.cm-bracket{color:#cc7}.cm-s-colorforth span.cm-tag{color:#ffbd40}.cm-s-colorforth span.cm-attribute{color:#fff700}.cm-s-colorforth span.cm-error{color:red}.cm-s-colorforth div.CodeMirror-selected{background:#333d53}.cm-s-colorforth span.cm-compilation{background:#ffffff1f}.cm-s-colorforth .CodeMirror-activeline-background{background:#253540}.cm-s-eclipse span.cm-meta{color:#ff1717}.cm-s-eclipse span.cm-keyword{line-height:1em;font-weight:700;color:#7f0055}.cm-s-eclipse span.cm-atom{color:#219}.cm-s-eclipse span.cm-number{color:#164}.cm-s-eclipse span.cm-def{color:#00f}.cm-s-eclipse span.cm-variable{color:#000}.cm-s-eclipse span.cm-variable-2,.cm-s-eclipse span.cm-variable-3,.cm-s-eclipse span.cm-type{color:#0000c0}.cm-s-eclipse span.cm-property,.cm-s-eclipse span.cm-operator{color:#000}.cm-s-eclipse span.cm-comment{color:#3f7f5f}.cm-s-eclipse span.cm-string{color:#2a00ff}.cm-s-eclipse span.cm-string-2{color:#f50}.cm-s-eclipse span.cm-qualifier{color:#555}.cm-s-eclipse span.cm-builtin{color:#30a}.cm-s-eclipse span.cm-bracket{color:#cc7}.cm-s-eclipse span.cm-tag{color:#170}.cm-s-eclipse span.cm-attribute{color:#00c}.cm-s-eclipse span.cm-link{color:#219}.cm-s-eclipse span.cm-error{color:red}.cm-s-eclipse .CodeMirror-activeline-background{background:#e8f2ff}.cm-s-eclipse .CodeMirror-matchingbracket{outline:1px solid grey;color:#000!important}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483e}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:#49483efc}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:#49483efc}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0px}.cm-s-monokai .CodeMirror-guttermarker{color:#fff}.cm-s-monokai .CodeMirror-guttermarker-subtle,.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom,.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-comment.cm-attribute{color:#97b757}.cm-s-monokai span.cm-comment.cm-def{color:#bc9262}.cm-s-monokai span.cm-comment.cm-tag{color:#bc6283}.cm-s-monokai span.cm-comment.cm-type{color:#5998a6}.cm-s-monokai span.cm-property,.cm-s-monokai span.cm-attribute{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-builtin{color:#66d9ef}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header,.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-night.CodeMirror{background:#0a001f;color:#f8f8f8}.cm-s-night div.CodeMirror-selected{background:#447}.cm-s-night .CodeMirror-line::selection,.cm-s-night .CodeMirror-line>span::selection,.cm-s-night .CodeMirror-line>span>span::selection{background:#444477fc}.cm-s-night .CodeMirror-line::-moz-selection,.cm-s-night .CodeMirror-line>span::-moz-selection,.cm-s-night .CodeMirror-line>span>span::-moz-selection{background:#444477fc}.cm-s-night .CodeMirror-gutters{background:#0a001f;border-right:1px solid #aaa}.cm-s-night .CodeMirror-guttermarker{color:#fff}.cm-s-night .CodeMirror-guttermarker-subtle{color:#bbb}.cm-s-night .CodeMirror-linenumber{color:#f8f8f8}.cm-s-night .CodeMirror-cursor{border-left:1px solid white}.cm-s-night span.cm-comment{color:#8900d1}.cm-s-night span.cm-atom{color:#845dc4}.cm-s-night span.cm-number,.cm-s-night span.cm-attribute{color:#ffd500}.cm-s-night span.cm-keyword{color:#599eff}.cm-s-night span.cm-string{color:#37f14a}.cm-s-night span.cm-meta{color:#7678e2}.cm-s-night span.cm-variable-2,.cm-s-night span.cm-tag{color:#99b2ff}.cm-s-night span.cm-variable-3,.cm-s-night span.cm-def,.cm-s-night span.cm-type{color:#fff}.cm-s-night span.cm-bracket{color:#8da6ce}.cm-s-night span.cm-builtin,.cm-s-night span.cm-special{color:#ff9e59}.cm-s-night span.cm-link{color:#845dc4}.cm-s-night span.cm-error{color:#9d1e15}.cm-s-night .CodeMirror-activeline-background{background:#1c005a}.cm-s-night .CodeMirror-matchingbracket{outline:1px solid grey;color:#fff!important}.solarized.base03{color:#002b36}.solarized.base02{color:#073642}.solarized.base01{color:#586e75}.solarized.base00{color:#657b83}.solarized.base0{color:#839496}.solarized.base1{color:#93a1a1}.solarized.base2{color:#eee8d5}.solarized.base3{color:#fdf6e3}.solarized.solar-yellow{color:#b58900}.solarized.solar-orange{color:#cb4b16}.solarized.solar-red{color:#dc322f}.solarized.solar-magenta{color:#d33682}.solarized.solar-violet{color:#6c71c4}.solarized.solar-blue{color:#268bd2}.solarized.solar-cyan{color:#2aa198}.solarized.solar-green{color:#859900}.cm-s-solarized{line-height:1.45em;color-profile:sRGB;rendering-intent:auto}.cm-s-solarized.cm-s-dark{color:#839496;background-color:#002b36}.cm-s-solarized.cm-s-light{background-color:#fdf6e3;color:#657b83}.cm-s-solarized .CodeMirror-widget{text-shadow:none}.cm-s-solarized .cm-header{color:#586e75}.cm-s-solarized .cm-quote{color:#93a1a1}.cm-s-solarized .cm-keyword{color:#cb4b16}.cm-s-solarized .cm-atom,.cm-s-solarized .cm-number{color:#d33682}.cm-s-solarized .cm-def{color:#2aa198}.cm-s-solarized .cm-variable{color:#839496}.cm-s-solarized .cm-variable-2{color:#b58900}.cm-s-solarized .cm-variable-3,.cm-s-solarized .cm-type{color:#6c71c4}.cm-s-solarized .cm-property{color:#2aa198}.cm-s-solarized .cm-operator{color:#6c71c4}.cm-s-solarized .cm-comment{color:#586e75;font-style:italic}.cm-s-solarized .cm-string{color:#859900}.cm-s-solarized .cm-string-2{color:#b58900}.cm-s-solarized .cm-meta{color:#859900}.cm-s-solarized .cm-qualifier{color:#b58900}.cm-s-solarized .cm-builtin{color:#d33682}.cm-s-solarized .cm-bracket{color:#cb4b16}.cm-s-solarized .CodeMirror-matchingbracket{color:#859900}.cm-s-solarized .CodeMirror-nonmatchingbracket{color:#dc322f}.cm-s-solarized .cm-tag{color:#93a1a1}.cm-s-solarized .cm-attribute{color:#2aa198}.cm-s-solarized .cm-hr{color:transparent;border-top:1px solid #586e75;display:block}.cm-s-solarized .cm-link{color:#93a1a1;cursor:pointer}.cm-s-solarized .cm-special{color:#6c71c4}.cm-s-solarized .cm-em{color:#999;text-decoration:underline;text-decoration-style:dotted}.cm-s-solarized .cm-error,.cm-s-solarized .cm-invalidchar{color:#586e75;border-bottom:1px dotted #dc322f}.cm-s-solarized.cm-s-dark div.CodeMirror-selected{background:#073642}.cm-s-solarized.cm-s-dark.CodeMirror ::selection{background:#073642fc}.cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection,.cm-s-dark .CodeMirror-line>span::-moz-selection,.cm-s-dark .CodeMirror-line>span>span::-moz-selection{background:#073642fc}.cm-s-solarized.cm-s-light div.CodeMirror-selected{background:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-line::selection,.cm-s-light .CodeMirror-line>span::selection,.cm-s-light .CodeMirror-line>span>span::selection{background:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection,.cm-s-light .CodeMirror-line>span::-moz-selection,.cm-s-light .CodeMirror-line>span>span::-moz-selection{background:#eee8d5}.cm-s-solarized.CodeMirror{-moz-box-shadow:inset 7px 0 12px -6px #000;-webkit-box-shadow:inset 7px 0 12px -6px #000;box-shadow:inset 7px 0 12px -6px #000}.cm-s-solarized .CodeMirror-gutters{border-right:0}.cm-s-solarized.cm-s-dark .CodeMirror-gutters{background-color:#073642}.cm-s-solarized.cm-s-dark .CodeMirror-linenumber{color:#586e75}.cm-s-solarized.cm-s-light .CodeMirror-gutters{background-color:#eee8d5}.cm-s-solarized.cm-s-light .CodeMirror-linenumber{color:#839496}.cm-s-solarized .CodeMirror-linenumber{padding:0 5px}.cm-s-solarized .CodeMirror-guttermarker-subtle{color:#586e75}.cm-s-solarized.cm-s-dark .CodeMirror-guttermarker{color:#ddd}.cm-s-solarized.cm-s-light .CodeMirror-guttermarker{color:#cb4b16}.cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text{color:#586e75}.cm-s-solarized .CodeMirror-cursor{border-left:1px solid #819090}.cm-s-solarized.cm-s-light.cm-fat-cursor .CodeMirror-cursor{background:#7e7}.cm-s-solarized.cm-s-light .cm-animate-fat-cursor{background-color:#7e7}.cm-s-solarized.cm-s-dark.cm-fat-cursor .CodeMirror-cursor{background:#586e75}.cm-s-solarized.cm-s-dark .cm-animate-fat-cursor{background-color:#586e75}.cm-s-solarized.cm-s-dark .CodeMirror-activeline-background{background:#ffffff0f}.cm-s-solarized.cm-s-light .CodeMirror-activeline-background{background:#0000000f}.cm-s-the-matrix.CodeMirror{background:#000;color:#0f0}.cm-s-the-matrix div.CodeMirror-selected{background:#2d2d2d}.cm-s-the-matrix .CodeMirror-line::selection,.cm-s-the-matrix .CodeMirror-line>span::selection,.cm-s-the-matrix .CodeMirror-line>span>span::selection{background:#2d2d2dfc}.cm-s-the-matrix .CodeMirror-line::-moz-selection,.cm-s-the-matrix .CodeMirror-line>span::-moz-selection,.cm-s-the-matrix .CodeMirror-line>span>span::-moz-selection{background:#2d2d2dfc}.cm-s-the-matrix .CodeMirror-gutters{background:#060;border-right:2px solid #00FF00}.cm-s-the-matrix .CodeMirror-guttermarker{color:#0f0}.cm-s-the-matrix .CodeMirror-guttermarker-subtle,.cm-s-the-matrix .CodeMirror-linenumber{color:#fff}.cm-s-the-matrix .CodeMirror-cursor{border-left:1px solid #00FF00}.cm-s-the-matrix span.cm-keyword{color:#008803;font-weight:700}.cm-s-the-matrix span.cm-atom{color:#3ff}.cm-s-the-matrix span.cm-number{color:#ffb94f}.cm-s-the-matrix span.cm-def{color:#99c}.cm-s-the-matrix span.cm-variable{color:#f6c}.cm-s-the-matrix span.cm-variable-2{color:#c6f}.cm-s-the-matrix span.cm-variable-3,.cm-s-the-matrix span.cm-type{color:#96f}.cm-s-the-matrix span.cm-property{color:#62ffa0}.cm-s-the-matrix span.cm-operator{color:#999}.cm-s-the-matrix span.cm-comment{color:#ccc}.cm-s-the-matrix span.cm-string{color:#39c}.cm-s-the-matrix span.cm-meta{color:#c9f}.cm-s-the-matrix span.cm-qualifier{color:#fff700}.cm-s-the-matrix span.cm-builtin{color:#30a}.cm-s-the-matrix span.cm-bracket{color:#cc7}.cm-s-the-matrix span.cm-tag{color:#ffbd40}.cm-s-the-matrix span.cm-attribute{color:#fff700}.cm-s-the-matrix span.cm-error{color:red}.cm-s-the-matrix .CodeMirror-activeline-background{background:#040}.cm-s-ttcn .cm-quote{color:#f00000}.cm-s-ttcn .cm-header,.cm-strong{font-weight:700}.cm-s-ttcn .cm-link{text-decoration:underline}.cm-s-ttcn .cm-header{color:#00f000;font-weight:700}.cm-s-ttcn .cm-atom{color:#219}.cm-s-ttcn .cm-attribute{color:#00c000}.cm-s-ttcn .cm-bracket{color:#997000}.cm-s-ttcn .cm-comment{color:green}.cm-s-ttcn .cm-def{color:#00f000}.cm-s-ttcn .cm-em{font-style:italic}.cm-s-ttcn .cm-error{color:#f00000}.cm-s-ttcn .cm-hr{color:#999000}.cm-s-ttcn .cm-keyword{color:purple;font-weight:700}.cm-s-ttcn .cm-link{color:#00c;text-decoration:underline}.cm-s-ttcn .cm-meta{color:#555000}.cm-s-ttcn .cm-negative{color:#d44000}.cm-s-ttcn .cm-positive{color:#292000}.cm-s-ttcn .cm-qualifier{color:#555000}.cm-s-ttcn .cm-strikethrough{text-decoration:line-through}.cm-s-ttcn .cm-string{color:#8b0000}.cm-s-ttcn .cm-string-2{color:#f50000}.cm-s-ttcn .cm-strong{font-weight:700}.cm-s-ttcn .cm-tag{color:#170}.cm-s-ttcn .cm-variable{color:olive}.cm-s-ttcn .cm-variable-2{color:#05a000}.cm-s-ttcn .cm-variable-3,.cm-s-ttcn .cm-type{color:#085000}.cm-s-ttcn .cm-invalidchar{color:#f00000}.cm-s-ttcn .cm-accessTypes,.cm-s-ttcn .cm-compareTypes{color:#27408b}.cm-s-ttcn .cm-cmipVerbs{color:#8b2252}.cm-s-ttcn .cm-modifier{color:#d2691e}.cm-s-ttcn .cm-status{color:#8b4545}.cm-s-ttcn .cm-storage{color:#a020f0}.cm-s-ttcn .cm-tags{color:#006400}.cm-s-ttcn .cm-externalCommands{color:#8b4545;font-weight:700}.cm-s-ttcn .cm-fileNCtrlMaskOptions,.cm-s-ttcn .cm-sectionTitle{color:#2e8b57;font-weight:700}.cm-s-ttcn .cm-booleanConsts,.cm-s-ttcn .cm-otherConsts,.cm-s-ttcn .cm-verdictConsts{color:#006400}.cm-s-ttcn .cm-configOps,.cm-s-ttcn .cm-functionOps,.cm-s-ttcn .cm-portOps,.cm-s-ttcn .cm-sutOps,.cm-s-ttcn .cm-timerOps,.cm-s-ttcn .cm-verdictOps{color:#00f}.cm-s-ttcn .cm-preprocessor,.cm-s-ttcn .cm-templateMatch,.cm-s-ttcn .cm-ttcn3Macros{color:#27408b}.cm-s-ttcn .cm-types{color:brown;font-weight:700}.cm-s-ttcn .cm-visibilityModifiers{font-weight:700}.cm-s-ayu-dark.CodeMirror{background:#0a0e14;color:#b3b1ad}.cm-s-ayu-dark div.CodeMirror-selected{background:#273747}.cm-s-ayu-dark .CodeMirror-line::selection,.cm-s-ayu-dark .CodeMirror-line>span::selection,.cm-s-ayu-dark .CodeMirror-line>span>span::selection{background:#273747}.cm-s-ayu-dark .CodeMirror-line::-moz-selection,.cm-s-ayu-dark .CodeMirror-line>span::-moz-selection,.cm-s-ayu-dark .CodeMirror-line>span>span::-moz-selection{background:#273747}.cm-s-ayu-dark .CodeMirror-gutters{background:#0a0e14;border-right:0px}.cm-s-ayu-dark .CodeMirror-guttermarker{color:#fff}.cm-s-ayu-dark .CodeMirror-guttermarker-subtle,.cm-s-ayu-dark .CodeMirror-linenumber{color:#3d424d}.cm-s-ayu-dark .CodeMirror-cursor{border-left:1px solid #e6b450}.cm-s-ayu-dark.cm-fat-cursor .CodeMirror-cursor,.cm-s-ayu-dark .cm-animate-fat-cursor{background-color:#a2a8a175!important}.cm-s-ayu-dark span.cm-comment{color:#626a73}.cm-s-ayu-dark span.cm-atom{color:#ae81ff}.cm-s-ayu-dark span.cm-number{color:#e6b450}.cm-s-ayu-dark span.cm-comment.cm-attribute{color:#ffb454}.cm-s-ayu-dark span.cm-comment.cm-def,.cm-s-ayu-dark span.cm-comment.cm-tag{color:#39bae6}.cm-s-ayu-dark span.cm-comment.cm-type{color:#5998a6}.cm-s-ayu-dark span.cm-property,.cm-s-ayu-dark span.cm-attribute{color:#ffb454}.cm-s-ayu-dark span.cm-keyword{color:#ff8f40}.cm-s-ayu-dark span.cm-builtin{color:#e6b450}.cm-s-ayu-dark span.cm-string{color:#c2d94c}.cm-s-ayu-dark span.cm-variable{color:#b3b1ad}.cm-s-ayu-dark span.cm-variable-2{color:#f07178}.cm-s-ayu-dark span.cm-variable-3{color:#39bae6}.cm-s-ayu-dark span.cm-type{color:#ff8f40}.cm-s-ayu-dark span.cm-def{color:#fe9}.cm-s-ayu-dark span.cm-bracket{color:#f8f8f2}.cm-s-ayu-dark span.cm-tag{color:#39bae6}.cm-s-ayu-dark span.cm-header{color:#c2d94c}.cm-s-ayu-dark span.cm-link{color:#39bae6}.cm-s-ayu-dark span.cm-error{color:#f33}.cm-s-ayu-dark .CodeMirror-activeline-background{background:#01060e}.cm-s-ayu-dark .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-mbo.CodeMirror{background:#2c2c2c;color:#ffffec}.cm-s-mbo div.CodeMirror-selected{background:#716c62}.cm-s-mbo .CodeMirror-line::selection,.cm-s-mbo .CodeMirror-line>span::selection,.cm-s-mbo .CodeMirror-line>span>span::selection{background:#716c62fc}.cm-s-mbo .CodeMirror-line::-moz-selection,.cm-s-mbo .CodeMirror-line>span::-moz-selection,.cm-s-mbo .CodeMirror-line>span>span::-moz-selection{background:#716c62fc}.cm-s-mbo .CodeMirror-gutters{background:#4e4e4e;border-right:0px}.cm-s-mbo .CodeMirror-guttermarker{color:#fff}.cm-s-mbo .CodeMirror-guttermarker-subtle{color:gray}.cm-s-mbo .CodeMirror-linenumber{color:#dadada}.cm-s-mbo .CodeMirror-cursor{border-left:1px solid #ffffec}.cm-s-mbo span.cm-comment{color:#95958a}.cm-s-mbo span.cm-atom,.cm-s-mbo span.cm-number{color:#00a8c6}.cm-s-mbo span.cm-property,.cm-s-mbo span.cm-attribute{color:#9ddfe9}.cm-s-mbo span.cm-keyword{color:#ffb928}.cm-s-mbo span.cm-string{color:#ffcf6c}.cm-s-mbo span.cm-string.cm-property,.cm-s-mbo span.cm-variable{color:#ffffec}.cm-s-mbo span.cm-variable-2{color:#00a8c6}.cm-s-mbo span.cm-def{color:#ffffec}.cm-s-mbo span.cm-bracket{color:#fffffc;font-weight:700}.cm-s-mbo span.cm-tag{color:#9ddfe9}.cm-s-mbo span.cm-link{color:#f54b07}.cm-s-mbo span.cm-error{border-bottom:#636363;color:#ffffec}.cm-s-mbo span.cm-qualifier{color:#ffffec}.cm-s-mbo .CodeMirror-activeline-background{background:#494b41}.cm-s-mbo .CodeMirror-matchingbracket{color:#ffb928!important}.cm-s-mbo .CodeMirror-matchingtag{background:#ffffff5e}.cm-s-midnight .CodeMirror-activeline-background{background:#253540}.cm-s-midnight.CodeMirror{background:#0f192a;color:#d1edff}.cm-s-midnight div.CodeMirror-selected{background:#314d67}.cm-s-midnight .CodeMirror-line::selection,.cm-s-midnight .CodeMirror-line>span::selection,.cm-s-midnight .CodeMirror-line>span>span::selection{background:#314d67fc}.cm-s-midnight .CodeMirror-line::-moz-selection,.cm-s-midnight .CodeMirror-line>span::-moz-selection,.cm-s-midnight .CodeMirror-line>span>span::-moz-selection{background:#314d67fc}.cm-s-midnight .CodeMirror-gutters{background:#0f192a;border-right:1px solid}.cm-s-midnight .CodeMirror-guttermarker{color:#fff}.cm-s-midnight .CodeMirror-guttermarker-subtle,.cm-s-midnight .CodeMirror-linenumber{color:#d0d0d0}.cm-s-midnight .CodeMirror-cursor{border-left:1px solid #F8F8F0}.cm-s-midnight span.cm-comment{color:#428bdd}.cm-s-midnight span.cm-atom{color:#ae81ff}.cm-s-midnight span.cm-number{color:#d1edff}.cm-s-midnight span.cm-property,.cm-s-midnight span.cm-attribute{color:#a6e22e}.cm-s-midnight span.cm-keyword{color:#e83737}.cm-s-midnight span.cm-string{color:#1dc116}.cm-s-midnight span.cm-variable,.cm-s-midnight span.cm-variable-2{color:#ffaa3e}.cm-s-midnight span.cm-def{color:#4dd}.cm-s-midnight span.cm-bracket{color:#d1edff}.cm-s-midnight span.cm-tag{color:#449}.cm-s-midnight span.cm-link{color:#ae81ff}.cm-s-midnight span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-midnight .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-moxer.CodeMirror{background-color:#090a0f;color:#8e95b4;line-height:1.8}.cm-s-moxer .CodeMirror-gutters{background:#090a0f;color:#35394b;border:none}.cm-s-moxer .CodeMirror-guttermarker,.cm-s-moxer .CodeMirror-guttermarker-subtle,.cm-s-moxer .CodeMirror-linenumber{color:#35394b}.cm-s-moxer .CodeMirror-cursor{border-left:1px solid #FFCC00}.cm-s-moxer div.CodeMirror-selected{background:#80cbc433}.cm-s-moxer.CodeMirror-focused div.CodeMirror-selected{background:#212431}.cm-s-moxer .CodeMirror-line::selection,.cm-s-moxer .CodeMirror-line>span::selection,.cm-s-moxer .CodeMirror-line>span>span::selection{background:#212431}.cm-s-moxer .CodeMirror-line::-moz-selection,.cm-s-moxer .CodeMirror-line>span::-moz-selection,.cm-s-moxer .CodeMirror-line>span>span::-moz-selection{background:#212431}.cm-s-moxer .CodeMirror-activeline-background,.cm-s-moxer .CodeMirror-activeline-gutter .CodeMirror-linenumber{background:#21243180}.cm-s-moxer .cm-keyword,.cm-s-moxer .cm-operator{color:#d46c6c}.cm-s-moxer .cm-variable-2{color:#81c5da}.cm-s-moxer .cm-variable-3,.cm-s-moxer .cm-type{color:#f07178}.cm-s-moxer .cm-builtin{color:#ffcb6b}.cm-s-moxer .cm-atom{color:#a99be2}.cm-s-moxer .cm-number{color:#7ca4c0}.cm-s-moxer .cm-def{color:#f5dfa5}.cm-s-moxer .CodeMirror-line .cm-def~.cm-def{color:#81c5da}.cm-s-moxer .cm-string{color:#b2e4ae}.cm-s-moxer .cm-string-2{color:#f07178}.cm-s-moxer .cm-comment{color:#3f445a}.cm-s-moxer .cm-variable{color:#8e95b4}.cm-s-moxer .cm-tag{color:#ff5370}.cm-s-moxer .cm-meta{color:#ffcb6b}.cm-s-moxer .cm-attribute{color:#c792ea}.cm-s-moxer .cm-property{color:#81c5da}.cm-s-moxer .cm-qualifier,.cm-s-moxer .cm-variable-3,.cm-s-moxer .cm-type{color:#decb6b}.cm-s-moxer .cm-error{color:#fff;background-color:#ff5370}.cm-s-moxer .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}.cm-s-panda-syntax{background:#292a2b;color:#e6e6e6;font-family:Operator Mono,Source Code Pro,Menlo,Monaco,Consolas,Courier New,monospace}.cm-s-panda-syntax .CodeMirror-cursor{border-color:#ff2c6d}.cm-s-panda-syntax .CodeMirror-activeline-background{background:#637b9c1a}.cm-s-panda-syntax .CodeMirror-selected{background:#fff}.cm-s-panda-syntax .cm-comment{font-style:italic;color:#676b79}.cm-s-panda-syntax .cm-operator{color:#f3f3f3}.cm-s-panda-syntax .cm-string{color:#19f9d8}.cm-s-panda-syntax .cm-string-2{color:#ffb86c}.cm-s-panda-syntax .cm-tag{color:#ff2c6d}.cm-s-panda-syntax .cm-meta{color:#b084eb}.cm-s-panda-syntax .cm-number{color:#ffb86c}.cm-s-panda-syntax .cm-atom{color:#ff2c6d}.cm-s-panda-syntax .cm-keyword{color:#ff75b5}.cm-s-panda-syntax .cm-variable{color:#ffb86c}.cm-s-panda-syntax .cm-variable-2,.cm-s-panda-syntax .cm-variable-3,.cm-s-panda-syntax .cm-type{color:#ff9ac1}.cm-s-panda-syntax .cm-def{color:#e6e6e6}.cm-s-panda-syntax .cm-property{color:#f3f3f3}.cm-s-panda-syntax .cm-unit,.cm-s-panda-syntax .cm-attribute{color:#ffb86c}.cm-s-panda-syntax .CodeMirror-matchingbracket{border-bottom:1px dotted #19F9D8;padding-bottom:2px;color:#e6e6e6}.cm-s-panda-syntax .CodeMirror-gutters{background:#292a2b;border-right-color:#ffffff1a}.cm-s-panda-syntax .CodeMirror-linenumber{color:#e6e6e6;opacity:.6}.cm-s-tomorrow-night-eighties.CodeMirror{background:#000;color:#ccc}.cm-s-tomorrow-night-eighties div.CodeMirror-selected{background:#2d2d2d}.cm-s-tomorrow-night-eighties .CodeMirror-line::selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span::selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span>span::selection{background:#2d2d2dfc}.cm-s-tomorrow-night-eighties .CodeMirror-line::-moz-selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span::-moz-selection,.cm-s-tomorrow-night-eighties .CodeMirror-line>span>span::-moz-selection{background:#2d2d2dfc}.cm-s-tomorrow-night-eighties .CodeMirror-gutters{background:#000;border-right:0px}.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker{color:#f2777a}.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker-subtle{color:#777}.cm-s-tomorrow-night-eighties .CodeMirror-linenumber{color:#515151}.cm-s-tomorrow-night-eighties .CodeMirror-cursor{border-left:1px solid #6A6A6A}.cm-s-tomorrow-night-eighties span.cm-comment{color:#d27b53}.cm-s-tomorrow-night-eighties span.cm-atom,.cm-s-tomorrow-night-eighties span.cm-number{color:#a16a94}.cm-s-tomorrow-night-eighties span.cm-property,.cm-s-tomorrow-night-eighties span.cm-attribute{color:#9c9}.cm-s-tomorrow-night-eighties span.cm-keyword{color:#f2777a}.cm-s-tomorrow-night-eighties span.cm-string{color:#fc6}.cm-s-tomorrow-night-eighties span.cm-variable{color:#9c9}.cm-s-tomorrow-night-eighties span.cm-variable-2{color:#69c}.cm-s-tomorrow-night-eighties span.cm-def{color:#f99157}.cm-s-tomorrow-night-eighties span.cm-bracket{color:#ccc}.cm-s-tomorrow-night-eighties span.cm-tag{color:#f2777a}.cm-s-tomorrow-night-eighties span.cm-link{color:#a16a94}.cm-s-tomorrow-night-eighties span.cm-error{background:#f2777a;color:#6a6a6a}.cm-s-tomorrow-night-eighties .CodeMirror-activeline-background{background:#343600}.cm-s-tomorrow-night-eighties .CodeMirror-matchingbracket{text-decoration:underline;color:#fff!important}
</style>
	</head>
	<body style="visibility: hidden;">
		<div id="wrapper" class="CodeMirror">
			<div id="container">							
				<div id="editor_output">
					<div id="tabs_toolbar">
					<div id="editor_toolbar">
						<div id="left_side_toolbar" >
							<button id="run">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 384 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80L0 432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg>
							</button>
						</div>
						<div id="right_side_toolbar">
							<button id="srccode">
								<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 640 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3L562.7 256l-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"/></svg>
							</button>
							<select name="theme" id="theme" class="icon">
								<option id="theme_ttcn" value="ttcn"></option>
								<option id="theme_default" value="default"></option>
								<option id="theme_solarized_light" value="solarized"></option>
								<option id="theme_eclipse" value="eclipse"></option>
								<option id="theme_midnight" value="midnight"></option>
								<option id="theme_panda_syntax" value="panda-syntax"></option>
								<option id="theme_tomorrow_night_eighties" value="tomorrow-night-eighties"></option>
								<option id="theme_night" value="night"></option>
								<option id="theme_colorforth" value="colorforth"></option>								
								<option id="theme_monokai" value="monokai"></option>
								<option id="theme_the_matrix" value="the-matrix"></option>
								<option id="theme_ayu_dark" value="ayu-dark"></option>
								<option id="theme_moxer" value="moxer"></option>
								<option id="theme_mbo" value="mbo"></option>						
							</select>					
						</div>
					</div>		
					</div>
					<div id="side_by_side">
						<div id="left_side">
							<div id="left_side_titlebar">
								<label id="left_side_label"></label>
								<span id="src_opts">
								</span>
							</div>
							<textarea id="code" name="code"></textarea>
					    </div>
						<div id="right_side">
							<div id = "right_side_titlebar">
								<label id="right_side_label"></label>
								 <button id="right_side_close">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/></svg>
								 </button>
							</div>
							<textarea id="target_code" name="target_code"></textarea>
						</div>
						<div id="preview">
							<div id="preview_titlebar">
								<label id="preview_label"></label>
								<button id="preview_close" class="icon" style="padding: 0px; margin: 0px;">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM175 175c9.4-9.4 24.6-9.4 33.9 0l47 47 47-47c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-47 47 47 47c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-47-47-47 47c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l47-47-47-47c-9.4-9.4-9.4-24.6 0-33.9z"/></svg>
								</button>
							</div>
							<iframe id="preview_area"></iframe>							
							
						</div>
					</div>			
					<div id="output_container">
						<div id="output_area">
							<label id="output_label"></label>		
							<div id="output_toolbar">
								<button id="clear">
									<svg class="icon" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 576 512">!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path fill="currentColor" d="M566.6 54.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192-34.7-34.7c-4.2-4.2-10-6.6-16-6.6c-12.5 0-22.6 10.1-22.6 22.6l0 29.1L364.3 320l29.1 0c12.5 0 22.6-10.1 22.6-22.6c0-6-2.4-11.8-6.6-16l-34.7-34.7 192-192zM341.1 353.4L222.6 234.9c-42.7-3.7-85.2 11.7-115.8 42.3l-8 8C76.5 307.5 64 337.7 64 369.2c0 6.8 7.1 11.2 13.2 8.2l51.1-25.5c5-2.5 9.5 4.1 5.4 7.9L7.3 473.4C2.7 477.6 0 483.6 0 489.9C0 502.1 9.9 512 22.1 512l173.3 0c38.8 0 75.9-15.4 103.4-42.8c30.6-30.6 45.9-73.1 42.3-115.8z"/></svg>
								</button>
							</div>		
						</div>	
						<div id="output" class="CodeMirror"></div>
					</div>
				</div>
			</div>
		</div>	
		<footer id="status_bar"></footer>		
		<div id="eval"></div>
	</body>
</html>`
                const iframe = document.createElement('iframe');
                iframe.id = id;
                iframe.sandbox = 'allow-forms allow-scripts allow-same-origin';
                iframe.setAttribute("style","width:100%; height: 100%;");
                // iframe.src = 'data:text/html,'; 
                parent.replaceChildren()
                parent.appendChild(iframe)
                const iframe_win = iframe.contentWindow || iframe;                
                // iframe_win.opts = opts ;
                iframe.srcdoc = ` ${code.replace("'%SEEN_EDITOR__OPTS%'", `${JSON.stringify(opts)}`)} `;
                return iframe
              }                
              